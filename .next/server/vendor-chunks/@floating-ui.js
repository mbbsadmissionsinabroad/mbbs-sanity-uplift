"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@floating-ui";
exports.ids = ["vendor-chunks/@floating-ui"];
exports.modules = {

/***/ "(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.autoPlacement),\n/* harmony export */   autoUpdate: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.autoUpdate),\n/* harmony export */   computePosition: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.detectOverflow),\n/* harmony export */   flip: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.hide),\n/* harmony export */   inline: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.inline),\n/* harmony export */   limitShift: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.limitShift),\n/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.offset),\n/* harmony export */   platform: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.platform),\n/* harmony export */   shift: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.shift),\n/* harmony export */   size: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.size),\n/* harmony export */   useFloating: () => (/* binding */ useFloating)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\n/**\n * A data provider that provides data to position an inner element of the\n * floating element (usually a triangle or caret) so that it is centered to the\n * reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */ const arrow = (options)=>{\n    const { element, padding } = options;\n    function isRef(value) {\n        return Object.prototype.hasOwnProperty.call(value, \"current\");\n    }\n    return {\n        name: \"arrow\",\n        options,\n        fn (args) {\n            if (isRef(element)) {\n                if (element.current != null) {\n                    return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.arrow)({\n                        element: element.current,\n                        padding\n                    }).fn(args);\n                }\n                return {};\n            } else if (element) {\n                return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.arrow)({\n                    element,\n                    padding\n                }).fn(args);\n            }\n            return {};\n        }\n    };\n};\nvar index = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_2__.useEffect;\n// Fork of `fast-deep-equal` that only does the comparisons we need and compares\n// functions\nfunction deepEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (typeof a !== typeof b) {\n        return false;\n    }\n    if (typeof a === \"function\" && a.toString() === b.toString()) {\n        return true;\n    }\n    let length, i, keys;\n    if (a && b && typeof a == \"object\") {\n        if (Array.isArray(a)) {\n            length = a.length;\n            if (length != b.length) return false;\n            for(i = length; i-- !== 0;){\n                if (!deepEqual(a[i], b[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length) {\n            return false;\n        }\n        for(i = length; i-- !== 0;){\n            if (!Object.prototype.hasOwnProperty.call(b, keys[i])) {\n                return false;\n            }\n        }\n        for(i = length; i-- !== 0;){\n            const key = keys[i];\n            if (key === \"_owner\" && a.$$typeof) {\n                continue;\n            }\n            if (!deepEqual(a[key], b[key])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return a !== a && b !== b;\n}\nfunction useLatestRef(value) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_2__.useRef(value);\n    index(()=>{\n        ref.current = value;\n    });\n    return ref;\n}\n/**\n * Provides data to position a floating element.\n * @see https://floating-ui.com/docs/react\n */ function useFloating(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { placement = \"bottom\", strategy = \"absolute\", middleware = [], platform, whileElementsMounted, open } = options;\n    const [data, setData] = react__WEBPACK_IMPORTED_MODULE_2__.useState({\n        x: null,\n        y: null,\n        strategy,\n        placement,\n        middlewareData: {},\n        isPositioned: false\n    });\n    const [latestMiddleware, setLatestMiddleware] = react__WEBPACK_IMPORTED_MODULE_2__.useState(middleware);\n    if (!deepEqual(latestMiddleware, middleware)) {\n        setLatestMiddleware(middleware);\n    }\n    const referenceRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n    const floatingRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n    const dataRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(data);\n    const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n    const platformRef = useLatestRef(platform);\n    const [reference, _setReference] = react__WEBPACK_IMPORTED_MODULE_2__.useState(null);\n    const [floating, _setFloating] = react__WEBPACK_IMPORTED_MODULE_2__.useState(null);\n    const setReference = react__WEBPACK_IMPORTED_MODULE_2__.useCallback((node)=>{\n        if (referenceRef.current !== node) {\n            referenceRef.current = node;\n            _setReference(node);\n        }\n    }, []);\n    const setFloating = react__WEBPACK_IMPORTED_MODULE_2__.useCallback((node)=>{\n        if (floatingRef.current !== node) {\n            floatingRef.current = node;\n            _setFloating(node);\n        }\n    }, []);\n    const update = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(()=>{\n        if (!referenceRef.current || !floatingRef.current) {\n            return;\n        }\n        const config = {\n            placement,\n            strategy,\n            middleware: latestMiddleware\n        };\n        if (platformRef.current) {\n            config.platform = platformRef.current;\n        }\n        (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.computePosition)(referenceRef.current, floatingRef.current, config).then((data)=>{\n            const fullData = {\n                ...data,\n                isPositioned: true\n            };\n            if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n                dataRef.current = fullData;\n                react_dom__WEBPACK_IMPORTED_MODULE_3__.flushSync(()=>{\n                    setData(fullData);\n                });\n            }\n        });\n    }, [\n        latestMiddleware,\n        placement,\n        strategy,\n        platformRef\n    ]);\n    index(()=>{\n        if (open === false && dataRef.current.isPositioned) {\n            dataRef.current.isPositioned = false;\n            setData((data)=>({\n                    ...data,\n                    isPositioned: false\n                }));\n        }\n    }, [\n        open\n    ]);\n    const isMountedRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(false);\n    index(()=>{\n        isMountedRef.current = true;\n        return ()=>{\n            isMountedRef.current = false;\n        };\n    }, []);\n    index(()=>{\n        if (reference && floating) {\n            if (whileElementsMountedRef.current) {\n                return whileElementsMountedRef.current(reference, floating, update);\n            } else {\n                update();\n            }\n        }\n    }, [\n        reference,\n        floating,\n        update,\n        whileElementsMountedRef\n    ]);\n    const refs = react__WEBPACK_IMPORTED_MODULE_2__.useMemo(()=>({\n            reference: referenceRef,\n            floating: floatingRef,\n            setReference,\n            setFloating\n        }), [\n        setReference,\n        setFloating\n    ]);\n    const elements = react__WEBPACK_IMPORTED_MODULE_2__.useMemo(()=>({\n            reference,\n            floating\n        }), [\n        reference,\n        floating\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_2__.useMemo(()=>({\n            ...data,\n            update,\n            refs,\n            elements,\n            reference: setReference,\n            floating: setFloating\n        }), [\n        data,\n        update,\n        refs,\n        elements,\n        setReference,\n        setFloating\n    ]);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0LWRvbS9kaXN0L2Zsb2F0aW5nLXVpLnJlYWN0LWRvbS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFFO0FBQzhHO0FBQ3BKO0FBQ29CO0FBQ2I7QUFFdEM7Ozs7OztDQU1DLEdBQ0QsTUFBTUEsUUFBUW1CLENBQUFBO0lBQ1osTUFBTSxFQUNKQyxPQUFPLEVBQ1BDLE9BQU8sRUFDUixHQUFHRjtJQUNKLFNBQVNHLE1BQU1DLEtBQUs7UUFDbEIsT0FBT0MsT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osT0FBTztJQUNyRDtJQUNBLE9BQU87UUFDTEssTUFBTTtRQUNOVDtRQUNBVSxJQUFHQyxJQUFJO1lBQ0wsSUFBSVIsTUFBTUYsVUFBVTtnQkFDbEIsSUFBSUEsUUFBUVcsT0FBTyxJQUFJLE1BQU07b0JBQzNCLE9BQU85Qix1REFBT0EsQ0FBQzt3QkFDYm1CLFNBQVNBLFFBQVFXLE9BQU87d0JBQ3hCVjtvQkFDRixHQUFHUSxFQUFFLENBQUNDO2dCQUNSO2dCQUNBLE9BQU8sQ0FBQztZQUNWLE9BQU8sSUFBSVYsU0FBUztnQkFDbEIsT0FBT25CLHVEQUFPQSxDQUFDO29CQUNibUI7b0JBQ0FDO2dCQUNGLEdBQUdRLEVBQUUsQ0FBQ0M7WUFDUjtZQUNBLE9BQU8sQ0FBQztRQUNWO0lBQ0Y7QUFDRjtBQUVBLElBQUlFLFFBQVEsT0FBT0MsYUFBYSxjQUFjakIsa0RBQWVBLEdBQUdDLDRDQUFTQTtBQUV6RSxnRkFBZ0Y7QUFDaEYsWUFBWTtBQUNaLFNBQVNpQixVQUFVQyxDQUFDLEVBQUVDLENBQUM7SUFDckIsSUFBSUQsTUFBTUMsR0FBRztRQUNYLE9BQU87SUFDVDtJQUNBLElBQUksT0FBT0QsTUFBTSxPQUFPQyxHQUFHO1FBQ3pCLE9BQU87SUFDVDtJQUNBLElBQUksT0FBT0QsTUFBTSxjQUFjQSxFQUFFRSxRQUFRLE9BQU9ELEVB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Q0xpRCxhQUFhakQsT0FBTyxHQUFHO1FBQ3pCO0lBQ0YsR0FBRyxFQUFFO0lBQ0xDLE1BQU07UUFDSixJQUFJb0MsYUFBYUUsVUFBVTtZQUN6QixJQUFJSix3QkFBd0JuQyxPQUFPLEVBQUU7Z0JBQ25DLE9BQU9tQyx3QkFBd0JuQyxPQUFPLENBQUNxQyxXQUFXRSxVQUFVTTtZQUM5RCxPQUFPO2dCQUNMQTtZQUNGO1FBQ0Y7SUFDRixHQUFHO1FBQUNSO1FBQVdFO1FBQVVNO1FBQVFWO0tBQXdCO0lBQ3pELE1BQU1nQixPQUFPbkUsMENBQWEsQ0FBQyxJQUFPO1lBQ2hDcUQsV0FBV0w7WUFDWE8sVUFBVU47WUFDVlE7WUFDQUc7UUFDRixJQUFJO1FBQUNIO1FBQWNHO0tBQVk7SUFDL0IsTUFBTVMsV0FBV3JFLDBDQUFhLENBQUMsSUFBTztZQUNwQ3FEO1lBQ0FFO1FBQ0YsSUFBSTtRQUFDRjtRQUFXRTtLQUFTO0lBQ3pCLE9BQU92RCwwQ0FBYSxDQUFDLElBQU87WUFDMUIsR0FBR3VDLElBQUk7WUFDUHNCO1lBQ0FNO1lBQ0FFO1lBQ0FoQixXQUFXSTtZQUNYRixVQUFVSztRQUNaLElBQUk7UUFBQ3JCO1FBQU1zQjtRQUFRTTtRQUFNRTtRQUFVWjtRQUFjRztLQUFZO0FBQy9EO0FBRThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWRtaXNzaW9uLXVwbGlmdC8uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvcmVhY3QtZG9tL2Rpc3QvZmxvYXRpbmctdWkucmVhY3QtZG9tLmVzbS5qcz82ZjAwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFycm93IGFzIGFycm93JDEsIGNvbXB1dGVQb3NpdGlvbiB9IGZyb20gJ0BmbG9hdGluZy11aS9kb20nO1xuZXhwb3J0IHsgYXV0b1BsYWNlbWVudCwgYXV0b1VwZGF0ZSwgY29tcHV0ZVBvc2l0aW9uLCBkZXRlY3RPdmVyZmxvdywgZmxpcCwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMsIGhpZGUsIGlubGluZSwgbGltaXRTaGlmdCwgb2Zmc2V0LCBwbGF0Zm9ybSwgc2hpZnQsIHNpemUgfSBmcm9tICdAZmxvYXRpbmctdWkvZG9tJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxuLyoqXG4gKiBBIGRhdGEgcHJvdmlkZXIgdGhhdCBwcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGFuIGlubmVyIGVsZW1lbnQgb2YgdGhlXG4gKiBmbG9hdGluZyBlbGVtZW50ICh1c3VhbGx5IGEgdHJpYW5nbGUgb3IgY2FyZXQpIHNvIHRoYXQgaXQgaXMgY2VudGVyZWQgdG8gdGhlXG4gKiByZWZlcmVuY2UgZWxlbWVudC5cbiAqIFRoaXMgd3JhcHMgdGhlIGNvcmUgYGFycm93YCBtaWRkbGV3YXJlIHRvIGFsbG93IFJlYWN0IHJlZnMgYXMgdGhlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXJyb3dcbiAqL1xuY29uc3QgYXJyb3cgPSBvcHRpb25zID0+IHtcbiAgY29uc3Qge1xuICAgIGVsZW1lbnQsXG4gICAgcGFkZGluZ1xuICB9ID0gb3B0aW9ucztcbiAgZnVuY3Rpb24gaXNSZWYodmFsdWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY3VycmVudCcpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2Fycm93JyxcbiAgICBvcHRpb25zLFxuICAgIGZuKGFyZ3MpIHtcbiAgICAgIGlmIChpc1JlZihlbGVtZW50KSkge1xuICAgICAgICBpZiAoZWxlbWVudC5jdXJyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gYXJyb3ckMSh7XG4gICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LmN1cnJlbnQsXG4gICAgICAgICAgICBwYWRkaW5nXG4gICAgICAgICAgfSkuZm4oYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfSBlbHNlIGlmIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBhcnJvdyQxKHtcbiAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgIHBhZGRpbmdcbiAgICAgICAgfSkuZm4oYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxudmFyIGluZGV4ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcblxuLy8gRm9yayBvZiBgZmFzdC1kZWVwLWVxdWFsYCB0aGF0IG9ubHkgZG9lcyB0aGUgY29tcGFyaXNvbnMgd2UgbmVlZCBhbmQgY29tcGFyZXNcbi8vIGZ1bmN0aW9uc1xuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIGEgIT09IHR5cGVvZiBiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJyAmJiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGxldCBsZW5ndGgsIGksIGtleXM7XG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoa2V5ID09PSAnX293bmVyJyAmJiBhLiQkdHlwZW9mKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGEgIT09IGEgJiYgYiAhPT0gYjtcbn1cblxuZnVuY3Rpb24gdXNlTGF0ZXN0UmVmKHZhbHVlKSB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZih2YWx1ZSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlZjtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGEgZmxvYXRpbmcgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9yZWFjdFxuICovXG5mdW5jdGlvbiB1c2VGbG9hdGluZyhvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCA9ICdib3R0b20nLFxuICAgIHN0cmF0ZWd5ID0gJ2Fic29sdXRlJyxcbiAgICBtaWRkbGV3YXJlID0gW10sXG4gICAgcGxhdGZvcm0sXG4gICAgd2hpbGVFbGVtZW50c01vdW50ZWQsXG4gICAgb3BlblxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgW2RhdGEsIHNldERhdGFdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIHg6IG51bGwsXG4gICAgeTogbnVsbCxcbiAgICBzdHJhdGVneSxcbiAgICBwbGFjZW1lbnQsXG4gICAgbWlkZGxld2FyZURhdGE6IHt9LFxuICAgIGlzUG9zaXRpb25lZDogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IFtsYXRlc3RNaWRkbGV3YXJlLCBzZXRMYXRlc3RNaWRkbGV3YXJlXSA9IFJlYWN0LnVzZVN0YXRlKG1pZGRsZXdhcmUpO1xuICBpZiAoIWRlZXBFcXVhbChsYXRlc3RNaWRkbGV3YXJlLCBtaWRkbGV3YXJlKSkge1xuICAgIHNldExhdGVzdE1pZGRsZXdhcmUobWlkZGxld2FyZSk7XG4gIH1cbiAgY29uc3QgcmVmZXJlbmNlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBmbG9hdGluZ1JlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgZGF0YVJlZiA9IFJlYWN0LnVzZVJlZihkYXRhKTtcbiAgY29uc3Qgd2hpbGVFbGVtZW50c01vdW50ZWRSZWYgPSB1c2VMYXRlc3RSZWYod2hpbGVFbGVtZW50c01vdW50ZWQpO1xuICBjb25zdCBwbGF0Zm9ybVJlZiA9IHVzZUxhdGVzdFJlZihwbGF0Zm9ybSk7XG4gIGNvbnN0IFtyZWZlcmVuY2UsIF9zZXRSZWZlcmVuY2VdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtmbG9hdGluZywgX3NldEZsb2F0aW5nXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBzZXRSZWZlcmVuY2UgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBpZiAocmVmZXJlbmNlUmVmLmN1cnJlbnQgIT09IG5vZGUpIHtcbiAgICAgIHJlZmVyZW5jZVJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgIF9zZXRSZWZlcmVuY2Uobm9kZSk7XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IHNldEZsb2F0aW5nID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgaWYgKGZsb2F0aW5nUmVmLmN1cnJlbnQgIT09IG5vZGUpIHtcbiAgICAgIGZsb2F0aW5nUmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgX3NldEZsb2F0aW5nKG5vZGUpO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCB1cGRhdGUgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFyZWZlcmVuY2VSZWYuY3VycmVudCB8fCAhZmxvYXRpbmdSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICBwbGFjZW1lbnQsXG4gICAgICBzdHJhdGVneSxcbiAgICAgIG1pZGRsZXdhcmU6IGxhdGVzdE1pZGRsZXdhcmVcbiAgICB9O1xuICAgIGlmIChwbGF0Zm9ybVJlZi5jdXJyZW50KSB7XG4gICAgICBjb25maWcucGxhdGZvcm0gPSBwbGF0Zm9ybVJlZi5jdXJyZW50O1xuICAgIH1cbiAgICBjb21wdXRlUG9zaXRpb24ocmVmZXJlbmNlUmVmLmN1cnJlbnQsIGZsb2F0aW5nUmVmLmN1cnJlbnQsIGNvbmZpZykudGhlbihkYXRhID0+IHtcbiAgICAgIGNvbnN0IGZ1bGxEYXRhID0ge1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBpc1Bvc2l0aW9uZWQ6IHRydWVcbiAgICAgIH07XG4gICAgICBpZiAoaXNNb3VudGVkUmVmLmN1cnJlbnQgJiYgIWRlZXBFcXVhbChkYXRhUmVmLmN1cnJlbnQsIGZ1bGxEYXRhKSkge1xuICAgICAgICBkYXRhUmVmLmN1cnJlbnQgPSBmdWxsRGF0YTtcbiAgICAgICAgUmVhY3RET00uZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgICBzZXREYXRhKGZ1bGxEYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtsYXRlc3RNaWRkbGV3YXJlLCBwbGFjZW1lbnQsIHN0cmF0ZWd5LCBwbGF0Zm9ybVJlZl0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKG9wZW4gPT09IGZhbHNlICYmIGRhdGFSZWYuY3VycmVudC5pc1Bvc2l0aW9uZWQpIHtcbiAgICAgIGRhdGFSZWYuY3VycmVudC5pc1Bvc2l0aW9uZWQgPSBmYWxzZTtcbiAgICAgIHNldERhdGEoZGF0YSA9PiAoe1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBpc1Bvc2l0aW9uZWQ6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgfVxuICB9LCBbb3Blbl0pO1xuICBjb25zdCBpc01vdW50ZWRSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChyZWZlcmVuY2UgJiYgZmxvYXRpbmcpIHtcbiAgICAgIGlmICh3aGlsZUVsZW1lbnRzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybiB3aGlsZUVsZW1lbnRzTW91bnRlZFJlZi5jdXJyZW50KHJlZmVyZW5jZSwgZmxvYXRpbmcsIHVwZGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtyZWZlcmVuY2UsIGZsb2F0aW5nLCB1cGRhdGUsIHdoaWxlRWxlbWVudHNNb3VudGVkUmVmXSk7XG4gIGNvbnN0IHJlZnMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VSZWYsXG4gICAgZmxvYXRpbmc6IGZsb2F0aW5nUmVmLFxuICAgIHNldFJlZmVyZW5jZSxcbiAgICBzZXRGbG9hdGluZ1xuICB9KSwgW3NldFJlZmVyZW5jZSwgc2V0RmxvYXRpbmddKTtcbiAgY29uc3QgZWxlbWVudHMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nXG4gIH0pLCBbcmVmZXJlbmNlLCBmbG9hdGluZ10pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIC4uLmRhdGEsXG4gICAgdXBkYXRlLFxuICAgIHJlZnMsXG4gICAgZWxlbWVudHMsXG4gICAgcmVmZXJlbmNlOiBzZXRSZWZlcmVuY2UsXG4gICAgZmxvYXRpbmc6IHNldEZsb2F0aW5nXG4gIH0pLCBbZGF0YSwgdXBkYXRlLCByZWZzLCBlbGVtZW50cywgc2V0UmVmZXJlbmNlLCBzZXRGbG9hdGluZ10pO1xufVxuXG5leHBvcnQgeyBhcnJvdywgdXNlRmxvYXRpbmcgfTtcbiJdLCJuYW1lcyI6WyJhcnJvdyIsImFycm93JDEiLCJjb21wdXRlUG9zaXRpb24iLCJhdXRvUGxhY2VtZW50IiwiYXV0b1VwZGF0ZSIsImRldGVjdE92ZXJmbG93IiwiZmxpcCIsImdldE92ZXJmbG93QW5jZXN0b3JzIiwiaGlkZSIsImlubGluZSIsImxpbWl0U2hpZnQiLCJvZmZzZXQiLCJwbGF0Zm9ybSIsInNoaWZ0Iiwic2l6ZSIsIlJlYWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwiUmVhY3RET00iLCJvcHRpb25zIiwiZWxlbWVudCIsInBhZGRpbmciLCJpc1JlZiIsInZhbHVlIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwibmFtZSIsImZuIiwiYXJncyIsImN1cnJlbnQiLCJpbmRleCIsImRvY3VtZW50IiwiZGVlcEVxdWFsIiwiYSIsImIiLCJ0b1N0cmluZyIsImxlbmd0aCIsImkiLCJrZXlzIiwiQXJyYXkiLCJpc0FycmF5Iiwia2V5IiwiJCR0eXBlb2YiLCJ1c2VMYXRlc3RSZWYiLCJyZWYiLCJ1c2VSZWYiLCJ1c2VGbG9hdGluZyIsInBsYWNlbWVudCIsInN0cmF0ZWd5IiwibWlkZGxld2FyZSIsIndoaWxlRWxlbWVudHNNb3VudGVkIiwib3BlbiIsImRhdGEiLCJzZXREYXRhIiwidXNlU3RhdGUiLCJ4IiwieSIsIm1pZGRsZXdhcmVEYXRhIiwiaXNQb3NpdGlvbmVkIiwibGF0ZXN0TWlkZGxld2FyZSIsInNldExhdGVzdE1pZGRsZXdhcmUiLCJyZWZlcmVuY2VSZWYiLCJmbG9hdGluZ1JlZiIsImRhdGFSZWYiLCJ3aGlsZUVsZW1lbnRzTW91bnRlZFJlZiIsInBsYXRmb3JtUmVmIiwicmVmZXJlbmNlIiwiX3NldFJlZmVyZW5jZSIsImZsb2F0aW5nIiwiX3NldEZsb2F0aW5nIiwic2V0UmVmZXJlbmNlIiwidXNlQ2FsbGJhY2siLCJub2RlIiwic2V0RmxvYXRpbmciLCJ1cGRhdGUiLCJjb25maWciLCJ0aGVuIiwiZnVsbERhdGEiLCJpc01vdW50ZWRSZWYiLCJmbHVzaFN5bmMiLCJyZWZzIiwidXNlTWVtbyIsImVsZW1lbnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@floating-ui/react/dist/floating-ui.react.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FloatingDelayGroup: () => (/* binding */ FloatingDelayGroup),\n/* harmony export */   FloatingFocusManager: () => (/* binding */ FloatingFocusManager),\n/* harmony export */   FloatingNode: () => (/* binding */ FloatingNode),\n/* harmony export */   FloatingOverlay: () => (/* binding */ FloatingOverlay),\n/* harmony export */   FloatingPortal: () => (/* binding */ FloatingPortal),\n/* harmony export */   FloatingTree: () => (/* binding */ FloatingTree),\n/* harmony export */   arrow: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.arrow),\n/* harmony export */   autoPlacement: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_3__.autoPlacement),\n/* harmony export */   autoUpdate: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_3__.autoUpdate),\n/* harmony export */   computePosition: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_3__.computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_3__.detectOverflow),\n/* harmony export */   flip: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_3__.flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_3__.hide),\n/* harmony export */   inline: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_3__.inline),\n/* harmony export */   inner: () => (/* binding */ inner),\n/* harmony export */   limitShift: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_3__.limitShift),\n/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_3__.offset),\n/* harmony export */   platform: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_3__.platform),\n/* harmony export */   safePolygon: () => (/* binding */ safePolygon),\n/* harmony export */   shift: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_3__.shift),\n/* harmony export */   size: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_3__.size),\n/* harmony export */   useClick: () => (/* binding */ useClick),\n/* harmony export */   useDelayGroup: () => (/* binding */ useDelayGroup),\n/* harmony export */   useDelayGroupContext: () => (/* binding */ useDelayGroupContext),\n/* harmony export */   useDismiss: () => (/* binding */ useDismiss),\n/* harmony export */   useFloating: () => (/* binding */ useFloating),\n/* harmony export */   useFloatingNodeId: () => (/* binding */ useFloatingNodeId),\n/* harmony export */   useFloatingParentNodeId: () => (/* binding */ useFloatingParentNodeId),\n/* harmony export */   useFloatingPortalNode: () => (/* binding */ useFloatingPortalNode),\n/* harmony export */   useFloatingTree: () => (/* binding */ useFloatingTree),\n/* harmony export */   useFocus: () => (/* binding */ useFocus),\n/* harmony export */   useHover: () => (/* binding */ useHover),\n/* harmony export */   useId: () => (/* binding */ useId),\n/* harmony export */   useInnerOffset: () => (/* binding */ useInnerOffset),\n/* harmony export */   useInteractions: () => (/* binding */ useInteractions),\n/* harmony export */   useListNavigation: () => (/* binding */ useListNavigation),\n/* harmony export */   useMergeRefs: () => (/* binding */ useMergeRefs),\n/* harmony export */   useRole: () => (/* binding */ useRole),\n/* harmony export */   useTransitionStatus: () => (/* binding */ useTransitionStatus),\n/* harmony export */   useTransitionStyles: () => (/* binding */ useTransitionStyles),\n/* harmony export */   useTypeahead: () => (/* binding */ useTypeahead)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var aria_hidden__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! aria-hidden */ \"(ssr)/./node_modules/aria-hidden/dist/es2015/index.js\");\n/* harmony import */ var tabbable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tabbable */ \"(ssr)/./node_modules/tabbable/dist/index.esm.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js\");\n\n\n\n\n\n\n\n\nvar index = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nlet serverHandoffComplete = false;\nlet count = 0;\nconst genId = ()=>\"floating-ui-\" + count++;\nfunction useFloatingId() {\n    const [id, setId] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>serverHandoffComplete ? genId() : undefined);\n    index(()=>{\n        if (id == null) {\n            setId(genId());\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!serverHandoffComplete) {\n            serverHandoffComplete = true;\n        }\n    }, []);\n    return id;\n}\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useReactId = react__WEBPACK_IMPORTED_MODULE_0__[/*#__PURE__*/ \"useId\".toString()];\n/**\n * Uses React 18's built-in `useId()` when available, or falls back to a\n * slightly less performant (requiring a double render) implementation for\n * earlier React versions.\n * @see https://floating-ui.com/docs/useId\n */ const useId = useReactId || useFloatingId;\nfunction createPubSub() {\n    const map = new Map();\n    return {\n        emit (event, data) {\n            var _map$get;\n            (_map$get = map.get(event)) == null ? void 0 : _map$get.forEach((handler)=>handler(data));\n        },\n        on (event, listener) {\n            map.set(event, [\n                ...map.get(event) || [],\n                listener\n            ]);\n        },\n        off (event, listener) {\n            map.set(event, (map.get(event) || []).filter((l)=>l !== listener));\n        }\n    };\n}\nconst FloatingNodeContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst FloatingTreeContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst useFloatingParentNodeId = ()=>{\n    var _React$useContext;\n    return ((_React$useContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;\n};\nconst useFloatingTree = ()=>react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingTreeContext);\n/**\n * Registers a node into the floating tree, returning its id.\n */ const useFloatingNodeId = (customParentId)=>{\n    const id = useId();\n    const tree = useFloatingTree();\n    const reactParentId = useFloatingParentNodeId();\n    const parentId = customParentId || reactParentId;\n    index(()=>{\n        const node = {\n            id,\n            parentId\n        };\n        tree == null ? void 0 : tree.addNode(node);\n        return ()=>{\n            tree == null ? void 0 : tree.removeNode(node);\n        };\n    }, [\n        tree,\n        id,\n        parentId\n    ]);\n    return id;\n};\n/**\n * Provides parent node context for nested floating elements.\n * @see https://floating-ui.com/docs/FloatingTree\n */ const FloatingNode = (_ref)=>{\n    let { children, id } = _ref;\n    const parentId = useFloatingParentNodeId();\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingNodeContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                id,\n                parentId\n            }), [\n            id,\n            parentId\n        ])\n    }, children);\n};\n/**\n * Provides context for nested floating elements when they are not children of\n * each other on the DOM (i.e. portalled to a common node, rather than their\n * respective parent).\n * @see https://floating-ui.com/docs/FloatingTree\n */ const FloatingTree = (_ref2)=>{\n    let { children } = _ref2;\n    const nodesRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);\n    const addNode = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        nodesRef.current = [\n            ...nodesRef.current,\n            node\n        ];\n    }, []);\n    const removeNode = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        nodesRef.current = nodesRef.current.filter((n)=>n !== node);\n    }, []);\n    const events = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>createPubSub())[0];\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingTreeContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                nodesRef,\n                addNode,\n                removeNode,\n                events\n            }), [\n            nodesRef,\n            addNode,\n            removeNode,\n            events\n        ])\n    }, children);\n};\nfunction getDocument(node) {\n    return (node == null ? void 0 : node.ownerDocument) || document;\n}\n// Avoid Chrome DevTools blue warning.\nfunction getPlatform() {\n    const uaData = navigator.userAgentData;\n    if (uaData != null && uaData.platform) {\n        return uaData.platform;\n    }\n    return navigator.platform;\n}\nfunction getUserAgent() {\n    const uaData = navigator.userAgentData;\n    if (uaData && Array.isArray(uaData.brands)) {\n        return uaData.brands.map((_ref)=>{\n            let { brand, version } = _ref;\n            return brand + \"/\" + version;\n        }).join(\" \");\n    }\n    return navigator.userAgent;\n}\nfunction getWindow(value) {\n    return getDocument(value).defaultView || window;\n}\nfunction isElement(value) {\n    return value ? value instanceof getWindow(value).Element : false;\n}\nfunction isHTMLElement(value) {\n    return value ? value instanceof getWindow(value).HTMLElement : false;\n}\nfunction isShadowRoot(node) {\n    // Browsers without `ShadowRoot` support\n    if (typeof ShadowRoot === \"undefined\") {\n        return false;\n    }\n    const OwnElement = getWindow(node).ShadowRoot;\n    return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n// License: https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/utils/src/isVirtualEvent.ts\nfunction isVirtualClick(event) {\n    if (event.mozInputSource === 0 && event.isTrusted) {\n        return true;\n    }\n    const androidRe = /Android/i;\n    if ((androidRe.test(getPlatform()) || androidRe.test(getUserAgent())) && event.pointerType) {\n        return event.type === \"click\" && event.buttons === 1;\n    }\n    return event.detail === 0 && !event.pointerType;\n}\nfunction isVirtualPointerEvent(event) {\n    return event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType !== \"mouse\" || // iOS VoiceOver returns 0.333• for width/height.\n    event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0;\n}\nfunction isSafari() {\n    // Chrome DevTools does not complain about navigator.vendor\n    return /apple/i.test(navigator.vendor);\n}\nfunction isMac() {\n    return getPlatform().toLowerCase().startsWith(\"mac\") && !navigator.maxTouchPoints;\n}\nfunction isMouseLikePointerType(pointerType, strict) {\n    // On some Linux machines with Chromium, mouse inputs return a `pointerType`\n    // of \"pen\": https://github.com/floating-ui/floating-ui/issues/2015\n    const values = [\n        \"mouse\",\n        \"pen\"\n    ];\n    if (!strict) {\n        values.push(\"\", undefined);\n    }\n    return values.includes(pointerType);\n}\nfunction useLatestRef(value) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n    index(()=>{\n        ref.current = value;\n    });\n    return ref;\n}\nconst safePolygonIdentifier = \"data-floating-ui-safe-polygon\";\nfunction getDelay(value, prop, pointerType) {\n    if (pointerType && !isMouseLikePointerType(pointerType)) {\n        return 0;\n    }\n    if (typeof value === \"number\") {\n        return value;\n    }\n    return value == null ? void 0 : value[prop];\n}\n/**\n * Adds hover event listeners that change the open state, like CSS :hover.\n * @see https://floating-ui.com/docs/useHover\n */ const useHover = function(context, _temp) {\n    let { enabled = true, delay = 0, handleClose = null, mouseOnly = false, restMs = 0, move = true } = _temp === void 0 ? {} : _temp;\n    const { open, onOpenChange, dataRef, events, elements: { domReference, floating }, refs } = context;\n    const tree = useFloatingTree();\n    const parentId = useFloatingParentNodeId();\n    const handleCloseRef = useLatestRef(handleClose);\n    const delayRef = useLatestRef(delay);\n    const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const handlerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const restTimeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const blockMouseMoveRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n    const performedPointerEventsMutationRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const unbindMouseMoveRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(()=>{});\n    const isHoverOpen = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        var _dataRef$current$open;\n        const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;\n        return (type == null ? void 0 : type.includes(\"mouse\")) && type !== \"mousedown\";\n    }, [\n        dataRef\n    ]);\n    // When dismissing before opening, clear the delay timeouts to cancel it\n    // from showing.\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) {\n            return;\n        }\n        function onDismiss() {\n            clearTimeout(timeoutRef.current);\n            clearTimeout(restTimeoutRef.current);\n            blockMouseMoveRef.current = true;\n        }\n        events.on(\"dismiss\", onDismiss);\n        return ()=>{\n            events.off(\"dismiss\", onDismiss);\n        };\n    }, [\n        enabled,\n        events\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled || !handleCloseRef.current || !open) {\n            return;\n        }\n        function onLeave() {\n            if (isHoverOpen()) {\n                onOpenChange(false);\n            }\n        }\n        const html = getDocument(floating).documentElement;\n        html.addEventListener(\"mouseleave\", onLeave);\n        return ()=>{\n            html.removeEventListener(\"mouseleave\", onLeave);\n        };\n    }, [\n        floating,\n        open,\n        onOpenChange,\n        enabled,\n        handleCloseRef,\n        dataRef,\n        isHoverOpen\n    ]);\n    const closeWithDelay = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(runElseBranch) {\n        if (runElseBranch === void 0) {\n            runElseBranch = true;\n        }\n        const closeDelay = getDelay(delayRef.current, \"close\", pointerTypeRef.current);\n        if (closeDelay && !handlerRef.current) {\n            clearTimeout(timeoutRef.current);\n            timeoutRef.current = setTimeout(()=>onOpenChange(false), closeDelay);\n        } else if (runElseBranch) {\n            clearTimeout(timeoutRef.current);\n            onOpenChange(false);\n        }\n    }, [\n        delayRef,\n        onOpenChange\n    ]);\n    const cleanupMouseMoveHandler = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        unbindMouseMoveRef.current();\n        handlerRef.current = undefined;\n    }, []);\n    const clearPointerEvents = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        if (performedPointerEventsMutationRef.current) {\n            const body = getDocument(refs.floating.current).body;\n            body.style.pointerEvents = \"\";\n            body.removeAttribute(safePolygonIdentifier);\n            performedPointerEventsMutationRef.current = false;\n        }\n    }, [\n        refs\n    ]);\n    // Registering the mouse events on the reference directly to bypass React's\n    // delegation system. If the cursor was on a disabled element and then entered\n    // the reference (no gap), `mouseenter` doesn't fire in the delegation system.\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) {\n            return;\n        }\n        function isClickLikeOpenEvent() {\n            return dataRef.current.openEvent ? [\n                \"click\",\n                \"mousedown\"\n            ].includes(dataRef.current.openEvent.type) : false;\n        }\n        function onMouseEnter(event) {\n            clearTimeout(timeoutRef.current);\n            blockMouseMoveRef.current = false;\n            if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && getDelay(delayRef.current, \"open\") === 0) {\n                return;\n            }\n            dataRef.current.openEvent = event;\n            const openDelay = getDelay(delayRef.current, \"open\", pointerTypeRef.current);\n            if (openDelay) {\n                timeoutRef.current = setTimeout(()=>{\n                    onOpenChange(true);\n                }, openDelay);\n            } else {\n                onOpenChange(true);\n            }\n        }\n        function onMouseLeave(event) {\n            if (isClickLikeOpenEvent()) {\n                return;\n            }\n            unbindMouseMoveRef.current();\n            const doc = getDocument(floating);\n            clearTimeout(restTimeoutRef.current);\n            if (handleCloseRef.current) {\n                clearTimeout(timeoutRef.current);\n                handlerRef.current = handleCloseRef.current({\n                    ...context,\n                    tree,\n                    x: event.clientX,\n                    y: event.clientY,\n                    onClose () {\n                        clearPointerEvents();\n                        cleanupMouseMoveHandler();\n                        closeWithDelay();\n                    }\n                });\n                const handler = handlerRef.current;\n                doc.addEventListener(\"mousemove\", handler);\n                unbindMouseMoveRef.current = ()=>{\n                    doc.removeEventListener(\"mousemove\", handler);\n                };\n                return;\n            }\n            closeWithDelay();\n        }\n        // Ensure the floating element closes after scrolling even if the pointer\n        // did not move.\n        // https://github.com/floating-ui/floating-ui/discussions/1692\n        function onScrollMouseLeave(event) {\n            if (isClickLikeOpenEvent()) {\n                return;\n            }\n            handleCloseRef.current == null ? void 0 : handleCloseRef.current({\n                ...context,\n                tree,\n                x: event.clientX,\n                y: event.clientY,\n                onClose () {\n                    cleanupMouseMoveHandler();\n                    closeWithDelay();\n                }\n            })(event);\n        }\n        if (isElement(domReference)) {\n            const ref = domReference;\n            open && ref.addEventListener(\"mouseleave\", onScrollMouseLeave);\n            floating == null ? void 0 : floating.addEventListener(\"mouseleave\", onScrollMouseLeave);\n            move && ref.addEventListener(\"mousemove\", onMouseEnter, {\n                once: true\n            });\n            ref.addEventListener(\"mouseenter\", onMouseEnter);\n            ref.addEventListener(\"mouseleave\", onMouseLeave);\n            return ()=>{\n                open && ref.removeEventListener(\"mouseleave\", onScrollMouseLeave);\n                floating == null ? void 0 : floating.removeEventListener(\"mouseleave\", onScrollMouseLeave);\n                move && ref.removeEventListener(\"mousemove\", onMouseEnter);\n                ref.removeEventListener(\"mouseenter\", onMouseEnter);\n                ref.removeEventListener(\"mouseleave\", onMouseLeave);\n            };\n        }\n    }, [\n        domReference,\n        floating,\n        enabled,\n        context,\n        mouseOnly,\n        restMs,\n        move,\n        closeWithDelay,\n        cleanupMouseMoveHandler,\n        clearPointerEvents,\n        onOpenChange,\n        open,\n        tree,\n        delayRef,\n        handleCloseRef,\n        dataRef\n    ]);\n    // Block pointer-events of every element other than the reference and floating\n    // while the floating element is open and has a `handleClose` handler. Also\n    // handles nested floating elements.\n    // https://github.com/floating-ui/floating-ui/issues/1722\n    index(()=>{\n        var _handleCloseRef$curre;\n        if (!enabled) {\n            return;\n        }\n        if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {\n            const body = getDocument(floating).body;\n            body.setAttribute(safePolygonIdentifier, \"\");\n            body.style.pointerEvents = \"none\";\n            performedPointerEventsMutationRef.current = true;\n            if (isElement(domReference) && floating) {\n                var _tree$nodesRef$curren, _tree$nodesRef$curren2;\n                const ref = domReference;\n                const parentFloating = tree == null ? void 0 : (_tree$nodesRef$curren = tree.nodesRef.current.find((node)=>node.id === parentId)) == null ? void 0 : (_tree$nodesRef$curren2 = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren2.elements.floating;\n                if (parentFloating) {\n                    parentFloating.style.pointerEvents = \"\";\n                }\n                ref.style.pointerEvents = \"auto\";\n                floating.style.pointerEvents = \"auto\";\n                return ()=>{\n                    ref.style.pointerEvents = \"\";\n                    floating.style.pointerEvents = \"\";\n                };\n            }\n        }\n    }, [\n        enabled,\n        open,\n        parentId,\n        floating,\n        domReference,\n        tree,\n        handleCloseRef,\n        dataRef,\n        isHoverOpen\n    ]);\n    index(()=>{\n        if (!open) {\n            pointerTypeRef.current = undefined;\n            cleanupMouseMoveHandler();\n            clearPointerEvents();\n        }\n    }, [\n        open,\n        cleanupMouseMoveHandler,\n        clearPointerEvents\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return ()=>{\n            cleanupMouseMoveHandler();\n            clearTimeout(timeoutRef.current);\n            clearTimeout(restTimeoutRef.current);\n            clearPointerEvents();\n        };\n    }, [\n        enabled,\n        cleanupMouseMoveHandler,\n        clearPointerEvents\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        function setPointerRef(event) {\n            pointerTypeRef.current = event.pointerType;\n        }\n        return {\n            reference: {\n                onPointerDown: setPointerRef,\n                onPointerEnter: setPointerRef,\n                onMouseMove () {\n                    if (open || restMs === 0) {\n                        return;\n                    }\n                    clearTimeout(restTimeoutRef.current);\n                    restTimeoutRef.current = setTimeout(()=>{\n                        if (!blockMouseMoveRef.current) {\n                            onOpenChange(true);\n                        }\n                    }, restMs);\n                }\n            },\n            floating: {\n                onMouseEnter () {\n                    clearTimeout(timeoutRef.current);\n                },\n                onMouseLeave () {\n                    events.emit(\"dismiss\", {\n                        type: \"mouseLeave\",\n                        data: {\n                            returnFocus: false\n                        }\n                    });\n                    closeWithDelay(false);\n                }\n            }\n        };\n    }, [\n        events,\n        enabled,\n        restMs,\n        open,\n        onOpenChange,\n        closeWithDelay\n    ]);\n};\nconst FloatingDelayGroupContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    delay: 0,\n    initialDelay: 0,\n    timeoutMs: 0,\n    currentId: null,\n    setCurrentId: ()=>{},\n    setState: ()=>{},\n    isInstantPhase: false\n});\nconst useDelayGroupContext = ()=>react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingDelayGroupContext);\n/**\n * Provides context for a group of floating elements that should share a\n * `delay`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */ const FloatingDelayGroup = (_ref)=>{\n    let { children, delay, timeoutMs = 0 } = _ref;\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useReducer((prev, next)=>({\n            ...prev,\n            ...next\n        }), {\n        delay,\n        timeoutMs,\n        initialDelay: delay,\n        currentId: null,\n        isInstantPhase: false\n    });\n    const initialCurrentIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const setCurrentId = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((currentId)=>{\n        setState({\n            currentId\n        });\n    }, []);\n    index(()=>{\n        if (state.currentId) {\n            if (initialCurrentIdRef.current === null) {\n                initialCurrentIdRef.current = state.currentId;\n            } else {\n                setState({\n                    isInstantPhase: true\n                });\n            }\n        } else {\n            setState({\n                isInstantPhase: false\n            });\n            initialCurrentIdRef.current = null;\n        }\n    }, [\n        state.currentId\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingDelayGroupContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                ...state,\n                setState,\n                setCurrentId\n            }), [\n            state,\n            setState,\n            setCurrentId\n        ])\n    }, children);\n};\nconst useDelayGroup = (_ref2, _ref3)=>{\n    let { open, onOpenChange } = _ref2;\n    let { id } = _ref3;\n    const { currentId, setCurrentId, initialDelay, setState, timeoutMs } = useDelayGroupContext();\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (currentId) {\n            setState({\n                delay: {\n                    open: 1,\n                    close: getDelay(initialDelay, \"close\")\n                }\n            });\n            if (currentId !== id) {\n                onOpenChange(false);\n            }\n        }\n    }, [\n        id,\n        onOpenChange,\n        setState,\n        currentId,\n        initialDelay\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        function unset() {\n            onOpenChange(false);\n            setState({\n                delay: initialDelay,\n                currentId: null\n            });\n        }\n        if (!open && currentId === id) {\n            if (timeoutMs) {\n                const timeout = window.setTimeout(unset, timeoutMs);\n                return ()=>{\n                    clearTimeout(timeout);\n                };\n            } else {\n                unset();\n            }\n        }\n    }, [\n        open,\n        setState,\n        currentId,\n        id,\n        onOpenChange,\n        initialDelay,\n        timeoutMs\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (open) {\n            setCurrentId(id);\n        }\n    }, [\n        open,\n        setCurrentId,\n        id\n    ]);\n};\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n/**\n * Find the real active element. Traverses into shadowRoots.\n */ function activeElement$1(doc) {\n    let activeElement = doc.activeElement;\n    while(((_activeElement = activeElement) == null ? void 0 : (_activeElement$shadow = _activeElement.shadowRoot) == null ? void 0 : _activeElement$shadow.activeElement) != null){\n        var _activeElement, _activeElement$shadow;\n        activeElement = activeElement.shadowRoot.activeElement;\n    }\n    return activeElement;\n}\nfunction contains(parent, child) {\n    if (!parent || !child) {\n        return false;\n    }\n    const rootNode = child.getRootNode && child.getRootNode();\n    // First, attempt with faster native method\n    if (parent.contains(child)) {\n        return true;\n    } else if (rootNode && isShadowRoot(rootNode)) {\n        let next = child;\n        do {\n            if (next && parent === next) {\n                return true;\n            }\n            // @ts-ignore\n            next = next.parentNode || next.host;\n        }while (next);\n    }\n    // Give up, the result is false\n    return false;\n}\nlet rafId = 0;\nfunction enqueueFocus(el, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { preventScroll = false, cancelPrevious = true, sync = false } = options;\n    cancelPrevious && cancelAnimationFrame(rafId);\n    const exec = ()=>el == null ? void 0 : el.focus({\n            preventScroll\n        });\n    if (sync) {\n        exec();\n    } else {\n        rafId = requestAnimationFrame(exec);\n    }\n}\nfunction getAncestors(nodes, id) {\n    var _nodes$find;\n    let allAncestors = [];\n    let currentParentId = (_nodes$find = nodes.find((node)=>node.id === id)) == null ? void 0 : _nodes$find.parentId;\n    while(currentParentId){\n        const currentNode = nodes.find((node)=>node.id === currentParentId);\n        currentParentId = currentNode == null ? void 0 : currentNode.parentId;\n        if (currentNode) {\n            allAncestors = allAncestors.concat(currentNode);\n        }\n    }\n    return allAncestors;\n}\nfunction getChildren(nodes, id) {\n    let allChildren = nodes.filter((node)=>{\n        var _node$context;\n        return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);\n    }) || [];\n    let currentChildren = allChildren;\n    while(currentChildren.length){\n        currentChildren = nodes.filter((node)=>{\n            var _currentChildren;\n            return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some((n)=>{\n                var _node$context2;\n                return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);\n            });\n        }) || [];\n        allChildren = allChildren.concat(currentChildren);\n    }\n    return allChildren;\n}\nfunction getTarget(event) {\n    if (\"composedPath\" in event) {\n        return event.composedPath()[0];\n    }\n    // TS thinks `event` is of type never as it assumes all browsers support\n    // `composedPath()`, but browsers without shadow DOM don't.\n    return event.target;\n}\nconst TYPEABLE_SELECTOR = \"input:not([type='hidden']):not([disabled]),\" + \"[contenteditable]:not([contenteditable='false']),textarea:not([disabled])\";\nfunction isTypeableElement(element) {\n    return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);\n}\nfunction stopEvent(event) {\n    event.preventDefault();\n    event.stopPropagation();\n}\nconst getTabbableOptions = ()=>({\n        getShadowRoot: true,\n        displayCheck: // JSDOM does not support the `tabbable` library. To solve this we can\n        // check if `ResizeObserver` is a real function (not polyfilled), which\n        // determines if the current environment is JSDOM-like.\n        typeof ResizeObserver === \"function\" && ResizeObserver.toString().includes(\"[native code]\") ? \"full\" : \"none\"\n    });\nfunction getTabbableIn(container, direction) {\n    const allTabbable = (0,tabbable__WEBPACK_IMPORTED_MODULE_5__.tabbable)(container, getTabbableOptions());\n    if (direction === \"prev\") {\n        allTabbable.reverse();\n    }\n    const activeIndex = allTabbable.indexOf(activeElement$1(getDocument(container)));\n    const nextTabbableElements = allTabbable.slice(activeIndex + 1);\n    return nextTabbableElements[0];\n}\nfunction getNextTabbable() {\n    return getTabbableIn(document.body, \"next\");\n}\nfunction getPreviousTabbable() {\n    return getTabbableIn(document.body, \"prev\");\n}\nfunction isOutsideEvent(event, container) {\n    const containerElement = container || event.currentTarget;\n    const relatedTarget = event.relatedTarget;\n    return !relatedTarget || !contains(containerElement, relatedTarget);\n}\nfunction disableFocusInside(container) {\n    const tabbableElements = (0,tabbable__WEBPACK_IMPORTED_MODULE_5__.tabbable)(container, getTabbableOptions());\n    tabbableElements.forEach((element)=>{\n        element.dataset.tabindex = element.getAttribute(\"tabindex\") || \"\";\n        element.setAttribute(\"tabindex\", \"-1\");\n    });\n}\nfunction enableFocusInside(container) {\n    const elements = container.querySelectorAll(\"[data-tabindex]\");\n    elements.forEach((element)=>{\n        const tabindex = element.dataset.tabindex;\n        delete element.dataset.tabindex;\n        if (tabindex) {\n            element.setAttribute(\"tabindex\", tabindex);\n        } else {\n            element.removeAttribute(\"tabindex\");\n        }\n    });\n}\n// `toString()` prevents bundlers from trying to `import { useInsertionEffect } from 'react'`\nconst useInsertionEffect = react__WEBPACK_IMPORTED_MODULE_0__[/*#__PURE__*/ \"useInsertionEffect\".toString()];\nconst useSafeInsertionEffect = useInsertionEffect || ((fn)=>fn());\nfunction useEvent(callback) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(()=>{\n        if (true) {\n            throw new Error(\"Cannot call an event handler while rendering.\");\n        }\n    });\n    useSafeInsertionEffect(()=>{\n        ref.current = callback;\n    });\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return ref.current == null ? void 0 : ref.current(...args);\n    }, []);\n}\n// See Diego Haz's Sandbox for making this logic work well on Safari/iOS:\n// https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/FocusTrap.tsx\nconst HIDDEN_STYLES = {\n    border: 0,\n    clip: \"rect(0 0 0 0)\",\n    height: \"1px\",\n    margin: \"-1px\",\n    overflow: \"hidden\",\n    padding: 0,\n    position: \"fixed\",\n    whiteSpace: \"nowrap\",\n    width: \"1px\",\n    top: 0,\n    left: 0\n};\nlet activeElement;\nlet timeoutId;\nfunction setActiveElementOnTab(event) {\n    if (event.key === \"Tab\") {\n        activeElement = event.target;\n        clearTimeout(timeoutId);\n    }\n}\nfunction isTabFocus(event) {\n    const result = activeElement === event.relatedTarget;\n    activeElement = event.relatedTarget;\n    clearTimeout(timeoutId);\n    return result;\n}\nconst FocusGuard = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FocusGuard(props, ref) {\n    const onFocus = useEvent(props.onFocus);\n    const [role, setRole] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    index(()=>{\n        if (isSafari()) {\n            // Unlike other screen readers such as NVDA and JAWS, the virtual cursor\n            // on VoiceOver does trigger the onFocus event, so we can use the focus\n            // trap element. On Safari, only buttons trigger the onFocus event.\n            // NB: \"group\" role in the Sandbox no longer appears to work, must be a\n            // button role.\n            setRole(\"button\");\n        }\n        document.addEventListener(\"keydown\", setActiveElementOnTab);\n        return ()=>{\n            document.removeEventListener(\"keydown\", setActiveElementOnTab);\n        };\n    }, []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", _extends({}, props, {\n        ref: ref,\n        tabIndex: 0,\n        role: role,\n        \"aria-hidden\": role ? undefined : true,\n        \"data-floating-ui-focus-guard\": \"\",\n        style: HIDDEN_STYLES,\n        onFocus: (event)=>{\n            if (isSafari() && isMac() && !isTabFocus(event)) {\n                // On macOS we need to wait a little bit before moving\n                // focus again.\n                event.persist();\n                timeoutId = window.setTimeout(()=>{\n                    onFocus(event);\n                }, 50);\n            } else {\n                onFocus(event);\n            }\n        }\n    }));\n});\nconst PortalContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst useFloatingPortalNode = function(_temp) {\n    let { id, enabled = true } = _temp === void 0 ? {} : _temp;\n    const [portalEl, setPortalEl] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const uniqueId = useId();\n    const portalContext = usePortalContext();\n    index(()=>{\n        if (!enabled) {\n            return;\n        }\n        const rootNode = id ? document.getElementById(id) : null;\n        if (rootNode) {\n            rootNode.setAttribute(\"data-floating-ui-portal\", \"\");\n            setPortalEl(rootNode);\n        } else {\n            const newPortalEl = document.createElement(\"div\");\n            if (id !== \"\") {\n                newPortalEl.id = id || uniqueId;\n            }\n            newPortalEl.setAttribute(\"data-floating-ui-portal\", \"\");\n            setPortalEl(newPortalEl);\n            const container = (portalContext == null ? void 0 : portalContext.portalNode) || document.body;\n            container.appendChild(newPortalEl);\n            return ()=>{\n                container.removeChild(newPortalEl);\n            };\n        }\n    }, [\n        id,\n        portalContext,\n        uniqueId,\n        enabled\n    ]);\n    return portalEl;\n};\n/**\n * Portals your floating element outside of the main app node.\n * @see https://floating-ui.com/docs/FloatingPortal\n */ const FloatingPortal = (_ref)=>{\n    let { children, id, root = null, preserveTabOrder = true } = _ref;\n    const portalNode = useFloatingPortalNode({\n        id,\n        enabled: !root\n    });\n    const [focusManagerState, setFocusManagerState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const beforeOutsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const afterOutsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const beforeInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const afterInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const shouldRenderGuards = // The FocusManager and therefore floating element are currently open/\n    // rendered.\n    !!focusManagerState && // Guards are only for non-modal focus management.\n    !focusManagerState.modal && !!(root || portalNode) && preserveTabOrder;\n    // https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/TabbablePortal.tsx\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!portalNode || !preserveTabOrder || focusManagerState != null && focusManagerState.modal) {\n            return;\n        }\n        // Make sure elements inside the portal element are tabbable only when the\n        // portal has already been focused, either by tabbing into a focus trap\n        // element outside or using the mouse.\n        function onFocus(event) {\n            if (portalNode && isOutsideEvent(event)) {\n                const focusing = event.type === \"focusin\";\n                const manageFocus = focusing ? enableFocusInside : disableFocusInside;\n                manageFocus(portalNode);\n            }\n        }\n        // Listen to the event on the capture phase so they run before the focus\n        // trap elements onFocus prop is called.\n        portalNode.addEventListener(\"focusin\", onFocus, true);\n        portalNode.addEventListener(\"focusout\", onFocus, true);\n        return ()=>{\n            portalNode.removeEventListener(\"focusin\", onFocus, true);\n            portalNode.removeEventListener(\"focusout\", onFocus, true);\n        };\n    }, [\n        portalNode,\n        preserveTabOrder,\n        focusManagerState == null ? void 0 : focusManagerState.modal\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PortalContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                preserveTabOrder,\n                beforeOutsideRef,\n                afterOutsideRef,\n                beforeInsideRef,\n                afterInsideRef,\n                portalNode,\n                setFocusManagerState\n            }), [\n            preserveTabOrder,\n            portalNode\n        ])\n    }, shouldRenderGuards && portalNode && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n        \"data-type\": \"outside\",\n        ref: beforeOutsideRef,\n        onFocus: (event)=>{\n            if (isOutsideEvent(event, portalNode)) {\n                var _beforeInsideRef$curr;\n                (_beforeInsideRef$curr = beforeInsideRef.current) == null ? void 0 : _beforeInsideRef$curr.focus();\n            } else {\n                const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n                prevTabbable == null ? void 0 : prevTabbable.focus();\n            }\n        }\n    }), shouldRenderGuards && portalNode && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        \"aria-owns\": portalNode.id,\n        style: HIDDEN_STYLES\n    }), root ? /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, root) : portalNode ? /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, portalNode) : null, shouldRenderGuards && portalNode && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n        \"data-type\": \"outside\",\n        ref: afterOutsideRef,\n        onFocus: (event)=>{\n            if (isOutsideEvent(event, portalNode)) {\n                var _afterInsideRef$curre;\n                (_afterInsideRef$curre = afterInsideRef.current) == null ? void 0 : _afterInsideRef$curre.focus();\n            } else {\n                const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n                nextTabbable == null ? void 0 : nextTabbable.focus();\n                (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false));\n            }\n        }\n    }));\n};\nconst usePortalContext = ()=>react__WEBPACK_IMPORTED_MODULE_0__.useContext(PortalContext);\nconst VisuallyHiddenDismiss = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function VisuallyHiddenDismiss(props, ref) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", _extends({}, props, {\n        type: \"button\",\n        ref: ref,\n        tabIndex: -1,\n        style: HIDDEN_STYLES\n    }));\n});\n/**\n * Provides focus management for the floating element.\n * @see https://floating-ui.com/docs/FloatingFocusManager\n */ function FloatingFocusManager(_ref) {\n    let { context, children, order = [\n        \"content\"\n    ], guards = true, initialFocus = 0, returnFocus = true, modal = true, visuallyHiddenDismiss = false, closeOnFocusOut = true } = _ref;\n    const { refs, nodeId, onOpenChange, events, dataRef, elements: { domReference, floating } } = context;\n    const orderRef = useLatestRef(order);\n    const tree = useFloatingTree();\n    const portalContext = usePortalContext();\n    const [tabbableContentLength, setTabbableContentLength] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    // Controlled by `useListNavigation`.\n    const ignoreInitialFocus = typeof initialFocus === \"number\" && initialFocus < 0;\n    const startDismissButtonRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const endDismissButtonRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const preventReturnFocusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const previouslyFocusedElementRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const isPointerDownRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const isInsidePortal = portalContext != null;\n    // If the reference is a combobox and is typeable (e.g. input/textarea),\n    // there are different focus semantics. The guards should not be rendered, but\n    // aria-hidden should be applied to all nodes still. Further, the visually\n    // hidden dismiss button should only appear at the end of the list, not the\n    // start.\n    const isTypeableCombobox = domReference && domReference.getAttribute(\"role\") === \"combobox\" && isTypeableElement(domReference);\n    const getTabbableContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(container) {\n        if (container === void 0) {\n            container = floating;\n        }\n        return container ? (0,tabbable__WEBPACK_IMPORTED_MODULE_5__.tabbable)(container, getTabbableOptions()) : [];\n    }, [\n        floating\n    ]);\n    const getTabbableElements = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((container)=>{\n        const content = getTabbableContent(container);\n        return orderRef.current.map((type)=>{\n            if (domReference && type === \"reference\") {\n                return domReference;\n            }\n            if (floating && type === \"floating\") {\n                return floating;\n            }\n            return content;\n        }).filter(Boolean).flat();\n    }, [\n        domReference,\n        floating,\n        orderRef,\n        getTabbableContent\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!modal) {\n            return;\n        }\n        function onKeyDown(event) {\n            if (event.key === \"Tab\") {\n                // The focus guards have nothing to focus, so we need to stop the event.\n                if (getTabbableContent().length === 0 && !isTypeableCombobox) {\n                    stopEvent(event);\n                }\n                const els = getTabbableElements();\n                const target = getTarget(event);\n                if (orderRef.current[0] === \"reference\" && target === domReference) {\n                    stopEvent(event);\n                    if (event.shiftKey) {\n                        enqueueFocus(els[els.length - 1]);\n                    } else {\n                        enqueueFocus(els[1]);\n                    }\n                }\n                if (orderRef.current[1] === \"floating\" && target === floating && event.shiftKey) {\n                    stopEvent(event);\n                    enqueueFocus(els[0]);\n                }\n            }\n        }\n        const doc = getDocument(floating);\n        doc.addEventListener(\"keydown\", onKeyDown);\n        return ()=>{\n            doc.removeEventListener(\"keydown\", onKeyDown);\n        };\n    }, [\n        domReference,\n        floating,\n        modal,\n        orderRef,\n        refs,\n        isTypeableCombobox,\n        getTabbableContent,\n        getTabbableElements\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!closeOnFocusOut) {\n            return;\n        }\n        // In Safari, buttons lose focus when pressing them.\n        function handlePointerDown() {\n            isPointerDownRef.current = true;\n            setTimeout(()=>{\n                isPointerDownRef.current = false;\n            });\n        }\n        function handleFocusOutside(event) {\n            const relatedTarget = event.relatedTarget;\n            const movedToUnrelatedNode = !(contains(domReference, relatedTarget) || contains(floating, relatedTarget) || contains(relatedTarget, floating) || contains(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(\"data-floating-ui-focus-guard\") || tree && (getChildren(tree.nodesRef.current, nodeId).find((node)=>{\n                var _node$context, _node$context2;\n                return contains((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || contains((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);\n            }) || getAncestors(tree.nodesRef.current, nodeId).find((node)=>{\n                var _node$context3, _node$context4;\n                return ((_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating) === relatedTarget || ((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.domReference) === relatedTarget;\n            })));\n            // Focus did not move inside the floating tree, and there are no tabbable\n            // portal guards to handle closing.\n            if (relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current && // Fix React 18 Strict Mode returnFocus due to double rendering.\n            relatedTarget !== previouslyFocusedElementRef.current) {\n                preventReturnFocusRef.current = true;\n                // On iOS VoiceOver, dismissing the nested submenu will cause the\n                // first item of the list to receive focus. Delaying it appears to fix\n                // the issue.\n                setTimeout(()=>onOpenChange(false));\n            }\n        }\n        if (floating && isHTMLElement(domReference)) {\n            domReference.addEventListener(\"focusout\", handleFocusOutside);\n            domReference.addEventListener(\"pointerdown\", handlePointerDown);\n            !modal && floating.addEventListener(\"focusout\", handleFocusOutside);\n            return ()=>{\n                domReference.removeEventListener(\"focusout\", handleFocusOutside);\n                domReference.removeEventListener(\"pointerdown\", handlePointerDown);\n                !modal && floating.removeEventListener(\"focusout\", handleFocusOutside);\n            };\n        }\n    }, [\n        domReference,\n        floating,\n        modal,\n        nodeId,\n        tree,\n        portalContext,\n        onOpenChange,\n        closeOnFocusOut\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        var _portalContext$portal;\n        // Don't hide portals nested within the parent portal.\n        const portalNodes = Array.from((portalContext == null ? void 0 : (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll(\"[data-floating-ui-portal]\")) || []);\n        function getDismissButtons() {\n            return [\n                startDismissButtonRef.current,\n                endDismissButtonRef.current\n            ].filter(Boolean);\n        }\n        if (floating && modal) {\n            const insideNodes = [\n                floating,\n                ...portalNodes,\n                ...getDismissButtons()\n            ];\n            const cleanup = (0,aria_hidden__WEBPACK_IMPORTED_MODULE_6__.hideOthers)(orderRef.current.includes(\"reference\") || isTypeableCombobox ? insideNodes.concat(domReference || []) : insideNodes);\n            return ()=>{\n                cleanup();\n            };\n        }\n    }, [\n        domReference,\n        floating,\n        modal,\n        orderRef,\n        portalContext,\n        isTypeableCombobox\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (modal && !guards && floating) {\n            const tabIndexValues = [];\n            const options = getTabbableOptions();\n            const allTabbable = (0,tabbable__WEBPACK_IMPORTED_MODULE_5__.tabbable)(getDocument(floating).body, options);\n            const floatingTabbable = getTabbableElements();\n            // Exclude all tabbable elements that are part of the order\n            const elements = allTabbable.filter((el)=>!floatingTabbable.includes(el));\n            elements.forEach((el, i)=>{\n                tabIndexValues[i] = el.getAttribute(\"tabindex\");\n                el.setAttribute(\"tabindex\", \"-1\");\n            });\n            return ()=>{\n                elements.forEach((el, i)=>{\n                    const value = tabIndexValues[i];\n                    if (value == null) {\n                        el.removeAttribute(\"tabindex\");\n                    } else {\n                        el.setAttribute(\"tabindex\", value);\n                    }\n                });\n            };\n        }\n    }, [\n        floating,\n        modal,\n        guards,\n        getTabbableElements\n    ]);\n    index(()=>{\n        if (!floating) return;\n        const doc = getDocument(floating);\n        let returnFocusValue = returnFocus;\n        let preventReturnFocusScroll = false;\n        const previouslyFocusedElement = activeElement$1(doc);\n        const contextData = dataRef.current;\n        previouslyFocusedElementRef.current = previouslyFocusedElement;\n        const focusableElements = getTabbableElements(floating);\n        const elToFocus = (typeof initialFocus === \"number\" ? focusableElements[initialFocus] : initialFocus.current) || floating;\n        // If the `useListNavigation` hook is active, always ignore `initialFocus`\n        // because it has its own handling of the initial focus.\n        !ignoreInitialFocus && enqueueFocus(elToFocus, {\n            preventScroll: elToFocus === floating\n        });\n        // Dismissing via outside press should always ignore `returnFocus` to\n        // prevent unwanted scrolling.\n        function onDismiss(payload) {\n            if (payload.type === \"escapeKey\" && refs.domReference.current) {\n                previouslyFocusedElementRef.current = refs.domReference.current;\n            }\n            if ([\n                \"referencePress\",\n                \"escapeKey\"\n            ].includes(payload.type)) {\n                return;\n            }\n            const returnFocus = payload.data.returnFocus;\n            if (typeof returnFocus === \"object\") {\n                returnFocusValue = true;\n                preventReturnFocusScroll = returnFocus.preventScroll;\n            } else {\n                returnFocusValue = returnFocus;\n            }\n        }\n        events.on(\"dismiss\", onDismiss);\n        return ()=>{\n            events.off(\"dismiss\", onDismiss);\n            if (contains(floating, activeElement$1(doc)) && refs.domReference.current) {\n                previouslyFocusedElementRef.current = refs.domReference.current;\n            }\n            if (returnFocusValue && isHTMLElement(previouslyFocusedElementRef.current) && !preventReturnFocusRef.current) {\n                // `isPointerDownRef.current` to avoid the focus ring from appearing on\n                // the reference element when click-toggling it.\n                if (!refs.domReference.current || isPointerDownRef.current) {\n                    enqueueFocus(previouslyFocusedElementRef.current, {\n                        // When dismissing nested floating elements, by the time the rAF has\n                        // executed, the menus will all have been unmounted. When they try\n                        // to get focused, the calls get ignored — leaving the root\n                        // reference focused as desired.\n                        cancelPrevious: false,\n                        preventScroll: preventReturnFocusScroll\n                    });\n                } else {\n                    var _previouslyFocusedEle;\n                    // If the user has specified a `keydown` listener that calls\n                    // setOpen(false) (e.g. selecting an item and closing the floating\n                    // element), then sync return focus causes `useClick` to immediately\n                    // re-open it, unless they call `event.preventDefault()` in the\n                    // `keydown` listener. This helps keep backwards compatibility with\n                    // older examples.\n                    contextData.__syncReturnFocus = true;\n                    // In Safari, `useListNavigation` moves focus sync, so making this\n                    // sync ensures the initial item remains focused despite this being\n                    // invoked in Strict Mode due to double-invoked useEffects. This also\n                    // has the positive side effect of closing a modally focus-managed\n                    // <Menu> on `Tab` keydown to move naturally to the next focusable\n                    // element.\n                    (_previouslyFocusedEle = previouslyFocusedElementRef.current) == null ? void 0 : _previouslyFocusedEle.focus({\n                        preventScroll: preventReturnFocusScroll\n                    });\n                    setTimeout(()=>{\n                        // This isn't an actual property the user should access, make sure\n                        // it doesn't persist.\n                        delete contextData.__syncReturnFocus;\n                    });\n                }\n            }\n        };\n    }, [\n        floating,\n        getTabbableElements,\n        initialFocus,\n        returnFocus,\n        dataRef,\n        refs,\n        events,\n        ignoreInitialFocus\n    ]);\n    // Synchronize the `context` & `modal` value to the FloatingPortal context.\n    // It will decide whether or not it needs to render its own guards.\n    index(()=>{\n        if (!portalContext) return;\n        portalContext.setFocusManagerState({\n            ...context,\n            modal,\n            closeOnFocusOut\n        });\n        return ()=>{\n            portalContext.setFocusManagerState(null);\n        };\n    }, [\n        portalContext,\n        modal,\n        closeOnFocusOut,\n        context\n    ]);\n    index(()=>{\n        if (ignoreInitialFocus || !floating) return;\n        function setState() {\n            setTabbableContentLength(getTabbableContent().length);\n        }\n        setState();\n        if (typeof MutationObserver === \"function\") {\n            const observer = new MutationObserver(setState);\n            observer.observe(floating, {\n                childList: true,\n                subtree: true\n            });\n            return ()=>{\n                observer.disconnect();\n            };\n        }\n    }, [\n        floating,\n        getTabbableContent,\n        ignoreInitialFocus,\n        refs\n    ]);\n    const shouldRenderGuards = guards && (isInsidePortal || modal) && !isTypeableCombobox;\n    function renderDismissButton(location) {\n        return visuallyHiddenDismiss && modal ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(VisuallyHiddenDismiss, {\n            ref: location === \"start\" ? startDismissButtonRef : endDismissButtonRef,\n            onClick: ()=>onOpenChange(false)\n        }, typeof visuallyHiddenDismiss === \"string\" ? visuallyHiddenDismiss : \"Dismiss\") : null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, shouldRenderGuards && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n        \"data-type\": \"inside\",\n        ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,\n        onFocus: (event)=>{\n            if (modal) {\n                const els = getTabbableElements();\n                enqueueFocus(order[0] === \"reference\" ? els[0] : els[els.length - 1]);\n            } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n                preventReturnFocusRef.current = false;\n                if (isOutsideEvent(event, portalContext.portalNode)) {\n                    const nextTabbable = getNextTabbable() || domReference;\n                    nextTabbable == null ? void 0 : nextTabbable.focus();\n                } else {\n                    var _portalContext$before;\n                    (_portalContext$before = portalContext.beforeOutsideRef.current) == null ? void 0 : _portalContext$before.focus();\n                }\n            }\n        }\n    }), isTypeableCombobox ? null : renderDismissButton(\"start\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(children, tabbableContentLength === 0 || order.includes(\"floating\") ? {\n        tabIndex: 0\n    } : {}), renderDismissButton(\"end\"), shouldRenderGuards && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n        \"data-type\": \"inside\",\n        ref: portalContext == null ? void 0 : portalContext.afterInsideRef,\n        onFocus: (event)=>{\n            if (modal) {\n                enqueueFocus(getTabbableElements()[0]);\n            } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n                preventReturnFocusRef.current = true;\n                if (isOutsideEvent(event, portalContext.portalNode)) {\n                    const prevTabbable = getPreviousTabbable() || domReference;\n                    prevTabbable == null ? void 0 : prevTabbable.focus();\n                } else {\n                    var _portalContext$afterO;\n                    (_portalContext$afterO = portalContext.afterOutsideRef.current) == null ? void 0 : _portalContext$afterO.focus();\n                }\n            }\n        }\n    }));\n}\nconst identifier = \"data-floating-ui-scroll-lock\";\n/**\n * Provides base styling for a fixed overlay element to dim content or block\n * pointer events behind a floating element.\n * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.\n * @see https://floating-ui.com/docs/FloatingOverlay\n */ const FloatingOverlay = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FloatingOverlay(_ref, ref) {\n    let { lockScroll = false, ...rest } = _ref;\n    index(()=>{\n        var _window$visualViewpor, _window$visualViewpor2;\n        if (!lockScroll) {\n            return;\n        }\n        const alreadyLocked = document.body.hasAttribute(identifier);\n        if (alreadyLocked) {\n            return;\n        }\n        document.body.setAttribute(identifier, \"\");\n        // RTL <body> scrollbar\n        const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;\n        const paddingProp = scrollbarX ? \"paddingLeft\" : \"paddingRight\";\n        const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n        // Only iOS doesn't respect `overflow: hidden` on document.body, and this\n        // technique has fewer side effects.\n        if (!/iP(hone|ad|od)|iOS/.test(getPlatform())) {\n            Object.assign(document.body.style, {\n                overflow: \"hidden\",\n                [paddingProp]: scrollbarWidth + \"px\"\n            });\n            return ()=>{\n                document.body.removeAttribute(identifier);\n                Object.assign(document.body.style, {\n                    overflow: \"\",\n                    [paddingProp]: \"\"\n                });\n            };\n        }\n        // iOS 12 does not support `visualViewport`.\n        const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;\n        const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;\n        const scrollX = window.pageXOffset;\n        const scrollY = window.pageYOffset;\n        Object.assign(document.body.style, {\n            position: \"fixed\",\n            overflow: \"hidden\",\n            top: -(scrollY - Math.floor(offsetTop)) + \"px\",\n            left: -(scrollX - Math.floor(offsetLeft)) + \"px\",\n            right: \"0\",\n            [paddingProp]: scrollbarWidth + \"px\"\n        });\n        return ()=>{\n            Object.assign(document.body.style, {\n                position: \"\",\n                overflow: \"\",\n                top: \"\",\n                left: \"\",\n                right: \"\",\n                [paddingProp]: \"\"\n            });\n            document.body.removeAttribute(identifier);\n            window.scrollTo(scrollX, scrollY);\n        };\n    }, [\n        lockScroll\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", _extends({\n        ref: ref\n    }, rest, {\n        style: {\n            position: \"fixed\",\n            overflow: \"auto\",\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0,\n            ...rest.style\n        }\n    }));\n});\nfunction isButtonTarget(event) {\n    return isHTMLElement(event.target) && event.target.tagName === \"BUTTON\";\n}\nfunction isSpaceIgnored(element) {\n    return isTypeableElement(element);\n}\n/**\n * Adds click event listeners that change the open state.\n * @see https://floating-ui.com/docs/useClick\n */ const useClick = function(_ref, _temp) {\n    let { open, onOpenChange, dataRef, elements: { domReference } } = _ref;\n    let { enabled = true, event: eventOption = \"click\", toggle = true, ignoreMouse = false, keyboardHandlers = true } = _temp === void 0 ? {} : _temp;\n    const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        return {\n            reference: {\n                onPointerDown (event) {\n                    pointerTypeRef.current = event.pointerType;\n                },\n                onMouseDown (event) {\n                    // Ignore all buttons except for the \"main\" button.\n                    // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n                    if (event.button !== 0) {\n                        return;\n                    }\n                    if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {\n                        return;\n                    }\n                    if (eventOption === \"click\") {\n                        return;\n                    }\n                    if (open) {\n                        if (toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === \"mousedown\" : true)) {\n                            onOpenChange(false);\n                        }\n                    } else {\n                        // Prevent stealing focus from the floating element\n                        event.preventDefault();\n                        onOpenChange(true);\n                    }\n                    dataRef.current.openEvent = event.nativeEvent;\n                },\n                onClick (event) {\n                    if (dataRef.current.__syncReturnFocus) {\n                        return;\n                    }\n                    if (eventOption === \"mousedown\" && pointerTypeRef.current) {\n                        pointerTypeRef.current = undefined;\n                        return;\n                    }\n                    if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {\n                        return;\n                    }\n                    if (open) {\n                        if (toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === \"click\" : true)) {\n                            onOpenChange(false);\n                        }\n                    } else {\n                        onOpenChange(true);\n                    }\n                    dataRef.current.openEvent = event.nativeEvent;\n                },\n                onKeyDown (event) {\n                    pointerTypeRef.current = undefined;\n                    if (!keyboardHandlers) {\n                        return;\n                    }\n                    if (isButtonTarget(event)) {\n                        return;\n                    }\n                    if (event.key === \" \" && !isSpaceIgnored(domReference)) {\n                        // Prevent scrolling\n                        event.preventDefault();\n                    }\n                    if (event.key === \"Enter\") {\n                        if (open) {\n                            if (toggle) {\n                                onOpenChange(false);\n                            }\n                        } else {\n                            onOpenChange(true);\n                        }\n                    }\n                },\n                onKeyUp (event) {\n                    if (!keyboardHandlers) {\n                        return;\n                    }\n                    if (isButtonTarget(event) || isSpaceIgnored(domReference)) {\n                        return;\n                    }\n                    if (event.key === \" \") {\n                        if (open) {\n                            if (toggle) {\n                                onOpenChange(false);\n                            }\n                        } else {\n                            onOpenChange(true);\n                        }\n                    }\n                }\n            }\n        };\n    }, [\n        enabled,\n        dataRef,\n        eventOption,\n        ignoreMouse,\n        keyboardHandlers,\n        domReference,\n        toggle,\n        open,\n        onOpenChange\n    ]);\n};\n/**\n * Check whether the event.target is within the provided node. Uses event.composedPath if available for custom element support.\n *\n * @param event The event whose target/composedPath to check\n * @param node The node to check against\n * @returns Whether the event.target/composedPath is within the node.\n */ function isEventTargetWithin(event, node) {\n    if (node == null) {\n        return false;\n    }\n    if (\"composedPath\" in event) {\n        return event.composedPath().includes(node);\n    }\n    // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't\n    const e = event;\n    return e.target != null && node.contains(e.target);\n}\nconst bubbleHandlerKeys = {\n    pointerdown: \"onPointerDown\",\n    mousedown: \"onMouseDown\",\n    click: \"onClick\"\n};\nconst captureHandlerKeys = {\n    pointerdown: \"onPointerDownCapture\",\n    mousedown: \"onMouseDownCapture\",\n    click: \"onClickCapture\"\n};\nconst normalizeBubblesProp = function(bubbles) {\n    var _bubbles$escapeKey, _bubbles$outsidePress;\n    if (bubbles === void 0) {\n        bubbles = true;\n    }\n    return {\n        escapeKeyBubbles: typeof bubbles === \"boolean\" ? bubbles : (_bubbles$escapeKey = bubbles.escapeKey) != null ? _bubbles$escapeKey : true,\n        outsidePressBubbles: typeof bubbles === \"boolean\" ? bubbles : (_bubbles$outsidePress = bubbles.outsidePress) != null ? _bubbles$outsidePress : true\n    };\n};\n/**\n * Adds listeners that dismiss (close) the floating element.\n * @see https://floating-ui.com/docs/useDismiss\n */ const useDismiss = function(_ref, _temp) {\n    let { open, onOpenChange, events, nodeId, elements: { reference, domReference, floating }, dataRef } = _ref;\n    let { enabled = true, escapeKey = true, outsidePress: unstable_outsidePress = true, outsidePressEvent = \"pointerdown\", referencePress = false, referencePressEvent = \"pointerdown\", ancestorScroll = false, bubbles = true } = _temp === void 0 ? {} : _temp;\n    const tree = useFloatingTree();\n    const nested = useFloatingParentNodeId() != null;\n    const outsidePressFn = useEvent(typeof unstable_outsidePress === \"function\" ? unstable_outsidePress : ()=>false);\n    const outsidePress = typeof unstable_outsidePress === \"function\" ? outsidePressFn : unstable_outsidePress;\n    const insideReactTreeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const { escapeKeyBubbles, outsidePressBubbles } = normalizeBubblesProp(bubbles);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!open || !enabled) {\n            return;\n        }\n        dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;\n        dataRef.current.__outsidePressBubbles = outsidePressBubbles;\n        function onKeyDown(event) {\n            if (event.key === \"Escape\") {\n                const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n                if (children.length > 0) {\n                    let shouldDismiss = true;\n                    children.forEach((child)=>{\n                        var _child$context;\n                        if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {\n                            shouldDismiss = false;\n                            return;\n                        }\n                    });\n                    if (!shouldDismiss) {\n                        return;\n                    }\n                }\n                events.emit(\"dismiss\", {\n                    type: \"escapeKey\",\n                    data: {\n                        returnFocus: {\n                            preventScroll: false\n                        }\n                    }\n                });\n                onOpenChange(false);\n            }\n        }\n        function onOutsidePress(event) {\n            // Given developers can stop the propagation of the synthetic event,\n            // we can only be confident with a positive value.\n            const insideReactTree = insideReactTreeRef.current;\n            insideReactTreeRef.current = false;\n            if (insideReactTree) {\n                return;\n            }\n            if (typeof outsidePress === \"function\" && !outsidePress(event)) {\n                return;\n            }\n            const target = getTarget(event);\n            // Check if the click occurred on the scrollbar\n            if (isHTMLElement(target) && floating) {\n                const win = floating.ownerDocument.defaultView || window;\n                const canScrollX = target.scrollWidth > target.clientWidth;\n                const canScrollY = target.scrollHeight > target.clientHeight;\n                let xCond = canScrollY && event.offsetX > target.clientWidth;\n                // In some browsers it is possible to change the <body> (or window)\n                // scrollbar to the left side, but is very rare and is difficult to\n                // check for. Plus, for modal dialogs with backdrops, it is more\n                // important that the backdrop is checked but not so much the window.\n                if (canScrollY) {\n                    const isRTL = win.getComputedStyle(target).direction === \"rtl\";\n                    if (isRTL) {\n                        xCond = event.offsetX <= target.offsetWidth - target.clientWidth;\n                    }\n                }\n                if (xCond || canScrollX && event.offsetY > target.clientHeight) {\n                    return;\n                }\n            }\n            const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some((node)=>{\n                var _node$context;\n                return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);\n            });\n            if (isEventTargetWithin(event, floating) || isEventTargetWithin(event, domReference) || targetIsInsideChildren) {\n                return;\n            }\n            const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n            if (children.length > 0) {\n                let shouldDismiss = true;\n                children.forEach((child)=>{\n                    var _child$context2;\n                    if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {\n                        shouldDismiss = false;\n                        return;\n                    }\n                });\n                if (!shouldDismiss) {\n                    return;\n                }\n            }\n            events.emit(\"dismiss\", {\n                type: \"outsidePress\",\n                data: {\n                    returnFocus: nested ? {\n                        preventScroll: true\n                    } : isVirtualClick(event) || isVirtualPointerEvent(event)\n                }\n            });\n            onOpenChange(false);\n        }\n        function onScroll() {\n            onOpenChange(false);\n        }\n        const doc = getDocument(floating);\n        escapeKey && doc.addEventListener(\"keydown\", onKeyDown);\n        outsidePress && doc.addEventListener(outsidePressEvent, onOutsidePress);\n        let ancestors = [];\n        if (ancestorScroll) {\n            if (isElement(domReference)) {\n                ancestors = (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors)(domReference);\n            }\n            if (isElement(floating)) {\n                ancestors = ancestors.concat((0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors)(floating));\n            }\n            if (!isElement(reference) && reference && reference.contextElement) {\n                ancestors = ancestors.concat((0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors)(reference.contextElement));\n            }\n        }\n        // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)\n        ancestors = ancestors.filter((ancestor)=>{\n            var _doc$defaultView;\n            return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);\n        });\n        ancestors.forEach((ancestor)=>{\n            ancestor.addEventListener(\"scroll\", onScroll, {\n                passive: true\n            });\n        });\n        return ()=>{\n            escapeKey && doc.removeEventListener(\"keydown\", onKeyDown);\n            outsidePress && doc.removeEventListener(outsidePressEvent, onOutsidePress);\n            ancestors.forEach((ancestor)=>{\n                ancestor.removeEventListener(\"scroll\", onScroll);\n            });\n        };\n    }, [\n        dataRef,\n        floating,\n        domReference,\n        reference,\n        escapeKey,\n        outsidePress,\n        outsidePressEvent,\n        events,\n        tree,\n        nodeId,\n        open,\n        onOpenChange,\n        ancestorScroll,\n        enabled,\n        escapeKeyBubbles,\n        outsidePressBubbles,\n        nested\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        insideReactTreeRef.current = false;\n    }, [\n        outsidePress,\n        outsidePressEvent\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        return {\n            reference: {\n                [bubbleHandlerKeys[referencePressEvent]]: ()=>{\n                    if (referencePress) {\n                        events.emit(\"dismiss\", {\n                            type: \"referencePress\",\n                            data: {\n                                returnFocus: false\n                            }\n                        });\n                        onOpenChange(false);\n                    }\n                }\n            },\n            floating: {\n                [captureHandlerKeys[outsidePressEvent]]: ()=>{\n                    insideReactTreeRef.current = true;\n                }\n            }\n        };\n    }, [\n        enabled,\n        events,\n        referencePress,\n        outsidePressEvent,\n        referencePressEvent,\n        onOpenChange\n    ]);\n};\n/**\n * Adds focus event listeners that change the open state, like CSS :focus.\n * @see https://floating-ui.com/docs/useFocus\n */ const useFocus = function(_ref, _temp) {\n    let { open, onOpenChange, dataRef, events, refs, elements: { floating, domReference } } = _ref;\n    let { enabled = true, keyboardOnly = true } = _temp === void 0 ? {} : _temp;\n    const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(\"\");\n    const blockFocusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) {\n            return;\n        }\n        const doc = getDocument(floating);\n        const win = doc.defaultView || window;\n        // If the reference was focused and the user left the tab/window, and the\n        // floating element was not open, the focus should be blocked when they\n        // return to the tab/window.\n        function onBlur() {\n            if (!open && isHTMLElement(domReference) && domReference === activeElement$1(getDocument(domReference))) {\n                blockFocusRef.current = true;\n            }\n        }\n        win.addEventListener(\"blur\", onBlur);\n        return ()=>{\n            win.removeEventListener(\"blur\", onBlur);\n        };\n    }, [\n        floating,\n        domReference,\n        open,\n        enabled\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) {\n            return;\n        }\n        function onDismiss(payload) {\n            if (payload.type === \"referencePress\" || payload.type === \"escapeKey\") {\n                blockFocusRef.current = true;\n            }\n        }\n        events.on(\"dismiss\", onDismiss);\n        return ()=>{\n            events.off(\"dismiss\", onDismiss);\n        };\n    }, [\n        events,\n        enabled\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return ()=>{\n            clearTimeout(timeoutRef.current);\n        };\n    }, []);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        return {\n            reference: {\n                onPointerDown (_ref2) {\n                    let { pointerType } = _ref2;\n                    pointerTypeRef.current = pointerType;\n                    blockFocusRef.current = !!(pointerType && keyboardOnly);\n                },\n                onMouseLeave () {\n                    blockFocusRef.current = false;\n                },\n                onFocus (event) {\n                    var _dataRef$current$open;\n                    if (blockFocusRef.current) {\n                        return;\n                    }\n                    // Dismiss with click should ignore the subsequent `focus` trigger,\n                    // but only if the click originated inside the reference element.\n                    if (event.type === \"focus\" && ((_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type) === \"mousedown\" && dataRef.current.openEvent && isEventTargetWithin(dataRef.current.openEvent, domReference)) {\n                        return;\n                    }\n                    dataRef.current.openEvent = event.nativeEvent;\n                    onOpenChange(true);\n                },\n                onBlur (event) {\n                    blockFocusRef.current = false;\n                    const relatedTarget = event.relatedTarget;\n                    // Hit the non-modal focus management portal guard. Focus will be\n                    // moved into the floating element immediately after.\n                    const movedToFocusGuard = isElement(relatedTarget) && relatedTarget.hasAttribute(\"data-floating-ui-focus-guard\") && relatedTarget.getAttribute(\"data-type\") === \"outside\";\n                    // Wait for the window blur listener to fire.\n                    timeoutRef.current = setTimeout(()=>{\n                        // When focusing the reference element (e.g. regular click), then\n                        // clicking into the floating element, prevent it from hiding.\n                        // Note: it must be focusable, e.g. `tabindex=\"-1\"`.\n                        if (contains(refs.floating.current, relatedTarget) || contains(domReference, relatedTarget) || movedToFocusGuard) {\n                            return;\n                        }\n                        onOpenChange(false);\n                    });\n                }\n            }\n        };\n    }, [\n        enabled,\n        keyboardOnly,\n        domReference,\n        refs,\n        dataRef,\n        onOpenChange\n    ]);\n};\nlet isPreventScrollSupported = false;\nconst ARROW_UP = \"ArrowUp\";\nconst ARROW_DOWN = \"ArrowDown\";\nconst ARROW_LEFT = \"ArrowLeft\";\nconst ARROW_RIGHT = \"ArrowRight\";\nfunction isDifferentRow(index, cols, prevRow) {\n    return Math.floor(index / cols) !== prevRow;\n}\nfunction isIndexOutOfBounds(listRef, index) {\n    return index < 0 || index >= listRef.current.length;\n}\nfunction findNonDisabledIndex(listRef, _temp) {\n    let { startingIndex = -1, decrement = false, disabledIndices, amount = 1 } = _temp === void 0 ? {} : _temp;\n    const list = listRef.current;\n    let index = startingIndex;\n    do {\n        var _list$index, _list$index2;\n        index = index + (decrement ? -amount : amount);\n    }while (index >= 0 && index <= list.length - 1 && (disabledIndices ? disabledIndices.includes(index) : list[index] == null || ((_list$index = list[index]) == null ? void 0 : _list$index.hasAttribute(\"disabled\")) || ((_list$index2 = list[index]) == null ? void 0 : _list$index2.getAttribute(\"aria-disabled\")) === \"true\"));\n    return index;\n}\nfunction doSwitch(orientation, vertical, horizontal) {\n    switch(orientation){\n        case \"vertical\":\n            return vertical;\n        case \"horizontal\":\n            return horizontal;\n        default:\n            return vertical || horizontal;\n    }\n}\nfunction isMainOrientationKey(key, orientation) {\n    const vertical = key === ARROW_UP || key === ARROW_DOWN;\n    const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;\n    return doSwitch(orientation, vertical, horizontal);\n}\nfunction isMainOrientationToEndKey(key, orientation, rtl) {\n    const vertical = key === ARROW_DOWN;\n    const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n    return doSwitch(orientation, vertical, horizontal) || key === \"Enter\" || key == \" \" || key === \"\";\n}\nfunction isCrossOrientationOpenKey(key, orientation, rtl) {\n    const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n    const horizontal = key === ARROW_DOWN;\n    return doSwitch(orientation, vertical, horizontal);\n}\nfunction isCrossOrientationCloseKey(key, orientation, rtl) {\n    const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;\n    const horizontal = key === ARROW_UP;\n    return doSwitch(orientation, vertical, horizontal);\n}\nfunction getMinIndex(listRef, disabledIndices) {\n    return findNonDisabledIndex(listRef, {\n        disabledIndices\n    });\n}\nfunction getMaxIndex(listRef, disabledIndices) {\n    return findNonDisabledIndex(listRef, {\n        decrement: true,\n        startingIndex: listRef.current.length,\n        disabledIndices\n    });\n}\n/**\n * Adds focus-managed indexed navigation via arrow keys to a list of items\n * within the floating element.\n * @see https://floating-ui.com/docs/useListNavigation\n */ const useListNavigation = function(_ref, _temp2) {\n    let { open, onOpenChange, refs, elements: { domReference } } = _ref;\n    let { listRef, activeIndex, onNavigate: unstable_onNavigate = ()=>{}, enabled = true, selectedIndex = null, allowEscape = false, loop = false, nested = false, rtl = false, virtual = false, focusItemOnOpen = \"auto\", focusItemOnHover = true, openOnArrowKeyDown = true, disabledIndices = undefined, orientation = \"vertical\", cols = 1, scrollItemIntoView = true } = _temp2 === void 0 ? {\n        listRef: {\n            current: []\n        },\n        activeIndex: null,\n        onNavigate: ()=>{}\n    } : _temp2;\n    if (true) {\n        if (allowEscape) {\n            if (!loop) {\n                console.warn([\n                    \"Floating UI: `useListNavigation` looping must be enabled to allow\",\n                    \"escaping.\"\n                ].join(\" \"));\n            }\n            if (!virtual) {\n                console.warn([\n                    \"Floating UI: `useListNavigation` must be virtual to allow\",\n                    \"escaping.\"\n                ].join(\" \"));\n            }\n        }\n        if (orientation === \"vertical\" && cols > 1) {\n            console.warn([\n                \"Floating UI: In grid list navigation mode (`cols` > 1), the\",\n                '`orientation` should be either \"horizontal\" or \"both\".'\n            ].join(\" \"));\n        }\n    }\n    const parentId = useFloatingParentNodeId();\n    const tree = useFloatingTree();\n    const onNavigate = useEvent(unstable_onNavigate);\n    const focusItemOnOpenRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(focusItemOnOpen);\n    const indexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(selectedIndex != null ? selectedIndex : -1);\n    const keyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const isPointerModalityRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n    const previousOnNavigateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(onNavigate);\n    const previousOpenRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(open);\n    const forceSyncFocus = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const forceScrollIntoViewRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const disabledIndicesRef = useLatestRef(disabledIndices);\n    const latestOpenRef = useLatestRef(open);\n    const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);\n    const [activeId, setActiveId] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    const focusItem = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(listRef, indexRef, forceScrollIntoView) {\n        if (forceScrollIntoView === void 0) {\n            forceScrollIntoView = false;\n        }\n        const item = listRef.current[indexRef.current];\n        if (virtual) {\n            setActiveId(item == null ? void 0 : item.id);\n        } else {\n            enqueueFocus(item, {\n                preventScroll: true,\n                // Mac Safari does not move the virtual cursor unless the focus call\n                // is sync. However, for the very first focus call, we need to wait\n                // for the position to be ready in order to prevent unwanted\n                // scrolling. This means the virtual cursor will not move to the first\n                // item when first opening the floating element, but will on\n                // subsequent calls. `preventScroll` is supported in modern Safari,\n                // so we can use that instead.\n                // iOS Safari must be async or the first item will not be focused.\n                sync: isMac() && isSafari() ? isPreventScrollSupported || forceSyncFocus.current : false\n            });\n        }\n        requestAnimationFrame(()=>{\n            const scrollIntoViewOptions = scrollItemIntoViewRef.current;\n            const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);\n            if (shouldScrollIntoView) {\n                // JSDOM doesn't support `.scrollIntoView()` but it's widely supported\n                // by all browsers.\n                item.scrollIntoView == null ? void 0 : item.scrollIntoView(typeof scrollIntoViewOptions === \"boolean\" ? {\n                    block: \"nearest\",\n                    inline: \"nearest\"\n                } : scrollIntoViewOptions);\n            }\n        });\n    }, [\n        virtual,\n        scrollItemIntoViewRef\n    ]);\n    index(()=>{\n        document.createElement(\"div\").focus({\n            get preventScroll () {\n                isPreventScrollSupported = true;\n                return false;\n            }\n        });\n    }, []);\n    // Sync `selectedIndex` to be the `activeIndex` upon opening the floating\n    // element. Also, reset `activeIndex` upon closing the floating element.\n    index(()=>{\n        if (!enabled) {\n            return;\n        }\n        if (open) {\n            if (focusItemOnOpenRef.current && selectedIndex != null) {\n                // Regardless of the pointer modality, we want to ensure the selected\n                // item comes into view when the floating element is opened.\n                forceScrollIntoViewRef.current = true;\n                onNavigate(selectedIndex);\n            }\n        } else if (previousOpenRef.current) {\n            // Since the user can specify `onNavigate` conditionally\n            // (onNavigate: open ? setActiveIndex : setSelectedIndex),\n            // we store and call the previous function.\n            indexRef.current = -1;\n            previousOnNavigateRef.current(null);\n        }\n    }, [\n        enabled,\n        open,\n        selectedIndex,\n        onNavigate\n    ]);\n    // Sync `activeIndex` to be the focused item while the floating element is\n    // open.\n    index(()=>{\n        if (!enabled) {\n            return;\n        }\n        if (open) {\n            if (activeIndex == null) {\n                forceSyncFocus.current = false;\n                if (selectedIndex != null) {\n                    return;\n                }\n                // Reset while the floating element was open (e.g. the list changed).\n                if (previousOpenRef.current) {\n                    indexRef.current = -1;\n                    focusItem(listRef, indexRef);\n                }\n                // Initial sync.\n                if (!previousOpenRef.current && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {\n                    indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);\n                    onNavigate(indexRef.current);\n                }\n            } else if (!isIndexOutOfBounds(listRef, activeIndex)) {\n                indexRef.current = activeIndex;\n                focusItem(listRef, indexRef, forceScrollIntoViewRef.current);\n                forceScrollIntoViewRef.current = false;\n            }\n        }\n    }, [\n        enabled,\n        open,\n        activeIndex,\n        selectedIndex,\n        nested,\n        listRef,\n        orientation,\n        rtl,\n        onNavigate,\n        focusItem,\n        disabledIndicesRef\n    ]);\n    // Ensure the parent floating element has focus when a nested child closes\n    // to allow arrow key navigation to work after the pointer leaves the child.\n    index(()=>{\n        if (!enabled) {\n            return;\n        }\n        if (previousOpenRef.current && !open) {\n            var _tree$nodesRef$curren, _tree$nodesRef$curren2;\n            const parentFloating = tree == null ? void 0 : (_tree$nodesRef$curren = tree.nodesRef.current.find((node)=>node.id === parentId)) == null ? void 0 : (_tree$nodesRef$curren2 = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren2.elements.floating;\n            if (parentFloating && !contains(parentFloating, activeElement$1(getDocument(parentFloating)))) {\n                parentFloating.focus({\n                    preventScroll: true\n                });\n            }\n        }\n    }, [\n        enabled,\n        open,\n        tree,\n        parentId\n    ]);\n    index(()=>{\n        keyRef.current = null;\n        previousOnNavigateRef.current = onNavigate;\n        previousOpenRef.current = open;\n    });\n    const hasActiveIndex = activeIndex != null;\n    const item = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        function syncCurrentTarget(currentTarget) {\n            if (!open) return;\n            const index = listRef.current.indexOf(currentTarget);\n            if (index !== -1) {\n                onNavigate(index);\n            }\n        }\n        const props = {\n            onFocus (_ref2) {\n                let { currentTarget } = _ref2;\n                syncCurrentTarget(currentTarget);\n            },\n            onClick: (_ref3)=>{\n                let { currentTarget } = _ref3;\n                return currentTarget.focus({\n                    preventScroll: true\n                });\n            },\n            // Safari\n            ...focusItemOnHover && {\n                onMouseMove (_ref4) {\n                    let { currentTarget } = _ref4;\n                    syncCurrentTarget(currentTarget);\n                },\n                onPointerLeave () {\n                    if (!isPointerModalityRef.current) {\n                        return;\n                    }\n                    indexRef.current = -1;\n                    focusItem(listRef, indexRef);\n                    // Virtual cursor with VoiceOver on iOS needs this to be flushed\n                    // synchronously or there is a glitch that prevents nested\n                    // submenus from being accessible.\n                    (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(()=>onNavigate(null));\n                    if (!virtual) {\n                        var _refs$floating$curren;\n                        // This also needs to be sync to prevent fast mouse movements\n                        // from leaving behind a stale active item when landing on a\n                        // disabled button item.\n                        (_refs$floating$curren = refs.floating.current) == null ? void 0 : _refs$floating$curren.focus({\n                            preventScroll: true\n                        });\n                    }\n                }\n            }\n        };\n        return props;\n    }, [\n        open,\n        refs,\n        focusItem,\n        focusItemOnHover,\n        listRef,\n        onNavigate,\n        virtual\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        const disabledIndices = disabledIndicesRef.current;\n        function onKeyDown(event) {\n            isPointerModalityRef.current = false;\n            forceSyncFocus.current = true;\n            // If the floating element is animating out, ignore navigation. Otherwise,\n            // the `activeIndex` gets set to 0 despite not being open so the next time\n            // the user ArrowDowns, the first item won't be focused.\n            if (!latestOpenRef.current && event.currentTarget === refs.floating.current) {\n                return;\n            }\n            if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {\n                stopEvent(event);\n                onOpenChange(false);\n                if (isHTMLElement(domReference)) {\n                    domReference.focus();\n                }\n                return;\n            }\n            const currentIndex = indexRef.current;\n            const minIndex = getMinIndex(listRef, disabledIndices);\n            const maxIndex = getMaxIndex(listRef, disabledIndices);\n            if (event.key === \"Home\") {\n                indexRef.current = minIndex;\n                onNavigate(indexRef.current);\n            }\n            if (event.key === \"End\") {\n                indexRef.current = maxIndex;\n                onNavigate(indexRef.current);\n            }\n            // Grid navigation.\n            if (cols > 1) {\n                const prevIndex = indexRef.current;\n                if (event.key === ARROW_UP) {\n                    stopEvent(event);\n                    if (prevIndex === -1) {\n                        indexRef.current = maxIndex;\n                    } else {\n                        indexRef.current = findNonDisabledIndex(listRef, {\n                            startingIndex: prevIndex,\n                            amount: cols,\n                            decrement: true,\n                            disabledIndices\n                        });\n                        if (loop && (prevIndex - cols < minIndex || indexRef.current < 0)) {\n                            const col = prevIndex % cols;\n                            const maxCol = maxIndex % cols;\n                            const offset = maxIndex - (maxCol - col);\n                            if (maxCol === col) {\n                                indexRef.current = maxIndex;\n                            } else {\n                                indexRef.current = maxCol > col ? offset : offset - cols;\n                            }\n                        }\n                    }\n                    if (isIndexOutOfBounds(listRef, indexRef.current)) {\n                        indexRef.current = prevIndex;\n                    }\n                    onNavigate(indexRef.current);\n                }\n                if (event.key === ARROW_DOWN) {\n                    stopEvent(event);\n                    if (prevIndex === -1) {\n                        indexRef.current = minIndex;\n                    } else {\n                        indexRef.current = findNonDisabledIndex(listRef, {\n                            startingIndex: prevIndex,\n                            amount: cols,\n                            disabledIndices\n                        });\n                        if (loop && prevIndex + cols > maxIndex) {\n                            indexRef.current = findNonDisabledIndex(listRef, {\n                                startingIndex: prevIndex % cols - cols,\n                                amount: cols,\n                                disabledIndices\n                            });\n                        }\n                    }\n                    if (isIndexOutOfBounds(listRef, indexRef.current)) {\n                        indexRef.current = prevIndex;\n                    }\n                    onNavigate(indexRef.current);\n                }\n                // Remains on the same row/column.\n                if (orientation === \"both\") {\n                    const prevRow = Math.floor(prevIndex / cols);\n                    if (event.key === ARROW_RIGHT) {\n                        stopEvent(event);\n                        if (prevIndex % cols !== cols - 1) {\n                            indexRef.current = findNonDisabledIndex(listRef, {\n                                startingIndex: prevIndex,\n                                disabledIndices\n                            });\n                            if (loop && isDifferentRow(indexRef.current, cols, prevRow)) {\n                                indexRef.current = findNonDisabledIndex(listRef, {\n                                    startingIndex: prevIndex - prevIndex % cols - 1,\n                                    disabledIndices\n                                });\n                            }\n                        } else if (loop) {\n                            indexRef.current = findNonDisabledIndex(listRef, {\n                                startingIndex: prevIndex - prevIndex % cols - 1,\n                                disabledIndices\n                            });\n                        }\n                        if (isDifferentRow(indexRef.current, cols, prevRow)) {\n                            indexRef.current = prevIndex;\n                        }\n                    }\n                    if (event.key === ARROW_LEFT) {\n                        stopEvent(event);\n                        if (prevIndex % cols !== 0) {\n                            indexRef.current = findNonDisabledIndex(listRef, {\n                                startingIndex: prevIndex,\n                                disabledIndices,\n                                decrement: true\n                            });\n                            if (loop && isDifferentRow(indexRef.current, cols, prevRow)) {\n                                indexRef.current = findNonDisabledIndex(listRef, {\n                                    startingIndex: prevIndex + (cols - prevIndex % cols),\n                                    decrement: true,\n                                    disabledIndices\n                                });\n                            }\n                        } else if (loop) {\n                            indexRef.current = findNonDisabledIndex(listRef, {\n                                startingIndex: prevIndex + (cols - prevIndex % cols),\n                                decrement: true,\n                                disabledIndices\n                            });\n                        }\n                        if (isDifferentRow(indexRef.current, cols, prevRow)) {\n                            indexRef.current = prevIndex;\n                        }\n                    }\n                    const lastRow = Math.floor(maxIndex / cols) === prevRow;\n                    if (isIndexOutOfBounds(listRef, indexRef.current)) {\n                        if (loop && lastRow) {\n                            indexRef.current = event.key === ARROW_LEFT ? maxIndex : findNonDisabledIndex(listRef, {\n                                startingIndex: prevIndex - prevIndex % cols - 1,\n                                disabledIndices\n                            });\n                        } else {\n                            indexRef.current = prevIndex;\n                        }\n                    }\n                    onNavigate(indexRef.current);\n                    return;\n                }\n            }\n            if (isMainOrientationKey(event.key, orientation)) {\n                stopEvent(event);\n                // Reset the index if no item is focused.\n                if (open && !virtual && activeElement$1(event.currentTarget.ownerDocument) === event.currentTarget) {\n                    indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;\n                    onNavigate(indexRef.current);\n                    return;\n                }\n                if (isMainOrientationToEndKey(event.key, orientation, rtl)) {\n                    if (loop) {\n                        indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {\n                            startingIndex: currentIndex,\n                            disabledIndices\n                        });\n                    } else {\n                        indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {\n                            startingIndex: currentIndex,\n                            disabledIndices\n                        }));\n                    }\n                } else {\n                    if (loop) {\n                        indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {\n                            startingIndex: currentIndex,\n                            decrement: true,\n                            disabledIndices\n                        });\n                    } else {\n                        indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {\n                            startingIndex: currentIndex,\n                            decrement: true,\n                            disabledIndices\n                        }));\n                    }\n                }\n                if (isIndexOutOfBounds(listRef, indexRef.current)) {\n                    onNavigate(null);\n                } else {\n                    onNavigate(indexRef.current);\n                }\n            }\n        }\n        function checkVirtualMouse(event) {\n            if (focusItemOnOpen === \"auto\" && isVirtualClick(event.nativeEvent)) {\n                focusItemOnOpenRef.current = true;\n            }\n        }\n        function checkVirtualPointer(event) {\n            // `pointerdown` fires first, reset the state then perform the checks.\n            focusItemOnOpenRef.current = focusItemOnOpen;\n            if (focusItemOnOpen === \"auto\" && isVirtualPointerEvent(event.nativeEvent)) {\n                focusItemOnOpenRef.current = true;\n            }\n        }\n        const ariaActiveDescendantProp = virtual && open && hasActiveIndex && {\n            \"aria-activedescendant\": activeId\n        };\n        return {\n            reference: {\n                ...ariaActiveDescendantProp,\n                onKeyDown (event) {\n                    isPointerModalityRef.current = false;\n                    const isArrowKey = event.key.indexOf(\"Arrow\") === 0;\n                    if (virtual && open) {\n                        return onKeyDown(event);\n                    }\n                    // If a floating element should not open on arrow key down, avoid\n                    // setting `activeIndex` while it's closed.\n                    if (!open && !openOnArrowKeyDown && isArrowKey) {\n                        return;\n                    }\n                    const isNavigationKey = isArrowKey || event.key === \"Enter\" || event.key === \" \" || event.key === \"\";\n                    if (isNavigationKey) {\n                        keyRef.current = event.key;\n                    }\n                    if (nested) {\n                        if (isCrossOrientationOpenKey(event.key, orientation, rtl)) {\n                            stopEvent(event);\n                            if (open) {\n                                indexRef.current = getMinIndex(listRef, disabledIndices);\n                                onNavigate(indexRef.current);\n                            } else {\n                                onOpenChange(true);\n                            }\n                        }\n                        return;\n                    }\n                    if (isMainOrientationKey(event.key, orientation)) {\n                        if (selectedIndex != null) {\n                            indexRef.current = selectedIndex;\n                        }\n                        stopEvent(event);\n                        if (!open && openOnArrowKeyDown) {\n                            onOpenChange(true);\n                        } else {\n                            onKeyDown(event);\n                        }\n                        if (open) {\n                            onNavigate(indexRef.current);\n                        }\n                    }\n                },\n                onFocus () {\n                    if (open) {\n                        onNavigate(null);\n                    }\n                },\n                onPointerDown: checkVirtualPointer,\n                onMouseDown: checkVirtualMouse,\n                onClick: checkVirtualMouse\n            },\n            floating: {\n                \"aria-orientation\": orientation === \"both\" ? undefined : orientation,\n                ...ariaActiveDescendantProp,\n                onKeyDown,\n                onPointerMove () {\n                    isPointerModalityRef.current = true;\n                }\n            },\n            item\n        };\n    }, [\n        domReference,\n        refs,\n        activeId,\n        disabledIndicesRef,\n        latestOpenRef,\n        listRef,\n        enabled,\n        orientation,\n        rtl,\n        virtual,\n        open,\n        hasActiveIndex,\n        nested,\n        selectedIndex,\n        openOnArrowKeyDown,\n        allowEscape,\n        cols,\n        loop,\n        focusItemOnOpen,\n        onNavigate,\n        onOpenChange,\n        item\n    ]);\n};\nfunction useMergeRefs(refs) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (refs.every((ref)=>ref == null)) {\n            return null;\n        }\n        return (value)=>{\n            refs.forEach((ref)=>{\n                if (typeof ref === \"function\") {\n                    ref(value);\n                } else if (ref != null) {\n                    ref.current = value;\n                }\n            });\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, refs);\n}\n/**\n * Adds relevant screen reader props for a given element `role`.\n * @see https://floating-ui.com/docs/useRole\n */ const useRole = function(_ref, _temp) {\n    let { open } = _ref;\n    let { enabled = true, role = \"dialog\" } = _temp === void 0 ? {} : _temp;\n    const rootId = useId();\n    const referenceId = useId();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        const floatingProps = {\n            id: rootId,\n            role\n        };\n        if (!enabled) {\n            return {};\n        }\n        if (role === \"tooltip\") {\n            return {\n                reference: {\n                    \"aria-describedby\": open ? rootId : undefined\n                },\n                floating: floatingProps\n            };\n        }\n        return {\n            reference: {\n                \"aria-expanded\": open ? \"true\" : \"false\",\n                \"aria-haspopup\": role === \"alertdialog\" ? \"dialog\" : role,\n                \"aria-controls\": open ? rootId : undefined,\n                ...role === \"listbox\" && {\n                    role: \"combobox\"\n                },\n                ...role === \"menu\" && {\n                    id: referenceId\n                }\n            },\n            floating: {\n                ...floatingProps,\n                ...role === \"menu\" && {\n                    \"aria-labelledby\": referenceId\n                }\n            }\n        };\n    }, [\n        enabled,\n        role,\n        open,\n        rootId,\n        referenceId\n    ]);\n};\n// Converts a JS style key like `backgroundColor` to a CSS transition-property\n// like `background-color`.\nconst camelCaseToKebabCase = (str)=>str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs)=>(ofs ? \"-\" : \"\") + $.toLowerCase());\nfunction useDelayUnmount(open, durationMs) {\n    const [isMounted, setIsMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(open);\n    if (open && !isMounted) {\n        setIsMounted(true);\n    }\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!open) {\n            const timeout = setTimeout(()=>setIsMounted(false), durationMs);\n            return ()=>clearTimeout(timeout);\n        }\n    }, [\n        open,\n        durationMs\n    ]);\n    return isMounted;\n}\n/**\n * Provides a status string to apply CSS transitions to a floating element,\n * correctly handling placement-aware transitions.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstatus\n */ function useTransitionStatus(_ref, _temp) {\n    let { open, elements: { floating } } = _ref;\n    let { duration = 250 } = _temp === void 0 ? {} : _temp;\n    const isNumberDuration = typeof duration === \"number\";\n    const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n    const [initiated, setInitiated] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const [status, setStatus] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\"unmounted\");\n    const isMounted = useDelayUnmount(open, closeDuration);\n    // `initiated` check prevents this `setState` call from breaking\n    // <FloatingPortal />. This call is necessary to ensure subsequent opens\n    // after the initial one allows the correct side animation to play when the\n    // placement has changed.\n    index(()=>{\n        if (initiated && !isMounted) {\n            setStatus(\"unmounted\");\n        }\n    }, [\n        initiated,\n        isMounted\n    ]);\n    index(()=>{\n        if (!floating) return;\n        if (open) {\n            setStatus(\"initial\");\n            const frame = requestAnimationFrame(()=>{\n                setStatus(\"open\");\n            });\n            return ()=>{\n                cancelAnimationFrame(frame);\n            };\n        } else {\n            setInitiated(true);\n            setStatus(\"close\");\n        }\n    }, [\n        open,\n        floating\n    ]);\n    return {\n        isMounted,\n        status\n    };\n}\n/**\n * Provides styles to apply CSS transitions to a floating element, correctly\n * handling placement-aware transitions. Wrapper around `useTransitionStatus`.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstyles\n */ function useTransitionStyles(context, _temp2) {\n    let { initial: unstable_initial = {\n        opacity: 0\n    }, open: unstable_open, close: unstable_close, common: unstable_common, duration = 250 } = _temp2 === void 0 ? {} : _temp2;\n    const placement = context.placement;\n    const side = placement.split(\"-\")[0];\n    const [styles, setStyles] = react__WEBPACK_IMPORTED_MODULE_0__.useState({});\n    const { isMounted, status } = useTransitionStatus(context, {\n        duration\n    });\n    const initialRef = useLatestRef(unstable_initial);\n    const openRef = useLatestRef(unstable_open);\n    const closeRef = useLatestRef(unstable_close);\n    const commonRef = useLatestRef(unstable_common);\n    const isNumberDuration = typeof duration === \"number\";\n    const openDuration = (isNumberDuration ? duration : duration.open) || 0;\n    const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n    index(()=>{\n        const fnArgs = {\n            side,\n            placement\n        };\n        const initial = initialRef.current;\n        const close = closeRef.current;\n        const open = openRef.current;\n        const common = commonRef.current;\n        const initialStyles = typeof initial === \"function\" ? initial(fnArgs) : initial;\n        const closeStyles = typeof close === \"function\" ? close(fnArgs) : close;\n        const commonStyles = typeof common === \"function\" ? common(fnArgs) : common;\n        const openStyles = (typeof open === \"function\" ? open(fnArgs) : open) || Object.keys(initialStyles).reduce((acc, key)=>{\n            acc[key] = \"\";\n            return acc;\n        }, {});\n        if (status === \"initial\") {\n            setStyles((styles)=>({\n                    transitionProperty: styles.transitionProperty,\n                    ...commonStyles,\n                    ...initialStyles\n                }));\n        }\n        if (status === \"open\") {\n            setStyles({\n                transitionProperty: Object.keys(openStyles).map(camelCaseToKebabCase).join(\",\"),\n                transitionDuration: openDuration + \"ms\",\n                ...commonStyles,\n                ...openStyles\n            });\n        }\n        if (status === \"close\") {\n            const styles = closeStyles || initialStyles;\n            setStyles({\n                transitionProperty: Object.keys(styles).map(camelCaseToKebabCase).join(\",\"),\n                transitionDuration: closeDuration + \"ms\",\n                ...commonStyles,\n                ...styles\n            });\n        }\n    }, [\n        side,\n        placement,\n        closeDuration,\n        closeRef,\n        initialRef,\n        openRef,\n        commonRef,\n        openDuration,\n        status\n    ]);\n    return {\n        isMounted,\n        styles\n    };\n}\n/**\n * Provides a matching callback that can be used to focus an item as the user\n * types, often used in tandem with `useListNavigation()`.\n * @see https://floating-ui.com/docs/useTypeahead\n */ const useTypeahead = function(_ref, _temp) {\n    var _ref2;\n    let { open, dataRef } = _ref;\n    let { listRef, activeIndex, onMatch: unstable_onMatch = ()=>{}, enabled = true, findMatch = null, resetMs = 1000, ignoreKeys = [], selectedIndex = null } = _temp === void 0 ? {\n        listRef: {\n            current: []\n        },\n        activeIndex: null\n    } : _temp;\n    const timeoutIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const stringRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(\"\");\n    const prevIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef((_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1);\n    const matchIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const onMatch = useEvent(unstable_onMatch);\n    const findMatchRef = useLatestRef(findMatch);\n    const ignoreKeysRef = useLatestRef(ignoreKeys);\n    index(()=>{\n        if (open) {\n            clearTimeout(timeoutIdRef.current);\n            matchIndexRef.current = null;\n            stringRef.current = \"\";\n        }\n    }, [\n        open\n    ]);\n    index(()=>{\n        // Sync arrow key navigation but not typeahead navigation.\n        if (open && stringRef.current === \"\") {\n            var _ref3;\n            prevIndexRef.current = (_ref3 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref3 : -1;\n        }\n    }, [\n        open,\n        selectedIndex,\n        activeIndex\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        function onKeyDown(event) {\n            // Correctly scope nested non-portalled floating elements. Since the nested\n            // floating element is inside of the another, we find the closest role\n            // that indicates the floating element scope.\n            const target = getTarget(event.nativeEvent);\n            if (isElement(target) && (activeElement$1(getDocument(target)) !== event.currentTarget ? target.closest('[role=\"dialog\"],[role=\"menu\"],[role=\"listbox\"],[role=\"tree\"],[role=\"grid\"]') !== event.currentTarget : false)) {\n                return;\n            }\n            if (stringRef.current.length > 0 && stringRef.current[0] !== \" \") {\n                dataRef.current.typing = true;\n                if (event.key === \" \") {\n                    stopEvent(event);\n                }\n            }\n            const listContent = listRef.current;\n            if (listContent == null || ignoreKeysRef.current.includes(event.key) || // Character key.\n            event.key.length !== 1 || // Modifier key.\n            event.ctrlKey || event.metaKey || event.altKey) {\n                return;\n            }\n            // Bail out if the list contains a word like \"llama\" or \"aaron\". TODO:\n            // allow it in this case, too.\n            const allowRapidSuccessionOfFirstLetter = listContent.every((text)=>{\n                var _text$, _text$2;\n                return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;\n            });\n            // Allows the user to cycle through items that start with the same letter\n            // in rapid succession.\n            if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {\n                stringRef.current = \"\";\n                prevIndexRef.current = matchIndexRef.current;\n            }\n            stringRef.current += event.key;\n            clearTimeout(timeoutIdRef.current);\n            timeoutIdRef.current = setTimeout(()=>{\n                stringRef.current = \"\";\n                prevIndexRef.current = matchIndexRef.current;\n                dataRef.current.typing = false;\n            }, resetMs);\n            const prevIndex = prevIndexRef.current;\n            const orderedList = [\n                ...listContent.slice((prevIndex || 0) + 1),\n                ...listContent.slice(0, (prevIndex || 0) + 1)\n            ];\n            const str = findMatchRef.current ? findMatchRef.current(orderedList, stringRef.current) : orderedList.find((text)=>(text == null ? void 0 : text.toLocaleLowerCase().indexOf(stringRef.current.toLocaleLowerCase())) === 0);\n            const index = str ? listContent.indexOf(str) : -1;\n            if (index !== -1) {\n                onMatch(index);\n                matchIndexRef.current = index;\n            }\n        }\n        return {\n            reference: {\n                onKeyDown\n            },\n            floating: {\n                onKeyDown\n            }\n        };\n    }, [\n        enabled,\n        dataRef,\n        listRef,\n        resetMs,\n        ignoreKeysRef,\n        findMatchRef,\n        onMatch\n    ]);\n};\nfunction getArgsWithCustomFloatingHeight(args, height) {\n    return {\n        ...args,\n        rects: {\n            ...args.rects,\n            floating: {\n                ...args.rects.floating,\n                height\n            }\n        }\n    };\n}\n/**\n * Positions the floating element such that an inner element inside\n * of it is anchored to the reference element.\n * @see https://floating-ui.com/docs/inner\n */ const inner = (props)=>({\n        name: \"inner\",\n        options: props,\n        async fn (middlewareArguments) {\n            const { listRef, overflowRef, onFallbackChange, offset: innerOffset = 0, index = 0, minItemsVisible = 4, referenceOverflowThreshold = 0, scrollRef, ...detectOverflowOptions } = props;\n            const { rects, elements: { floating } } = middlewareArguments;\n            const item = listRef.current[index];\n            if (true) {\n                if (!middlewareArguments.placement.startsWith(\"bottom\")) {\n                    console.warn([\n                        'Floating UI: `placement` side must be \"bottom\" when using the',\n                        \"`inner` middleware.\"\n                    ].join(\" \"));\n                }\n            }\n            if (!item) {\n                return {};\n            }\n            const nextArgs = {\n                ...middlewareArguments,\n                ...await (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_3__.offset)(-item.offsetTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(middlewareArguments)\n            };\n            const el = (scrollRef == null ? void 0 : scrollRef.current) || floating;\n            const overflow = await (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_3__.detectOverflow)(getArgsWithCustomFloatingHeight(nextArgs, el.scrollHeight), detectOverflowOptions);\n            const refOverflow = await (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_3__.detectOverflow)(nextArgs, {\n                ...detectOverflowOptions,\n                elementContext: \"reference\"\n            });\n            const diffY = Math.max(0, overflow.top);\n            const nextY = nextArgs.y + diffY;\n            const maxHeight = Math.max(0, el.scrollHeight - diffY - Math.max(0, overflow.bottom));\n            el.style.maxHeight = maxHeight + \"px\";\n            el.scrollTop = diffY;\n            // There is not enough space, fallback to standard anchored positioning\n            if (onFallbackChange) {\n                if (el.offsetHeight < item.offsetHeight * Math.min(minItemsVisible, listRef.current.length - 1) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold) {\n                    (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(()=>onFallbackChange(true));\n                } else {\n                    (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(()=>onFallbackChange(false));\n                }\n            }\n            if (overflowRef) {\n                overflowRef.current = await (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_3__.detectOverflow)(getArgsWithCustomFloatingHeight({\n                    ...nextArgs,\n                    y: nextY\n                }, el.offsetHeight), detectOverflowOptions);\n            }\n            return {\n                y: nextY\n            };\n        }\n    });\n/**\n * Changes the `inner` middleware's `offset` upon a `wheel` event to\n * expand the floating element's height, revealing more list items.\n * @see https://floating-ui.com/docs/inner\n */ const useInnerOffset = (_ref, _ref2)=>{\n    let { open, elements } = _ref;\n    let { enabled = true, overflowRef, scrollRef, onChange: unstable_onChange } = _ref2;\n    const onChange = useEvent(unstable_onChange);\n    const controlledScrollingRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const prevScrollTopRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const initialOverflowRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) {\n            return;\n        }\n        function onWheel(e) {\n            if (e.ctrlKey || !el || overflowRef.current == null) {\n                return;\n            }\n            const dY = e.deltaY;\n            const isAtTop = overflowRef.current.top >= -0.5;\n            const isAtBottom = overflowRef.current.bottom >= -0.5;\n            const remainingScroll = el.scrollHeight - el.clientHeight;\n            const sign = dY < 0 ? -1 : 1;\n            const method = dY < 0 ? \"max\" : \"min\";\n            if (el.scrollHeight <= el.clientHeight) {\n                return;\n            }\n            if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {\n                e.preventDefault();\n                (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(()=>{\n                    onChange((d)=>d + Math[method](dY, remainingScroll * sign));\n                });\n            } else if (/firefox/i.test(getUserAgent())) {\n                // Needed to propagate scrolling during momentum scrolling phase once\n                // it gets limited by the boundary. UX improvement, not critical.\n                el.scrollTop += dY;\n            }\n        }\n        const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n        if (open && el) {\n            el.addEventListener(\"wheel\", onWheel);\n            // Wait for the position to be ready.\n            requestAnimationFrame(()=>{\n                prevScrollTopRef.current = el.scrollTop;\n                if (overflowRef.current != null) {\n                    initialOverflowRef.current = {\n                        ...overflowRef.current\n                    };\n                }\n            });\n            return ()=>{\n                prevScrollTopRef.current = null;\n                initialOverflowRef.current = null;\n                el.removeEventListener(\"wheel\", onWheel);\n            };\n        }\n    }, [\n        enabled,\n        open,\n        elements.floating,\n        overflowRef,\n        scrollRef,\n        onChange\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        return {\n            floating: {\n                onKeyDown () {\n                    controlledScrollingRef.current = true;\n                },\n                onWheel () {\n                    controlledScrollingRef.current = false;\n                },\n                onPointerMove () {\n                    controlledScrollingRef.current = false;\n                },\n                onScroll () {\n                    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n                    if (!overflowRef.current || !el || !controlledScrollingRef.current) {\n                        return;\n                    }\n                    if (prevScrollTopRef.current !== null) {\n                        const scrollDiff = el.scrollTop - prevScrollTopRef.current;\n                        if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {\n                            (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(()=>onChange((d)=>d + scrollDiff));\n                        }\n                    }\n                    // [Firefox] Wait for the height change to have been applied.\n                    requestAnimationFrame(()=>{\n                        prevScrollTopRef.current = el.scrollTop;\n                    });\n                }\n            }\n        };\n    }, [\n        enabled,\n        overflowRef,\n        elements.floating,\n        scrollRef,\n        onChange\n    ]);\n};\nfunction isPointInPolygon(point, polygon) {\n    const [x, y] = point;\n    let isInside = false;\n    const length = polygon.length;\n    for(let i = 0, j = length - 1; i < length; j = i++){\n        const [xi, yi] = polygon[i] || [\n            0,\n            0\n        ];\n        const [xj, yj] = polygon[j] || [\n            0,\n            0\n        ];\n        const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\nfunction isInside(point, rect) {\n    return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;\n}\nfunction safePolygon(_temp) {\n    let { restMs = 0, buffer = 0.5, blockPointerEvents = false } = _temp === void 0 ? {} : _temp;\n    let timeoutId;\n    let isInsideRect = false;\n    let hasLanded = false;\n    const fn = (_ref)=>{\n        let { x, y, placement, elements, onClose, nodeId, tree } = _ref;\n        return function onMouseMove(event) {\n            function close() {\n                clearTimeout(timeoutId);\n                onClose();\n            }\n            clearTimeout(timeoutId);\n            if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {\n                return;\n            }\n            const { clientX, clientY } = event;\n            const clientPoint = [\n                clientX,\n                clientY\n            ];\n            const target = getTarget(event);\n            const isLeave = event.type === \"mouseleave\";\n            const isOverFloatingEl = contains(elements.floating, target);\n            const isOverReferenceEl = contains(elements.domReference, target);\n            const refRect = elements.domReference.getBoundingClientRect();\n            const rect = elements.floating.getBoundingClientRect();\n            const side = placement.split(\"-\")[0];\n            const cursorLeaveFromRight = x > rect.right - rect.width / 2;\n            const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;\n            const isOverReferenceRect = isInside(clientPoint, refRect);\n            if (isOverFloatingEl) {\n                hasLanded = true;\n            }\n            if (isOverReferenceEl) {\n                hasLanded = false;\n            }\n            if (isOverReferenceEl && !isLeave) {\n                hasLanded = true;\n                return;\n            }\n            // Prevent overlapping floating element from being stuck in an open-close\n            // loop: https://github.com/floating-ui/floating-ui/issues/1910\n            if (isLeave && isElement(event.relatedTarget) && contains(elements.floating, event.relatedTarget)) {\n                return;\n            }\n            // If any nested child is open, abort.\n            if (tree && getChildren(tree.nodesRef.current, nodeId).some((_ref2)=>{\n                let { context } = _ref2;\n                return context == null ? void 0 : context.open;\n            })) {\n                return;\n            }\n            // If the pointer is leaving from the opposite side, the \"buffer\" logic\n            // creates a point where the floating element remains open, but should be\n            // ignored.\n            // A constant of 1 handles floating point rounding errors.\n            if (side === \"top\" && y >= refRect.bottom - 1 || side === \"bottom\" && y <= refRect.top + 1 || side === \"left\" && x >= refRect.right - 1 || side === \"right\" && x <= refRect.left + 1) {\n                return close();\n            }\n            // Ignore when the cursor is within the rectangular trough between the\n            // two elements. Since the triangle is created from the cursor point,\n            // which can start beyond the ref element's edge, traversing back and\n            // forth from the ref to the floating element can cause it to close. This\n            // ensures it always remains open in that case.\n            let rectPoly = [];\n            switch(side){\n                case \"top\":\n                    rectPoly = [\n                        [\n                            rect.left,\n                            refRect.top + 1\n                        ],\n                        [\n                            rect.left,\n                            rect.bottom - 1\n                        ],\n                        [\n                            rect.right,\n                            rect.bottom - 1\n                        ],\n                        [\n                            rect.right,\n                            refRect.top + 1\n                        ]\n                    ];\n                    isInsideRect = clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= refRect.top + 1;\n                    break;\n                case \"bottom\":\n                    rectPoly = [\n                        [\n                            rect.left,\n                            rect.top + 1\n                        ],\n                        [\n                            rect.left,\n                            refRect.bottom - 1\n                        ],\n                        [\n                            rect.right,\n                            refRect.bottom - 1\n                        ],\n                        [\n                            rect.right,\n                            rect.top + 1\n                        ]\n                    ];\n                    isInsideRect = clientX >= rect.left && clientX <= rect.right && clientY >= refRect.bottom - 1 && clientY <= rect.bottom;\n                    break;\n                case \"left\":\n                    rectPoly = [\n                        [\n                            rect.right - 1,\n                            rect.bottom\n                        ],\n                        [\n                            rect.right - 1,\n                            rect.top\n                        ],\n                        [\n                            refRect.left + 1,\n                            rect.top\n                        ],\n                        [\n                            refRect.left + 1,\n                            rect.bottom\n                        ]\n                    ];\n                    isInsideRect = clientX >= rect.left && clientX <= refRect.left + 1 && clientY >= rect.top && clientY <= rect.bottom;\n                    break;\n                case \"right\":\n                    rectPoly = [\n                        [\n                            refRect.right - 1,\n                            rect.bottom\n                        ],\n                        [\n                            refRect.right - 1,\n                            rect.top\n                        ],\n                        [\n                            rect.left + 1,\n                            rect.top\n                        ],\n                        [\n                            rect.left + 1,\n                            rect.bottom\n                        ]\n                    ];\n                    isInsideRect = clientX >= refRect.right - 1 && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\n                    break;\n            }\n            function getPolygon(_ref3) {\n                let [x, y] = _ref3;\n                const isFloatingWider = rect.width > refRect.width;\n                const isFloatingTaller = rect.height > refRect.height;\n                switch(side){\n                    case \"top\":\n                        {\n                            const cursorPointOne = [\n                                isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y + buffer + 1\n                            ];\n                            const cursorPointTwo = [\n                                isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y + buffer + 1\n                            ];\n                            const commonPoints = [\n                                [\n                                    rect.left,\n                                    cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top\n                                ],\n                                [\n                                    rect.right,\n                                    cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer\n                                ]\n                            ];\n                            return [\n                                cursorPointOne,\n                                cursorPointTwo,\n                                ...commonPoints\n                            ];\n                        }\n                    case \"bottom\":\n                        {\n                            const cursorPointOne = [\n                                isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y - buffer\n                            ];\n                            const cursorPointTwo = [\n                                isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y - buffer\n                            ];\n                            const commonPoints = [\n                                [\n                                    rect.left,\n                                    cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom\n                                ],\n                                [\n                                    rect.right,\n                                    cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer\n                                ]\n                            ];\n                            return [\n                                cursorPointOne,\n                                cursorPointTwo,\n                                ...commonPoints\n                            ];\n                        }\n                    case \"left\":\n                        {\n                            const cursorPointOne = [\n                                x + buffer + 1,\n                                isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const cursorPointTwo = [\n                                x + buffer + 1,\n                                isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const commonPoints = [\n                                [\n                                    cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left,\n                                    rect.top\n                                ],\n                                [\n                                    cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer,\n                                    rect.bottom\n                                ]\n                            ];\n                            return [\n                                ...commonPoints,\n                                cursorPointOne,\n                                cursorPointTwo\n                            ];\n                        }\n                    case \"right\":\n                        {\n                            const cursorPointOne = [\n                                x - buffer,\n                                isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const cursorPointTwo = [\n                                x - buffer,\n                                isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const commonPoints = [\n                                [\n                                    cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right,\n                                    rect.top\n                                ],\n                                [\n                                    cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer,\n                                    rect.bottom\n                                ]\n                            ];\n                            return [\n                                cursorPointOne,\n                                cursorPointTwo,\n                                ...commonPoints\n                            ];\n                        }\n                }\n            }\n            const poly = isInsideRect ? rectPoly : getPolygon([\n                x,\n                y\n            ]);\n            if (isInsideRect) {\n                return;\n            } else if (hasLanded && !isOverReferenceRect) {\n                return close();\n            }\n            if (!isPointInPolygon([\n                clientX,\n                clientY\n            ], poly)) {\n                close();\n            } else if (restMs && !hasLanded) {\n                timeoutId = setTimeout(close, restMs);\n            }\n        };\n    };\n    fn.__options = {\n        blockPointerEvents\n    };\n    return fn;\n}\nfunction useFloating(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { open = false, onOpenChange: unstable_onOpenChange, nodeId } = options;\n    const position = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.useFloating)(options);\n    const tree = useFloatingTree();\n    const domReferenceRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const dataRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({});\n    const events = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>createPubSub())[0];\n    const [domReference, setDomReference] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const setPositionReference = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        const positionReference = isElement(node) ? {\n            getBoundingClientRect: ()=>node.getBoundingClientRect(),\n            contextElement: node\n        } : node;\n        position.refs.setReference(positionReference);\n    }, [\n        position.refs\n    ]);\n    const setReference = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        if (isElement(node) || node === null) {\n            domReferenceRef.current = node;\n            setDomReference(node);\n        }\n        // Backwards-compatibility for passing a virtual element to `reference`\n        // after it has set the DOM reference.\n        if (isElement(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to\n        // `null` to support `positionReference` + an unstable `reference`\n        // callback ref.\n        node !== null && !isElement(node)) {\n            position.refs.setReference(node);\n        }\n    }, [\n        position.refs\n    ]);\n    const refs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ...position.refs,\n            setReference,\n            setPositionReference,\n            domReference: domReferenceRef\n        }), [\n        position.refs,\n        setReference,\n        setPositionReference\n    ]);\n    const elements = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ...position.elements,\n            domReference: domReference\n        }), [\n        position.elements,\n        domReference\n    ]);\n    const onOpenChange = useEvent(unstable_onOpenChange);\n    const context = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ...position,\n            refs,\n            elements,\n            dataRef,\n            nodeId,\n            events,\n            open,\n            onOpenChange\n        }), [\n        position,\n        nodeId,\n        events,\n        open,\n        onOpenChange,\n        refs,\n        elements\n    ]);\n    index(()=>{\n        const node = tree == null ? void 0 : tree.nodesRef.current.find((node)=>node.id === nodeId);\n        if (node) {\n            node.context = context;\n        }\n    });\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ...position,\n            context,\n            refs,\n            reference: setReference,\n            positionReference: setPositionReference\n        }), [\n        position,\n        refs,\n        context,\n        setReference,\n        setPositionReference\n    ]);\n}\nfunction mergeProps(userProps, propsList, elementKey) {\n    const map = new Map();\n    return {\n        ...elementKey === \"floating\" && {\n            tabIndex: -1\n        },\n        ...userProps,\n        ...propsList.map((value)=>value ? value[elementKey] : null).concat(userProps).reduce((acc, props)=>{\n            if (!props) {\n                return acc;\n            }\n            Object.entries(props).forEach((_ref)=>{\n                let [key, value] = _ref;\n                if (key.indexOf(\"on\") === 0) {\n                    if (!map.has(key)) {\n                        map.set(key, []);\n                    }\n                    if (typeof value === \"function\") {\n                        var _map$get;\n                        (_map$get = map.get(key)) == null ? void 0 : _map$get.push(value);\n                        acc[key] = function() {\n                            var _map$get2;\n                            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                                args[_key] = arguments[_key];\n                            }\n                            (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.forEach((fn)=>fn(...args));\n                        };\n                    }\n                } else {\n                    acc[key] = value;\n                }\n            });\n            return acc;\n        }, {})\n    };\n}\nconst useInteractions = function(propsList) {\n    if (propsList === void 0) {\n        propsList = [];\n    }\n    // The dependencies are a dynamic array, so we can't use the linter's\n    // suggestion to add it to the deps array.\n    const deps = propsList;\n    const getReferenceProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((userProps)=>mergeProps(userProps, propsList, \"reference\"), // eslint-disable-next-line react-hooks/exhaustive-deps\n    deps);\n    const getFloatingProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((userProps)=>mergeProps(userProps, propsList, \"floating\"), // eslint-disable-next-line react-hooks/exhaustive-deps\n    deps);\n    const getItemProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((userProps)=>mergeProps(userProps, propsList, \"item\"), // Granularly check for `item` changes, because the `getItemProps` getter\n    // should be as referentially stable as possible since it may be passed as\n    // a prop to many components. All `item` key values must therefore be\n    // memoized.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    propsList.map((key)=>key == null ? void 0 : key.item));\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            getReferenceProps,\n            getFloatingProps,\n            getItemProps\n        }), [\n        getReferenceProps,\n        getFloatingProps,\n        getItemProps\n    ]);\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0L2Rpc3QvZmxvYXRpbmctdWkucmVhY3QuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUM0QjtBQUNsQjtBQUNMO0FBQ2dCO0FBQ2dFO0FBQ3JFO0FBQ29JO0FBRW5MLElBQUl3QixRQUFRLE9BQU9DLGFBQWEsY0FBY3hCLGtEQUFlQSxHQUFHQyw0Q0FBU0E7QUFFekUsSUFBSXdCLHdCQUF3QjtBQUM1QixJQUFJQyxRQUFRO0FBQ1osTUFBTUMsUUFBUSxJQUFNLGlCQUFpQkQ7QUFDckMsU0FBU0U7SUFDUCxNQUFNLENBQUNDLElBQUlDLE1BQU0sR0FBRy9CLDJDQUFjLENBQUMsSUFBTTBCLHdCQUF3QkUsVUFBVUs7SUFDM0VULE1BQU07UUFDSixJQUFJTSxNQUFNLE1BQU07WUFDZEMsTUFBTUg7UUFDUjtJQUNBLHVEQUF1RDtJQUN6RCxHQUFHLEVBQUU7SUFDTDVCLDRDQUFlLENBQUM7UUFDZCxJQUFJLENBQUMwQix1QkFBdUI7WUFDMUJBLHdCQUF3QjtRQUMxQjtJQUNGLEdBQUcsRUFBRTtJQUNMLE9BQU9JO0FBQ1Q7QUFFQSxnRkFBZ0Y7QUFDaEYsTUFBTUksYUFBYWxDLGtDQUFLLENBQUMsV0FBVyxHQUFFLFFBQVFtQyxRQUFRLEdBQUc7QUFFekQ7Ozs7O0NBS0MsR0FDRCxNQUFNQyxRQUFRRixjQUFjTDtBQUU1QixTQUFTUTtJQUNQLE1BQU1DLE1BQU0sSUFBSUM7SUFDaEIsT0FBTztRQUNMQyxNQUFLQyxLQUFLLEVBQUVDLElBQUk7WUFDZCxJQUFJQztZQUNIQSxDQUFBQSxXQUFXTCxJQUFJTSxHQUFHLENBQUNILE1BQUssS0FBTSxPQUFPLEtBQUssSUFBSUUsU0FBU0UsT0FBTyxDQUFDQyxDQUFBQSxVQUFXQSxRQUFRSjtRQUNyRjtRQUNBSyxJQUFHTixLQUFLLEVBQUVPLFFBQVE7WUFD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cmNlcyI6WyJ3ZWJwYWNrOi8vYWRtaXNzaW9uLXVwbGlmdC8uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvcmVhY3QvZGlzdC9mbG9hdGluZy11aS5yZWFjdC5lc20uanM/ZTc0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QsIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaGlkZU90aGVycyB9IGZyb20gJ2FyaWEtaGlkZGVuJztcbmltcG9ydCB7IHRhYmJhYmxlIH0gZnJvbSAndGFiYmFibGUnO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsLCBmbHVzaFN5bmMgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMsIG9mZnNldCwgZGV0ZWN0T3ZlcmZsb3csIHVzZUZsb2F0aW5nIGFzIHVzZUZsb2F0aW5nJDEgfSBmcm9tICdAZmxvYXRpbmctdWkvcmVhY3QtZG9tJztcbmV4cG9ydCB7IGFycm93IH0gZnJvbSAnQGZsb2F0aW5nLXVpL3JlYWN0LWRvbSc7XG5leHBvcnQgeyBhdXRvUGxhY2VtZW50LCBhdXRvVXBkYXRlLCBjb21wdXRlUG9zaXRpb24sIGRldGVjdE92ZXJmbG93LCBmbGlwLCBnZXRPdmVyZmxvd0FuY2VzdG9ycywgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHBsYXRmb3JtLCBzaGlmdCwgc2l6ZSB9IGZyb20gJ0BmbG9hdGluZy11aS9kb20nO1xuXG52YXIgaW5kZXggPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG5sZXQgc2VydmVySGFuZG9mZkNvbXBsZXRlID0gZmFsc2U7XG5sZXQgY291bnQgPSAwO1xuY29uc3QgZ2VuSWQgPSAoKSA9PiBcImZsb2F0aW5nLXVpLVwiICsgY291bnQrKztcbmZ1bmN0aW9uIHVzZUZsb2F0aW5nSWQoKSB7XG4gIGNvbnN0IFtpZCwgc2V0SWRdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gc2VydmVySGFuZG9mZkNvbXBsZXRlID8gZ2VuSWQoKSA6IHVuZGVmaW5lZCk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoaWQgPT0gbnVsbCkge1xuICAgICAgc2V0SWQoZ2VuSWQoKSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW10pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghc2VydmVySGFuZG9mZkNvbXBsZXRlKSB7XG4gICAgICBzZXJ2ZXJIYW5kb2ZmQ29tcGxldGUgPSB0cnVlO1xuICAgIH1cbiAgfSwgW10pO1xuICByZXR1cm4gaWQ7XG59XG5cbi8vIGB0b1N0cmluZygpYCBwcmV2ZW50cyBidW5kbGVycyBmcm9tIHRyeWluZyB0byBgaW1wb3J0IHsgdXNlSWQgfSBmcm9tICdyZWFjdCdgXG5jb25zdCB1c2VSZWFjdElkID0gUmVhY3RbLyojX19QVVJFX18qLyd1c2VJZCcudG9TdHJpbmcoKV07XG5cbi8qKlxuICogVXNlcyBSZWFjdCAxOCdzIGJ1aWx0LWluIGB1c2VJZCgpYCB3aGVuIGF2YWlsYWJsZSwgb3IgZmFsbHMgYmFjayB0byBhXG4gKiBzbGlnaHRseSBsZXNzIHBlcmZvcm1hbnQgKHJlcXVpcmluZyBhIGRvdWJsZSByZW5kZXIpIGltcGxlbWVudGF0aW9uIGZvclxuICogZWFybGllciBSZWFjdCB2ZXJzaW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VJZFxuICovXG5jb25zdCB1c2VJZCA9IHVzZVJlYWN0SWQgfHwgdXNlRmxvYXRpbmdJZDtcblxuZnVuY3Rpb24gY3JlYXRlUHViU3ViKCkge1xuICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gIHJldHVybiB7XG4gICAgZW1pdChldmVudCwgZGF0YSkge1xuICAgICAgdmFyIF9tYXAkZ2V0O1xuICAgICAgKF9tYXAkZ2V0ID0gbWFwLmdldChldmVudCkpID09IG51bGwgPyB2b2lkIDAgOiBfbWFwJGdldC5mb3JFYWNoKGhhbmRsZXIgPT4gaGFuZGxlcihkYXRhKSk7XG4gICAgfSxcbiAgICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgIG1hcC5zZXQoZXZlbnQsIFsuLi4obWFwLmdldChldmVudCkgfHwgW10pLCBsaXN0ZW5lcl0pO1xuICAgIH0sXG4gICAgb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgbWFwLnNldChldmVudCwgKG1hcC5nZXQoZXZlbnQpIHx8IFtdKS5maWx0ZXIobCA9PiBsICE9PSBsaXN0ZW5lcikpO1xuICAgIH1cbiAgfTtcbn1cblxuY29uc3QgRmxvYXRpbmdOb2RlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgRmxvYXRpbmdUcmVlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgdXNlRmxvYXRpbmdQYXJlbnROb2RlSWQgPSAoKSA9PiB7XG4gIHZhciBfUmVhY3QkdXNlQ29udGV4dDtcbiAgcmV0dXJuICgoX1JlYWN0JHVzZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KEZsb2F0aW5nTm9kZUNvbnRleHQpKSA9PSBudWxsID8gdm9pZCAwIDogX1JlYWN0JHVzZUNvbnRleHQuaWQpIHx8IG51bGw7XG59O1xuY29uc3QgdXNlRmxvYXRpbmdUcmVlID0gKCkgPT4gUmVhY3QudXNlQ29udGV4dChGbG9hdGluZ1RyZWVDb250ZXh0KTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBub2RlIGludG8gdGhlIGZsb2F0aW5nIHRyZWUsIHJldHVybmluZyBpdHMgaWQuXG4gKi9cbmNvbnN0IHVzZUZsb2F0aW5nTm9kZUlkID0gY3VzdG9tUGFyZW50SWQgPT4ge1xuICBjb25zdCBpZCA9IHVzZUlkKCk7XG4gIGNvbnN0IHRyZWUgPSB1c2VGbG9hdGluZ1RyZWUoKTtcbiAgY29uc3QgcmVhY3RQYXJlbnRJZCA9IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkKCk7XG4gIGNvbnN0IHBhcmVudElkID0gY3VzdG9tUGFyZW50SWQgfHwgcmVhY3RQYXJlbnRJZDtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICBpZCxcbiAgICAgIHBhcmVudElkXG4gICAgfTtcbiAgICB0cmVlID09IG51bGwgPyB2b2lkIDAgOiB0cmVlLmFkZE5vZGUobm9kZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRyZWUgPT0gbnVsbCA/IHZvaWQgMCA6IHRyZWUucmVtb3ZlTm9kZShub2RlKTtcbiAgICB9O1xuICB9LCBbdHJlZSwgaWQsIHBhcmVudElkXSk7XG4gIHJldHVybiBpZDtcbn07XG5cbi8qKlxuICogUHJvdmlkZXMgcGFyZW50IG5vZGUgY29udGV4dCBmb3IgbmVzdGVkIGZsb2F0aW5nIGVsZW1lbnRzLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nVHJlZVxuICovXG5jb25zdCBGbG9hdGluZ05vZGUgPSBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlbixcbiAgICBpZFxuICB9ID0gX3JlZjtcbiAgY29uc3QgcGFyZW50SWQgPSB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCgpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvYXRpbmdOb2RlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgICBpZCxcbiAgICAgIHBhcmVudElkXG4gICAgfSksIFtpZCwgcGFyZW50SWRdKVxuICB9LCBjaGlsZHJlbik7XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGNvbnRleHQgZm9yIG5lc3RlZCBmbG9hdGluZyBlbGVtZW50cyB3aGVuIHRoZXkgYXJlIG5vdCBjaGlsZHJlbiBvZlxuICogZWFjaCBvdGhlciBvbiB0aGUgRE9NIChpLmUuIHBvcnRhbGxlZCB0byBhIGNvbW1vbiBub2RlLCByYXRoZXIgdGhhbiB0aGVpclxuICogcmVzcGVjdGl2ZSBwYXJlbnQpLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nVHJlZVxuICovXG5jb25zdCBGbG9hdGluZ1RyZWUgPSBfcmVmMiA9PiB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW5cbiAgfSA9IF9yZWYyO1xuICBjb25zdCBub2Rlc1JlZiA9IFJlYWN0LnVzZVJlZihbXSk7XG4gIGNvbnN0IGFkZE5vZGUgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBub2Rlc1JlZi5jdXJyZW50ID0gWy4uLm5vZGVzUmVmLmN1cnJlbnQsIG5vZGVdO1xuICB9LCBbXSk7XG4gIGNvbnN0IHJlbW92ZU5vZGUgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBub2Rlc1JlZi5jdXJyZW50ID0gbm9kZXNSZWYuY3VycmVudC5maWx0ZXIobiA9PiBuICE9PSBub2RlKTtcbiAgfSwgW10pO1xuICBjb25zdCBldmVudHMgPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBjcmVhdGVQdWJTdWIoKSlbMF07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGbG9hdGluZ1RyZWVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIG5vZGVzUmVmLFxuICAgICAgYWRkTm9kZSxcbiAgICAgIHJlbW92ZU5vZGUsXG4gICAgICBldmVudHNcbiAgICB9KSwgW25vZGVzUmVmLCBhZGROb2RlLCByZW1vdmVOb2RlLCBldmVudHNdKVxuICB9LCBjaGlsZHJlbik7XG59O1xuXG5mdW5jdGlvbiBnZXREb2N1bWVudChub2RlKSB7XG4gIHJldHVybiAobm9kZSA9PSBudWxsID8gdm9pZCAwIDogbm9kZS5vd25lckRvY3VtZW50KSB8fCBkb2N1bWVudDtcbn1cblxuLy8gQXZvaWQgQ2hyb21lIERldlRvb2xzIGJsdWUgd2FybmluZy5cbmZ1bmN0aW9uIGdldFBsYXRmb3JtKCkge1xuICBjb25zdCB1YURhdGEgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcbiAgaWYgKHVhRGF0YSAhPSBudWxsICYmIHVhRGF0YS5wbGF0Zm9ybSkge1xuICAgIHJldHVybiB1YURhdGEucGxhdGZvcm07XG4gIH1cbiAgcmV0dXJuIG5hdmlnYXRvci5wbGF0Zm9ybTtcbn1cbmZ1bmN0aW9uIGdldFVzZXJBZ2VudCgpIHtcbiAgY29uc3QgdWFEYXRhID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG4gIGlmICh1YURhdGEgJiYgQXJyYXkuaXNBcnJheSh1YURhdGEuYnJhbmRzKSkge1xuICAgIHJldHVybiB1YURhdGEuYnJhbmRzLm1hcChfcmVmID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIGJyYW5kLFxuICAgICAgICB2ZXJzaW9uXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIHJldHVybiBicmFuZCArIFwiL1wiICsgdmVyc2lvbjtcbiAgICB9KS5qb2luKCcgJyk7XG4gIH1cbiAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvdyh2YWx1ZSkge1xuICByZXR1cm4gZ2V0RG9jdW1lbnQodmFsdWUpLmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPyB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuRWxlbWVudCA6IGZhbHNlO1xufVxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPyB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuSFRNTEVsZW1lbnQgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzU2hhZG93Um9vdChub2RlKSB7XG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgYFNoYWRvd1Jvb3RgIHN1cHBvcnRcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLlNoYWRvd1Jvb3Q7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdDtcbn1cblxuLy8gTGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL2Fkb2JlL3JlYWN0LXNwZWN0cnVtL2Jsb2IvYjM1ZDVjMDJmZTkwMGJhZGNjZDBjZjFhOGYyM2JiNTkzNDE5ZjIzOC9wYWNrYWdlcy9AcmVhY3QtYXJpYS91dGlscy9zcmMvaXNWaXJ0dWFsRXZlbnQudHNcbmZ1bmN0aW9uIGlzVmlydHVhbENsaWNrKGV2ZW50KSB7XG4gIGlmIChldmVudC5tb3pJbnB1dFNvdXJjZSA9PT0gMCAmJiBldmVudC5pc1RydXN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBhbmRyb2lkUmUgPSAvQW5kcm9pZC9pO1xuICBpZiAoKGFuZHJvaWRSZS50ZXN0KGdldFBsYXRmb3JtKCkpIHx8IGFuZHJvaWRSZS50ZXN0KGdldFVzZXJBZ2VudCgpKSkgJiYgZXZlbnQucG9pbnRlclR5cGUpIHtcbiAgICByZXR1cm4gZXZlbnQudHlwZSA9PT0gJ2NsaWNrJyAmJiBldmVudC5idXR0b25zID09PSAxO1xuICB9XG4gIHJldHVybiBldmVudC5kZXRhaWwgPT09IDAgJiYgIWV2ZW50LnBvaW50ZXJUeXBlO1xufVxuZnVuY3Rpb24gaXNWaXJ0dWFsUG9pbnRlckV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC53aWR0aCA9PT0gMCAmJiBldmVudC5oZWlnaHQgPT09IDAgfHwgZXZlbnQud2lkdGggPT09IDEgJiYgZXZlbnQuaGVpZ2h0ID09PSAxICYmIGV2ZW50LnByZXNzdXJlID09PSAwICYmIGV2ZW50LmRldGFpbCA9PT0gMCAmJiBldmVudC5wb2ludGVyVHlwZSAhPT0gJ21vdXNlJyB8fFxuICAvLyBpT1MgVm9pY2VPdmVyIHJldHVybnMgMC4zMzPigKIgZm9yIHdpZHRoL2hlaWdodC5cbiAgZXZlbnQud2lkdGggPCAxICYmIGV2ZW50LmhlaWdodCA8IDEgJiYgZXZlbnQucHJlc3N1cmUgPT09IDAgJiYgZXZlbnQuZGV0YWlsID09PSAwO1xufVxuZnVuY3Rpb24gaXNTYWZhcmkoKSB7XG4gIC8vIENocm9tZSBEZXZUb29scyBkb2VzIG5vdCBjb21wbGFpbiBhYm91dCBuYXZpZ2F0b3IudmVuZG9yXG4gIHJldHVybiAvYXBwbGUvaS50ZXN0KG5hdmlnYXRvci52ZW5kb3IpO1xufVxuZnVuY3Rpb24gaXNNYWMoKSB7XG4gIHJldHVybiBnZXRQbGF0Zm9ybSgpLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnbWFjJykgJiYgIW5hdmlnYXRvci5tYXhUb3VjaFBvaW50cztcbn1cbmZ1bmN0aW9uIGlzTW91c2VMaWtlUG9pbnRlclR5cGUocG9pbnRlclR5cGUsIHN0cmljdCkge1xuICAvLyBPbiBzb21lIExpbnV4IG1hY2hpbmVzIHdpdGggQ2hyb21pdW0sIG1vdXNlIGlucHV0cyByZXR1cm4gYSBgcG9pbnRlclR5cGVgXG4gIC8vIG9mIFwicGVuXCI6IGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMjAxNVxuICBjb25zdCB2YWx1ZXMgPSBbJ21vdXNlJywgJ3BlbiddO1xuICBpZiAoIXN0cmljdCkge1xuICAgIHZhbHVlcy5wdXNoKCcnLCB1bmRlZmluZWQpO1xuICB9XG4gIHJldHVybiB2YWx1ZXMuaW5jbHVkZXMocG9pbnRlclR5cGUpO1xufVxuXG5mdW5jdGlvbiB1c2VMYXRlc3RSZWYodmFsdWUpIHtcbiAgY29uc3QgcmVmID0gdXNlUmVmKHZhbHVlKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVmO1xufVxuXG5jb25zdCBzYWZlUG9seWdvbklkZW50aWZpZXIgPSAnZGF0YS1mbG9hdGluZy11aS1zYWZlLXBvbHlnb24nO1xuZnVuY3Rpb24gZ2V0RGVsYXkodmFsdWUsIHByb3AsIHBvaW50ZXJUeXBlKSB7XG4gIGlmIChwb2ludGVyVHlwZSAmJiAhaXNNb3VzZUxpa2VQb2ludGVyVHlwZShwb2ludGVyVHlwZSkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IHZhbHVlW3Byb3BdO1xufVxuLyoqXG4gKiBBZGRzIGhvdmVyIGV2ZW50IGxpc3RlbmVycyB0aGF0IGNoYW5nZSB0aGUgb3BlbiBzdGF0ZSwgbGlrZSBDU1MgOmhvdmVyLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUhvdmVyXG4gKi9cbmNvbnN0IHVzZUhvdmVyID0gZnVuY3Rpb24gKGNvbnRleHQsIF90ZW1wKSB7XG4gIGxldCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgZGVsYXkgPSAwLFxuICAgIGhhbmRsZUNsb3NlID0gbnVsbCxcbiAgICBtb3VzZU9ubHkgPSBmYWxzZSxcbiAgICByZXN0TXMgPSAwLFxuICAgIG1vdmUgPSB0cnVlXG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGRhdGFSZWYsXG4gICAgZXZlbnRzLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBkb21SZWZlcmVuY2UsXG4gICAgICBmbG9hdGluZ1xuICAgIH0sXG4gICAgcmVmc1xuICB9ID0gY29udGV4dDtcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBjb25zdCBwYXJlbnRJZCA9IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkKCk7XG4gIGNvbnN0IGhhbmRsZUNsb3NlUmVmID0gdXNlTGF0ZXN0UmVmKGhhbmRsZUNsb3NlKTtcbiAgY29uc3QgZGVsYXlSZWYgPSB1c2VMYXRlc3RSZWYoZGVsYXkpO1xuICBjb25zdCBwb2ludGVyVHlwZVJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCB0aW1lb3V0UmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IGhhbmRsZXJSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3QgcmVzdFRpbWVvdXRSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3QgYmxvY2tNb3VzZU1vdmVSZWYgPSBSZWFjdC51c2VSZWYodHJ1ZSk7XG4gIGNvbnN0IHBlcmZvcm1lZFBvaW50ZXJFdmVudHNNdXRhdGlvblJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHVuYmluZE1vdXNlTW92ZVJlZiA9IFJlYWN0LnVzZVJlZigoKSA9PiB7fSk7XG4gIGNvbnN0IGlzSG92ZXJPcGVuID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHZhciBfZGF0YVJlZiRjdXJyZW50JG9wZW47XG4gICAgY29uc3QgdHlwZSA9IChfZGF0YVJlZiRjdXJyZW50JG9wZW4gPSBkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGFSZWYkY3VycmVudCRvcGVuLnR5cGU7XG4gICAgcmV0dXJuICh0eXBlID09IG51bGwgPyB2b2lkIDAgOiB0eXBlLmluY2x1ZGVzKCdtb3VzZScpKSAmJiB0eXBlICE9PSAnbW91c2Vkb3duJztcbiAgfSwgW2RhdGFSZWZdKTtcblxuICAvLyBXaGVuIGRpc21pc3NpbmcgYmVmb3JlIG9wZW5pbmcsIGNsZWFyIHRoZSBkZWxheSB0aW1lb3V0cyB0byBjYW5jZWwgaXRcbiAgLy8gZnJvbSBzaG93aW5nLlxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkRpc21pc3MoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIGNsZWFyVGltZW91dChyZXN0VGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIGJsb2NrTW91c2VNb3ZlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH1cbiAgICBldmVudHMub24oJ2Rpc21pc3MnLCBvbkRpc21pc3MpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBldmVudHMub2ZmKCdkaXNtaXNzJywgb25EaXNtaXNzKTtcbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgZXZlbnRzXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkIHx8ICFoYW5kbGVDbG9zZVJlZi5jdXJyZW50IHx8ICFvcGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTGVhdmUoKSB7XG4gICAgICBpZiAoaXNIb3Zlck9wZW4oKSkge1xuICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBodG1sID0gZ2V0RG9jdW1lbnQoZmxvYXRpbmcpLmRvY3VtZW50RWxlbWVudDtcbiAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvbkxlYXZlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaHRtbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25MZWF2ZSk7XG4gICAgfTtcbiAgfSwgW2Zsb2F0aW5nLCBvcGVuLCBvbk9wZW5DaGFuZ2UsIGVuYWJsZWQsIGhhbmRsZUNsb3NlUmVmLCBkYXRhUmVmLCBpc0hvdmVyT3Blbl0pO1xuICBjb25zdCBjbG9zZVdpdGhEZWxheSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChydW5FbHNlQnJhbmNoKSB7XG4gICAgaWYgKHJ1bkVsc2VCcmFuY2ggPT09IHZvaWQgMCkge1xuICAgICAgcnVuRWxzZUJyYW5jaCA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGNsb3NlRGVsYXkgPSBnZXREZWxheShkZWxheVJlZi5jdXJyZW50LCAnY2xvc2UnLCBwb2ludGVyVHlwZVJlZi5jdXJyZW50KTtcbiAgICBpZiAoY2xvc2VEZWxheSAmJiAhaGFuZGxlclJlZi5jdXJyZW50KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4gb25PcGVuQ2hhbmdlKGZhbHNlKSwgY2xvc2VEZWxheSk7XG4gICAgfSBlbHNlIGlmIChydW5FbHNlQnJhbmNoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSk7XG4gICAgfVxuICB9LCBbZGVsYXlSZWYsIG9uT3BlbkNoYW5nZV0pO1xuICBjb25zdCBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlciA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICB1bmJpbmRNb3VzZU1vdmVSZWYuY3VycmVudCgpO1xuICAgIGhhbmRsZXJSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgfSwgW10pO1xuICBjb25zdCBjbGVhclBvaW50ZXJFdmVudHMgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKHBlcmZvcm1lZFBvaW50ZXJFdmVudHNNdXRhdGlvblJlZi5jdXJyZW50KSB7XG4gICAgICBjb25zdCBib2R5ID0gZ2V0RG9jdW1lbnQocmVmcy5mbG9hdGluZy5jdXJyZW50KS5ib2R5O1xuICAgICAgYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJyc7XG4gICAgICBib2R5LnJlbW92ZUF0dHJpYnV0ZShzYWZlUG9seWdvbklkZW50aWZpZXIpO1xuICAgICAgcGVyZm9ybWVkUG9pbnRlckV2ZW50c011dGF0aW9uUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9XG4gIH0sIFtyZWZzXSk7XG5cbiAgLy8gUmVnaXN0ZXJpbmcgdGhlIG1vdXNlIGV2ZW50cyBvbiB0aGUgcmVmZXJlbmNlIGRpcmVjdGx5IHRvIGJ5cGFzcyBSZWFjdCdzXG4gIC8vIGRlbGVnYXRpb24gc3lzdGVtLiBJZiB0aGUgY3Vyc29yIHdhcyBvbiBhIGRpc2FibGVkIGVsZW1lbnQgYW5kIHRoZW4gZW50ZXJlZFxuICAvLyB0aGUgcmVmZXJlbmNlIChubyBnYXApLCBgbW91c2VlbnRlcmAgZG9lc24ndCBmaXJlIGluIHRoZSBkZWxlZ2F0aW9uIHN5c3RlbS5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNDbGlja0xpa2VPcGVuRXZlbnQoKSB7XG4gICAgICByZXR1cm4gZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCA/IFsnY2xpY2snLCAnbW91c2Vkb3duJ10uaW5jbHVkZXMoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudC50eXBlKSA6IGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1vdXNlRW50ZXIoZXZlbnQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgYmxvY2tNb3VzZU1vdmVSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgaWYgKG1vdXNlT25seSAmJiAhaXNNb3VzZUxpa2VQb2ludGVyVHlwZShwb2ludGVyVHlwZVJlZi5jdXJyZW50KSB8fCByZXN0TXMgPiAwICYmIGdldERlbGF5KGRlbGF5UmVmLmN1cnJlbnQsICdvcGVuJykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCA9IGV2ZW50O1xuICAgICAgY29uc3Qgb3BlbkRlbGF5ID0gZ2V0RGVsYXkoZGVsYXlSZWYuY3VycmVudCwgJ29wZW4nLCBwb2ludGVyVHlwZVJlZi5jdXJyZW50KTtcbiAgICAgIGlmIChvcGVuRGVsYXkpIHtcbiAgICAgICAgdGltZW91dFJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUpO1xuICAgICAgICB9LCBvcGVuRGVsYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1vdXNlTGVhdmUoZXZlbnQpIHtcbiAgICAgIGlmIChpc0NsaWNrTGlrZU9wZW5FdmVudCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHVuYmluZE1vdXNlTW92ZVJlZi5jdXJyZW50KCk7XG4gICAgICBjb25zdCBkb2MgPSBnZXREb2N1bWVudChmbG9hdGluZyk7XG4gICAgICBjbGVhclRpbWVvdXQocmVzdFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICBpZiAoaGFuZGxlQ2xvc2VSZWYuY3VycmVudCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgICAgaGFuZGxlclJlZi5jdXJyZW50ID0gaGFuZGxlQ2xvc2VSZWYuY3VycmVudCh7XG4gICAgICAgICAgLi4uY29udGV4dCxcbiAgICAgICAgICB0cmVlLFxuICAgICAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgeTogZXZlbnQuY2xpZW50WSxcbiAgICAgICAgICBvbkNsb3NlKCkge1xuICAgICAgICAgICAgY2xlYXJQb2ludGVyRXZlbnRzKCk7XG4gICAgICAgICAgICBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlcigpO1xuICAgICAgICAgICAgY2xvc2VXaXRoRGVsYXkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlclJlZi5jdXJyZW50O1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlcik7XG4gICAgICAgIHVuYmluZE1vdXNlTW92ZVJlZi5jdXJyZW50ID0gKCkgPT4ge1xuICAgICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2xvc2VXaXRoRGVsYXkoKTtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgY2xvc2VzIGFmdGVyIHNjcm9sbGluZyBldmVuIGlmIHRoZSBwb2ludGVyXG4gICAgLy8gZGlkIG5vdCBtb3ZlLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9kaXNjdXNzaW9ucy8xNjkyXG4gICAgZnVuY3Rpb24gb25TY3JvbGxNb3VzZUxlYXZlKGV2ZW50KSB7XG4gICAgICBpZiAoaXNDbGlja0xpa2VPcGVuRXZlbnQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBoYW5kbGVDbG9zZVJlZi5jdXJyZW50ID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVDbG9zZVJlZi5jdXJyZW50KHtcbiAgICAgICAgLi4uY29udGV4dCxcbiAgICAgICAgdHJlZSxcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WSxcbiAgICAgICAgb25DbG9zZSgpIHtcbiAgICAgICAgICBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlcigpO1xuICAgICAgICAgIGNsb3NlV2l0aERlbGF5KCk7XG4gICAgICAgIH1cbiAgICAgIH0pKGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGlzRWxlbWVudChkb21SZWZlcmVuY2UpKSB7XG4gICAgICBjb25zdCByZWYgPSBkb21SZWZlcmVuY2U7XG4gICAgICBvcGVuICYmIHJlZi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25TY3JvbGxNb3VzZUxlYXZlKTtcbiAgICAgIGZsb2F0aW5nID09IG51bGwgPyB2b2lkIDAgOiBmbG9hdGluZy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25TY3JvbGxNb3VzZUxlYXZlKTtcbiAgICAgIG1vdmUgJiYgcmVmLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VFbnRlciwge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlZi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgb25Nb3VzZUVudGVyKTtcbiAgICAgIHJlZi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25Nb3VzZUxlYXZlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIG9wZW4gJiYgcmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvblNjcm9sbE1vdXNlTGVhdmUpO1xuICAgICAgICBmbG9hdGluZyA9PSBudWxsID8gdm9pZCAwIDogZmxvYXRpbmcucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uU2Nyb2xsTW91c2VMZWF2ZSk7XG4gICAgICAgIG1vdmUgJiYgcmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VFbnRlcik7XG4gICAgICAgIHJlZi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgb25Nb3VzZUVudGVyKTtcbiAgICAgICAgcmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvbk1vdXNlTGVhdmUpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtkb21SZWZlcmVuY2UsIGZsb2F0aW5nLCBlbmFibGVkLCBjb250ZXh0LCBtb3VzZU9ubHksIHJlc3RNcywgbW92ZSwgY2xvc2VXaXRoRGVsYXksIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyLCBjbGVhclBvaW50ZXJFdmVudHMsIG9uT3BlbkNoYW5nZSwgb3BlbiwgdHJlZSwgZGVsYXlSZWYsIGhhbmRsZUNsb3NlUmVmLCBkYXRhUmVmXSk7XG5cbiAgLy8gQmxvY2sgcG9pbnRlci1ldmVudHMgb2YgZXZlcnkgZWxlbWVudCBvdGhlciB0aGFuIHRoZSByZWZlcmVuY2UgYW5kIGZsb2F0aW5nXG4gIC8vIHdoaWxlIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzIG9wZW4gYW5kIGhhcyBhIGBoYW5kbGVDbG9zZWAgaGFuZGxlci4gQWxzb1xuICAvLyBoYW5kbGVzIG5lc3RlZCBmbG9hdGluZyBlbGVtZW50cy5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8xNzIyXG4gIGluZGV4KCgpID0+IHtcbiAgICB2YXIgX2hhbmRsZUNsb3NlUmVmJGN1cnJlO1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3BlbiAmJiAoX2hhbmRsZUNsb3NlUmVmJGN1cnJlID0gaGFuZGxlQ2xvc2VSZWYuY3VycmVudCkgIT0gbnVsbCAmJiBfaGFuZGxlQ2xvc2VSZWYkY3VycmUuX19vcHRpb25zLmJsb2NrUG9pbnRlckV2ZW50cyAmJiBpc0hvdmVyT3BlbigpKSB7XG4gICAgICBjb25zdCBib2R5ID0gZ2V0RG9jdW1lbnQoZmxvYXRpbmcpLmJvZHk7XG4gICAgICBib2R5LnNldEF0dHJpYnV0ZShzYWZlUG9seWdvbklkZW50aWZpZXIsICcnKTtcbiAgICAgIGJvZHkuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgIHBlcmZvcm1lZFBvaW50ZXJFdmVudHNNdXRhdGlvblJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIGlmIChpc0VsZW1lbnQoZG9tUmVmZXJlbmNlKSAmJiBmbG9hdGluZykge1xuICAgICAgICB2YXIgX3RyZWUkbm9kZXNSZWYkY3VycmVuLCBfdHJlZSRub2Rlc1JlZiRjdXJyZW4yO1xuICAgICAgICBjb25zdCByZWYgPSBkb21SZWZlcmVuY2U7XG4gICAgICAgIGNvbnN0IHBhcmVudEZsb2F0aW5nID0gdHJlZSA9PSBudWxsID8gdm9pZCAwIDogKF90cmVlJG5vZGVzUmVmJGN1cnJlbiA9IHRyZWUubm9kZXNSZWYuY3VycmVudC5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gcGFyZW50SWQpKSA9PSBudWxsID8gdm9pZCAwIDogKF90cmVlJG5vZGVzUmVmJGN1cnJlbjIgPSBfdHJlZSRub2Rlc1JlZiRjdXJyZW4uY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90cmVlJG5vZGVzUmVmJGN1cnJlbjIuZWxlbWVudHMuZmxvYXRpbmc7XG4gICAgICAgIGlmIChwYXJlbnRGbG9hdGluZykge1xuICAgICAgICAgIHBhcmVudEZsb2F0aW5nLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICAgICAgfVxuICAgICAgICByZWYuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcbiAgICAgICAgZmxvYXRpbmcuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICByZWYuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuICAgICAgICAgIGZsb2F0aW5nLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBwYXJlbnRJZCwgZmxvYXRpbmcsIGRvbVJlZmVyZW5jZSwgdHJlZSwgaGFuZGxlQ2xvc2VSZWYsIGRhdGFSZWYsIGlzSG92ZXJPcGVuXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIW9wZW4pIHtcbiAgICAgIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlcigpO1xuICAgICAgY2xlYXJQb2ludGVyRXZlbnRzKCk7XG4gICAgfVxuICB9LCBbb3BlbiwgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIsIGNsZWFyUG9pbnRlckV2ZW50c10pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlcigpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICBjbGVhclRpbWVvdXQocmVzdFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICBjbGVhclBvaW50ZXJFdmVudHMoKTtcbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIsIGNsZWFyUG9pbnRlckV2ZW50c10pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFBvaW50ZXJSZWYoZXZlbnQpIHtcbiAgICAgIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPSBldmVudC5wb2ludGVyVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICBvblBvaW50ZXJEb3duOiBzZXRQb2ludGVyUmVmLFxuICAgICAgICBvblBvaW50ZXJFbnRlcjogc2V0UG9pbnRlclJlZixcbiAgICAgICAgb25Nb3VzZU1vdmUoKSB7XG4gICAgICAgICAgaWYgKG9wZW4gfHwgcmVzdE1zID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsZWFyVGltZW91dChyZXN0VGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgICAgICByZXN0VGltZW91dFJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWJsb2NrTW91c2VNb3ZlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlc3RNcyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmbG9hdGluZzoge1xuICAgICAgICBvbk1vdXNlRW50ZXIoKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VMZWF2ZSgpIHtcbiAgICAgICAgICBldmVudHMuZW1pdCgnZGlzbWlzcycsIHtcbiAgICAgICAgICAgIHR5cGU6ICdtb3VzZUxlYXZlJyxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgcmV0dXJuRm9jdXM6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY2xvc2VXaXRoRGVsYXkoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2V2ZW50cywgZW5hYmxlZCwgcmVzdE1zLCBvcGVuLCBvbk9wZW5DaGFuZ2UsIGNsb3NlV2l0aERlbGF5XSk7XG59O1xuXG5jb25zdCBGbG9hdGluZ0RlbGF5R3JvdXBDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBkZWxheTogMCxcbiAgaW5pdGlhbERlbGF5OiAwLFxuICB0aW1lb3V0TXM6IDAsXG4gIGN1cnJlbnRJZDogbnVsbCxcbiAgc2V0Q3VycmVudElkOiAoKSA9PiB7fSxcbiAgc2V0U3RhdGU6ICgpID0+IHt9LFxuICBpc0luc3RhbnRQaGFzZTogZmFsc2Vcbn0pO1xuY29uc3QgdXNlRGVsYXlHcm91cENvbnRleHQgPSAoKSA9PiBSZWFjdC51c2VDb250ZXh0KEZsb2F0aW5nRGVsYXlHcm91cENvbnRleHQpO1xuXG4vKipcbiAqIFByb3ZpZGVzIGNvbnRleHQgZm9yIGEgZ3JvdXAgb2YgZmxvYXRpbmcgZWxlbWVudHMgdGhhdCBzaG91bGQgc2hhcmUgYVxuICogYGRlbGF5YC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ0RlbGF5R3JvdXBcbiAqL1xuY29uc3QgRmxvYXRpbmdEZWxheUdyb3VwID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW4sXG4gICAgZGVsYXksXG4gICAgdGltZW91dE1zID0gMFxuICB9ID0gX3JlZjtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VSZWR1Y2VyKChwcmV2LCBuZXh0KSA9PiAoe1xuICAgIC4uLnByZXYsXG4gICAgLi4ubmV4dFxuICB9KSwge1xuICAgIGRlbGF5LFxuICAgIHRpbWVvdXRNcyxcbiAgICBpbml0aWFsRGVsYXk6IGRlbGF5LFxuICAgIGN1cnJlbnRJZDogbnVsbCxcbiAgICBpc0luc3RhbnRQaGFzZTogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IGluaXRpYWxDdXJyZW50SWRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHNldEN1cnJlbnRJZCA9IFJlYWN0LnVzZUNhbGxiYWNrKGN1cnJlbnRJZCA9PiB7XG4gICAgc2V0U3RhdGUoe1xuICAgICAgY3VycmVudElkXG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChzdGF0ZS5jdXJyZW50SWQpIHtcbiAgICAgIGlmIChpbml0aWFsQ3VycmVudElkUmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgaW5pdGlhbEN1cnJlbnRJZFJlZi5jdXJyZW50ID0gc3RhdGUuY3VycmVudElkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGlzSW5zdGFudFBoYXNlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGlzSW5zdGFudFBoYXNlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBpbml0aWFsQ3VycmVudElkUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgW3N0YXRlLmN1cnJlbnRJZF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvYXRpbmdEZWxheUdyb3VwQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHNldFN0YXRlLFxuICAgICAgc2V0Q3VycmVudElkXG4gICAgfSksIFtzdGF0ZSwgc2V0U3RhdGUsIHNldEN1cnJlbnRJZF0pXG4gIH0sIGNoaWxkcmVuKTtcbn07XG5jb25zdCB1c2VEZWxheUdyb3VwID0gKF9yZWYyLCBfcmVmMykgPT4ge1xuICBsZXQge1xuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlXG4gIH0gPSBfcmVmMjtcbiAgbGV0IHtcbiAgICBpZFxuICB9ID0gX3JlZjM7XG4gIGNvbnN0IHtcbiAgICBjdXJyZW50SWQsXG4gICAgc2V0Q3VycmVudElkLFxuICAgIGluaXRpYWxEZWxheSxcbiAgICBzZXRTdGF0ZSxcbiAgICB0aW1lb3V0TXNcbiAgfSA9IHVzZURlbGF5R3JvdXBDb250ZXh0KCk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGN1cnJlbnRJZCkge1xuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBkZWxheToge1xuICAgICAgICAgIG9wZW46IDEsXG4gICAgICAgICAgY2xvc2U6IGdldERlbGF5KGluaXRpYWxEZWxheSwgJ2Nsb3NlJylcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoY3VycmVudElkICE9PSBpZCkge1xuICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2lkLCBvbk9wZW5DaGFuZ2UsIHNldFN0YXRlLCBjdXJyZW50SWQsIGluaXRpYWxEZWxheV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIHVuc2V0KCkge1xuICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlKTtcbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgZGVsYXk6IGluaXRpYWxEZWxheSxcbiAgICAgICAgY3VycmVudElkOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFvcGVuICYmIGN1cnJlbnRJZCA9PT0gaWQpIHtcbiAgICAgIGlmICh0aW1lb3V0TXMpIHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KHVuc2V0LCB0aW1lb3V0TXMpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVuc2V0KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbb3Blbiwgc2V0U3RhdGUsIGN1cnJlbnRJZCwgaWQsIG9uT3BlbkNoYW5nZSwgaW5pdGlhbERlbGF5LCB0aW1lb3V0TXNdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAob3Blbikge1xuICAgICAgc2V0Q3VycmVudElkKGlkKTtcbiAgICB9XG4gIH0sIFtvcGVuLCBzZXRDdXJyZW50SWQsIGlkXSk7XG59O1xuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIEZpbmQgdGhlIHJlYWwgYWN0aXZlIGVsZW1lbnQuIFRyYXZlcnNlcyBpbnRvIHNoYWRvd1Jvb3RzLlxuICovXG5mdW5jdGlvbiBhY3RpdmVFbGVtZW50JDEoZG9jKSB7XG4gIGxldCBhY3RpdmVFbGVtZW50ID0gZG9jLmFjdGl2ZUVsZW1lbnQ7XG4gIHdoaWxlICgoKF9hY3RpdmVFbGVtZW50ID0gYWN0aXZlRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IChfYWN0aXZlRWxlbWVudCRzaGFkb3cgPSBfYWN0aXZlRWxlbWVudC5zaGFkb3dSb290KSA9PSBudWxsID8gdm9pZCAwIDogX2FjdGl2ZUVsZW1lbnQkc2hhZG93LmFjdGl2ZUVsZW1lbnQpICE9IG51bGwpIHtcbiAgICB2YXIgX2FjdGl2ZUVsZW1lbnQsIF9hY3RpdmVFbGVtZW50JHNoYWRvdztcbiAgICBhY3RpdmVFbGVtZW50ID0gYWN0aXZlRWxlbWVudC5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGFjdGl2ZUVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgaWYgKCFwYXJlbnQgfHwgIWNoaWxkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHJvb3ROb2RlID0gY2hpbGQuZ2V0Um9vdE5vZGUgJiYgY2hpbGQuZ2V0Um9vdE5vZGUoKTtcblxuICAvLyBGaXJzdCwgYXR0ZW1wdCB3aXRoIGZhc3RlciBuYXRpdmUgbWV0aG9kXG4gIGlmIChwYXJlbnQuY29udGFpbnMoY2hpbGQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcbiAgZWxzZSBpZiAocm9vdE5vZGUgJiYgaXNTaGFkb3dSb290KHJvb3ROb2RlKSkge1xuICAgIGxldCBuZXh0ID0gY2hpbGQ7XG4gICAgZG8ge1xuICAgICAgaWYgKG5leHQgJiYgcGFyZW50ID09PSBuZXh0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XG4gICAgfSB3aGlsZSAobmV4dCk7XG4gIH1cblxuICAvLyBHaXZlIHVwLCB0aGUgcmVzdWx0IGlzIGZhbHNlXG4gIHJldHVybiBmYWxzZTtcbn1cblxubGV0IHJhZklkID0gMDtcbmZ1bmN0aW9uIGVucXVldWVGb2N1cyhlbCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBwcmV2ZW50U2Nyb2xsID0gZmFsc2UsXG4gICAgY2FuY2VsUHJldmlvdXMgPSB0cnVlLFxuICAgIHN5bmMgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY2FuY2VsUHJldmlvdXMgJiYgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpO1xuICBjb25zdCBleGVjID0gKCkgPT4gZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGVsLmZvY3VzKHtcbiAgICBwcmV2ZW50U2Nyb2xsXG4gIH0pO1xuICBpZiAoc3luYykge1xuICAgIGV4ZWMoKTtcbiAgfSBlbHNlIHtcbiAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShleGVjKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbmNlc3RvcnMobm9kZXMsIGlkKSB7XG4gIHZhciBfbm9kZXMkZmluZDtcbiAgbGV0IGFsbEFuY2VzdG9ycyA9IFtdO1xuICBsZXQgY3VycmVudFBhcmVudElkID0gKF9ub2RlcyRmaW5kID0gbm9kZXMuZmluZChub2RlID0+IG5vZGUuaWQgPT09IGlkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlcyRmaW5kLnBhcmVudElkO1xuICB3aGlsZSAoY3VycmVudFBhcmVudElkKSB7XG4gICAgY29uc3QgY3VycmVudE5vZGUgPSBub2Rlcy5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gY3VycmVudFBhcmVudElkKTtcbiAgICBjdXJyZW50UGFyZW50SWQgPSBjdXJyZW50Tm9kZSA9PSBudWxsID8gdm9pZCAwIDogY3VycmVudE5vZGUucGFyZW50SWQ7XG4gICAgaWYgKGN1cnJlbnROb2RlKSB7XG4gICAgICBhbGxBbmNlc3RvcnMgPSBhbGxBbmNlc3RvcnMuY29uY2F0KGN1cnJlbnROb2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFsbEFuY2VzdG9ycztcbn1cblxuZnVuY3Rpb24gZ2V0Q2hpbGRyZW4obm9kZXMsIGlkKSB7XG4gIGxldCBhbGxDaGlsZHJlbiA9IG5vZGVzLmZpbHRlcihub2RlID0+IHtcbiAgICB2YXIgX25vZGUkY29udGV4dDtcbiAgICByZXR1cm4gbm9kZS5wYXJlbnRJZCA9PT0gaWQgJiYgKChfbm9kZSRjb250ZXh0ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dC5vcGVuKTtcbiAgfSkgfHwgW107XG4gIGxldCBjdXJyZW50Q2hpbGRyZW4gPSBhbGxDaGlsZHJlbjtcbiAgd2hpbGUgKGN1cnJlbnRDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBjdXJyZW50Q2hpbGRyZW4gPSBub2Rlcy5maWx0ZXIobm9kZSA9PiB7XG4gICAgICB2YXIgX2N1cnJlbnRDaGlsZHJlbjtcbiAgICAgIHJldHVybiAoX2N1cnJlbnRDaGlsZHJlbiA9IGN1cnJlbnRDaGlsZHJlbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jdXJyZW50Q2hpbGRyZW4uc29tZShuID0+IHtcbiAgICAgICAgdmFyIF9ub2RlJGNvbnRleHQyO1xuICAgICAgICByZXR1cm4gbm9kZS5wYXJlbnRJZCA9PT0gbi5pZCAmJiAoKF9ub2RlJGNvbnRleHQyID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dDIub3Blbik7XG4gICAgICB9KTtcbiAgICB9KSB8fCBbXTtcbiAgICBhbGxDaGlsZHJlbiA9IGFsbENoaWxkcmVuLmNvbmNhdChjdXJyZW50Q2hpbGRyZW4pO1xuICB9XG4gIHJldHVybiBhbGxDaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0KGV2ZW50KSB7XG4gIGlmICgnY29tcG9zZWRQYXRoJyBpbiBldmVudCkge1xuICAgIHJldHVybiBldmVudC5jb21wb3NlZFBhdGgoKVswXTtcbiAgfVxuXG4gIC8vIFRTIHRoaW5rcyBgZXZlbnRgIGlzIG9mIHR5cGUgbmV2ZXIgYXMgaXQgYXNzdW1lcyBhbGwgYnJvd3NlcnMgc3VwcG9ydFxuICAvLyBgY29tcG9zZWRQYXRoKClgLCBidXQgYnJvd3NlcnMgd2l0aG91dCBzaGFkb3cgRE9NIGRvbid0LlxuICByZXR1cm4gZXZlbnQudGFyZ2V0O1xufVxuXG5jb25zdCBUWVBFQUJMRV9TRUxFQ1RPUiA9IFwiaW5wdXQ6bm90KFt0eXBlPSdoaWRkZW4nXSk6bm90KFtkaXNhYmxlZF0pLFwiICsgXCJbY29udGVudGVkaXRhYmxlXTpub3QoW2NvbnRlbnRlZGl0YWJsZT0nZmFsc2UnXSksdGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pXCI7XG5mdW5jdGlvbiBpc1R5cGVhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpICYmIGVsZW1lbnQubWF0Y2hlcyhUWVBFQUJMRV9TRUxFQ1RPUik7XG59XG5cbmZ1bmN0aW9uIHN0b3BFdmVudChldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn1cblxuY29uc3QgZ2V0VGFiYmFibGVPcHRpb25zID0gKCkgPT4gKHtcbiAgZ2V0U2hhZG93Um9vdDogdHJ1ZSxcbiAgZGlzcGxheUNoZWNrOlxuICAvLyBKU0RPTSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBgdGFiYmFibGVgIGxpYnJhcnkuIFRvIHNvbHZlIHRoaXMgd2UgY2FuXG4gIC8vIGNoZWNrIGlmIGBSZXNpemVPYnNlcnZlcmAgaXMgYSByZWFsIGZ1bmN0aW9uIChub3QgcG9seWZpbGxlZCksIHdoaWNoXG4gIC8vIGRldGVybWluZXMgaWYgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgaXMgSlNET00tbGlrZS5cbiAgdHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSAnZnVuY3Rpb24nICYmIFJlc2l6ZU9ic2VydmVyLnRvU3RyaW5nKCkuaW5jbHVkZXMoJ1tuYXRpdmUgY29kZV0nKSA/ICdmdWxsJyA6ICdub25lJ1xufSk7XG5mdW5jdGlvbiBnZXRUYWJiYWJsZUluKGNvbnRhaW5lciwgZGlyZWN0aW9uKSB7XG4gIGNvbnN0IGFsbFRhYmJhYmxlID0gdGFiYmFibGUoY29udGFpbmVyLCBnZXRUYWJiYWJsZU9wdGlvbnMoKSk7XG4gIGlmIChkaXJlY3Rpb24gPT09ICdwcmV2Jykge1xuICAgIGFsbFRhYmJhYmxlLnJldmVyc2UoKTtcbiAgfVxuICBjb25zdCBhY3RpdmVJbmRleCA9IGFsbFRhYmJhYmxlLmluZGV4T2YoYWN0aXZlRWxlbWVudCQxKGdldERvY3VtZW50KGNvbnRhaW5lcikpKTtcbiAgY29uc3QgbmV4dFRhYmJhYmxlRWxlbWVudHMgPSBhbGxUYWJiYWJsZS5zbGljZShhY3RpdmVJbmRleCArIDEpO1xuICByZXR1cm4gbmV4dFRhYmJhYmxlRWxlbWVudHNbMF07XG59XG5mdW5jdGlvbiBnZXROZXh0VGFiYmFibGUoKSB7XG4gIHJldHVybiBnZXRUYWJiYWJsZUluKGRvY3VtZW50LmJvZHksICduZXh0Jyk7XG59XG5mdW5jdGlvbiBnZXRQcmV2aW91c1RhYmJhYmxlKCkge1xuICByZXR1cm4gZ2V0VGFiYmFibGVJbihkb2N1bWVudC5ib2R5LCAncHJldicpO1xufVxuZnVuY3Rpb24gaXNPdXRzaWRlRXZlbnQoZXZlbnQsIGNvbnRhaW5lcikge1xuICBjb25zdCBjb250YWluZXJFbGVtZW50ID0gY29udGFpbmVyIHx8IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICByZXR1cm4gIXJlbGF0ZWRUYXJnZXQgfHwgIWNvbnRhaW5zKGNvbnRhaW5lckVsZW1lbnQsIHJlbGF0ZWRUYXJnZXQpO1xufVxuZnVuY3Rpb24gZGlzYWJsZUZvY3VzSW5zaWRlKGNvbnRhaW5lcikge1xuICBjb25zdCB0YWJiYWJsZUVsZW1lbnRzID0gdGFiYmFibGUoY29udGFpbmVyLCBnZXRUYWJiYWJsZU9wdGlvbnMoKSk7XG4gIHRhYmJhYmxlRWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICBlbGVtZW50LmRhdGFzZXQudGFiaW5kZXggPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSB8fCAnJztcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBlbmFibGVGb2N1c0luc2lkZShjb250YWluZXIpIHtcbiAgY29uc3QgZWxlbWVudHMgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtdGFiaW5kZXhdJyk7XG4gIGVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgY29uc3QgdGFiaW5kZXggPSBlbGVtZW50LmRhdGFzZXQudGFiaW5kZXg7XG4gICAgZGVsZXRlIGVsZW1lbnQuZGF0YXNldC50YWJpbmRleDtcbiAgICBpZiAodGFiaW5kZXgpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIHRhYmluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gYHRvU3RyaW5nKClgIHByZXZlbnRzIGJ1bmRsZXJzIGZyb20gdHJ5aW5nIHRvIGBpbXBvcnQgeyB1c2VJbnNlcnRpb25FZmZlY3QgfSBmcm9tICdyZWFjdCdgXG5jb25zdCB1c2VJbnNlcnRpb25FZmZlY3QgPSBSZWFjdFsvKiNfX1BVUkVfXyovJ3VzZUluc2VydGlvbkVmZmVjdCcudG9TdHJpbmcoKV07XG5jb25zdCB1c2VTYWZlSW5zZXJ0aW9uRWZmZWN0ID0gdXNlSW5zZXJ0aW9uRWZmZWN0IHx8IChmbiA9PiBmbigpKTtcbmZ1bmN0aW9uIHVzZUV2ZW50KGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZigoKSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2FsbCBhbiBldmVudCBoYW5kbGVyIHdoaWxlIHJlbmRlcmluZy4nKTtcbiAgICB9XG4gIH0pO1xuICB1c2VTYWZlSW5zZXJ0aW9uRWZmZWN0KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IGNhbGxiYWNrO1xuICB9KTtcbiAgcmV0dXJuIFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIHJldHVybiByZWYuY3VycmVudCA9PSBudWxsID8gdm9pZCAwIDogcmVmLmN1cnJlbnQoLi4uYXJncyk7XG4gIH0sIFtdKTtcbn1cblxuLy8gU2VlIERpZWdvIEhheidzIFNhbmRib3ggZm9yIG1ha2luZyB0aGlzIGxvZ2ljIHdvcmsgd2VsbCBvbiBTYWZhcmkvaU9TOlxuLy8gaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3RhYmJhYmxlLXBvcnRhbC1mNHRuZz9maWxlPS9zcmMvRm9jdXNUcmFwLnRzeFxuXG5jb25zdCBISURERU5fU1RZTEVTID0ge1xuICBib3JkZXI6IDAsXG4gIGNsaXA6ICdyZWN0KDAgMCAwIDApJyxcbiAgaGVpZ2h0OiAnMXB4JyxcbiAgbWFyZ2luOiAnLTFweCcsXG4gIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgcGFkZGluZzogMCxcbiAgcG9zaXRpb246ICdmaXhlZCcsXG4gIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICB3aWR0aDogJzFweCcsXG4gIHRvcDogMCxcbiAgbGVmdDogMFxufTtcbmxldCBhY3RpdmVFbGVtZW50O1xubGV0IHRpbWVvdXRJZDtcbmZ1bmN0aW9uIHNldEFjdGl2ZUVsZW1lbnRPblRhYihldmVudCkge1xuICBpZiAoZXZlbnQua2V5ID09PSAnVGFiJykge1xuICAgIGFjdGl2ZUVsZW1lbnQgPSBldmVudC50YXJnZXQ7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVGFiRm9jdXMoZXZlbnQpIHtcbiAgY29uc3QgcmVzdWx0ID0gYWN0aXZlRWxlbWVudCA9PT0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgYWN0aXZlRWxlbWVudCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgRm9jdXNHdWFyZCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIEZvY3VzR3VhcmQocHJvcHMsIHJlZikge1xuICBjb25zdCBvbkZvY3VzID0gdXNlRXZlbnQocHJvcHMub25Gb2N1cyk7XG4gIGNvbnN0IFtyb2xlLCBzZXRSb2xlXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoaXNTYWZhcmkoKSkge1xuICAgICAgLy8gVW5saWtlIG90aGVyIHNjcmVlbiByZWFkZXJzIHN1Y2ggYXMgTlZEQSBhbmQgSkFXUywgdGhlIHZpcnR1YWwgY3Vyc29yXG4gICAgICAvLyBvbiBWb2ljZU92ZXIgZG9lcyB0cmlnZ2VyIHRoZSBvbkZvY3VzIGV2ZW50LCBzbyB3ZSBjYW4gdXNlIHRoZSBmb2N1c1xuICAgICAgLy8gdHJhcCBlbGVtZW50LiBPbiBTYWZhcmksIG9ubHkgYnV0dG9ucyB0cmlnZ2VyIHRoZSBvbkZvY3VzIGV2ZW50LlxuICAgICAgLy8gTkI6IFwiZ3JvdXBcIiByb2xlIGluIHRoZSBTYW5kYm94IG5vIGxvbmdlciBhcHBlYXJzIHRvIHdvcmssIG11c3QgYmUgYVxuICAgICAgLy8gYnV0dG9uIHJvbGUuXG4gICAgICBzZXRSb2xlKCdidXR0b24nKTtcbiAgICB9XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHNldEFjdGl2ZUVsZW1lbnRPblRhYik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBzZXRBY3RpdmVFbGVtZW50T25UYWIpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICByZWY6IHJlZixcbiAgICB0YWJJbmRleDogMFxuICAgIC8vIFJvbGUgaXMgb25seSBmb3IgVm9pY2VPdmVyXG4gICAgLFxuICAgIHJvbGU6IHJvbGUsXG4gICAgXCJhcmlhLWhpZGRlblwiOiByb2xlID8gdW5kZWZpbmVkIDogdHJ1ZSxcbiAgICBcImRhdGEtZmxvYXRpbmctdWktZm9jdXMtZ3VhcmRcIjogXCJcIixcbiAgICBzdHlsZTogSElEREVOX1NUWUxFUyxcbiAgICBvbkZvY3VzOiBldmVudCA9PiB7XG4gICAgICBpZiAoaXNTYWZhcmkoKSAmJiBpc01hYygpICYmICFpc1RhYkZvY3VzKGV2ZW50KSkge1xuICAgICAgICAvLyBPbiBtYWNPUyB3ZSBuZWVkIHRvIHdhaXQgYSBsaXR0bGUgYml0IGJlZm9yZSBtb3ZpbmdcbiAgICAgICAgLy8gZm9jdXMgYWdhaW4uXG4gICAgICAgIGV2ZW50LnBlcnNpc3QoKTtcbiAgICAgICAgdGltZW91dElkID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIG9uRm9jdXMoZXZlbnQpO1xuICAgICAgICB9LCA1MCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbkZvY3VzKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pKTtcbn0pO1xuXG5jb25zdCBQb3J0YWxDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCB1c2VGbG9hdGluZ1BvcnRhbE5vZGUgPSBmdW5jdGlvbiAoX3RlbXApIHtcbiAgbGV0IHtcbiAgICBpZCxcbiAgICBlbmFibGVkID0gdHJ1ZVxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGNvbnN0IFtwb3J0YWxFbCwgc2V0UG9ydGFsRWxdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHVuaXF1ZUlkID0gdXNlSWQoKTtcbiAgY29uc3QgcG9ydGFsQ29udGV4dCA9IHVzZVBvcnRhbENvbnRleHQoKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByb290Tm9kZSA9IGlkID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIDogbnVsbDtcbiAgICBpZiAocm9vdE5vZGUpIHtcbiAgICAgIHJvb3ROb2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1mbG9hdGluZy11aS1wb3J0YWwnLCAnJyk7XG4gICAgICBzZXRQb3J0YWxFbChyb290Tm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5ld1BvcnRhbEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBpZiAoaWQgIT09ICcnKSB7XG4gICAgICAgIG5ld1BvcnRhbEVsLmlkID0gaWQgfHwgdW5pcXVlSWQ7XG4gICAgICB9XG4gICAgICBuZXdQb3J0YWxFbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtZmxvYXRpbmctdWktcG9ydGFsJywgJycpO1xuICAgICAgc2V0UG9ydGFsRWwobmV3UG9ydGFsRWwpO1xuICAgICAgY29uc3QgY29udGFpbmVyID0gKHBvcnRhbENvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSkgfHwgZG9jdW1lbnQuYm9keTtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChuZXdQb3J0YWxFbCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQobmV3UG9ydGFsRWwpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtpZCwgcG9ydGFsQ29udGV4dCwgdW5pcXVlSWQsIGVuYWJsZWRdKTtcbiAgcmV0dXJuIHBvcnRhbEVsO1xufTtcblxuLyoqXG4gKiBQb3J0YWxzIHlvdXIgZmxvYXRpbmcgZWxlbWVudCBvdXRzaWRlIG9mIHRoZSBtYWluIGFwcCBub2RlLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nUG9ydGFsXG4gKi9cbmNvbnN0IEZsb2F0aW5nUG9ydGFsID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW4sXG4gICAgaWQsXG4gICAgcm9vdCA9IG51bGwsXG4gICAgcHJlc2VydmVUYWJPcmRlciA9IHRydWVcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHBvcnRhbE5vZGUgPSB1c2VGbG9hdGluZ1BvcnRhbE5vZGUoe1xuICAgIGlkLFxuICAgIGVuYWJsZWQ6ICFyb290XG4gIH0pO1xuICBjb25zdCBbZm9jdXNNYW5hZ2VyU3RhdGUsIHNldEZvY3VzTWFuYWdlclN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBiZWZvcmVPdXRzaWRlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBhZnRlck91dHNpZGVSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGJlZm9yZUluc2lkZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgYWZ0ZXJJbnNpZGVSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHNob3VsZFJlbmRlckd1YXJkcyA9XG4gIC8vIFRoZSBGb2N1c01hbmFnZXIgYW5kIHRoZXJlZm9yZSBmbG9hdGluZyBlbGVtZW50IGFyZSBjdXJyZW50bHkgb3Blbi9cbiAgLy8gcmVuZGVyZWQuXG4gICEhZm9jdXNNYW5hZ2VyU3RhdGUgJiZcbiAgLy8gR3VhcmRzIGFyZSBvbmx5IGZvciBub24tbW9kYWwgZm9jdXMgbWFuYWdlbWVudC5cbiAgIWZvY3VzTWFuYWdlclN0YXRlLm1vZGFsICYmICEhKHJvb3QgfHwgcG9ydGFsTm9kZSkgJiYgcHJlc2VydmVUYWJPcmRlcjtcblxuICAvLyBodHRwczovL2NvZGVzYW5kYm94LmlvL3MvdGFiYmFibGUtcG9ydGFsLWY0dG5nP2ZpbGU9L3NyYy9UYWJiYWJsZVBvcnRhbC50c3hcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXBvcnRhbE5vZGUgfHwgIXByZXNlcnZlVGFiT3JkZXIgfHwgZm9jdXNNYW5hZ2VyU3RhdGUgIT0gbnVsbCAmJiBmb2N1c01hbmFnZXJTdGF0ZS5tb2RhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSBlbGVtZW50cyBpbnNpZGUgdGhlIHBvcnRhbCBlbGVtZW50IGFyZSB0YWJiYWJsZSBvbmx5IHdoZW4gdGhlXG4gICAgLy8gcG9ydGFsIGhhcyBhbHJlYWR5IGJlZW4gZm9jdXNlZCwgZWl0aGVyIGJ5IHRhYmJpbmcgaW50byBhIGZvY3VzIHRyYXBcbiAgICAvLyBlbGVtZW50IG91dHNpZGUgb3IgdXNpbmcgdGhlIG1vdXNlLlxuICAgIGZ1bmN0aW9uIG9uRm9jdXMoZXZlbnQpIHtcbiAgICAgIGlmIChwb3J0YWxOb2RlICYmIGlzT3V0c2lkZUV2ZW50KGV2ZW50KSkge1xuICAgICAgICBjb25zdCBmb2N1c2luZyA9IGV2ZW50LnR5cGUgPT09ICdmb2N1c2luJztcbiAgICAgICAgY29uc3QgbWFuYWdlRm9jdXMgPSBmb2N1c2luZyA/IGVuYWJsZUZvY3VzSW5zaWRlIDogZGlzYWJsZUZvY3VzSW5zaWRlO1xuICAgICAgICBtYW5hZ2VGb2N1cyhwb3J0YWxOb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTGlzdGVuIHRvIHRoZSBldmVudCBvbiB0aGUgY2FwdHVyZSBwaGFzZSBzbyB0aGV5IHJ1biBiZWZvcmUgdGhlIGZvY3VzXG4gICAgLy8gdHJhcCBlbGVtZW50cyBvbkZvY3VzIHByb3AgaXMgY2FsbGVkLlxuICAgIHBvcnRhbE5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIG9uRm9jdXMsIHRydWUpO1xuICAgIHBvcnRhbE5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBvbkZvY3VzLCB0cnVlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcG9ydGFsTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgb25Gb2N1cywgdHJ1ZSk7XG4gICAgICBwb3J0YWxOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0Jywgb25Gb2N1cywgdHJ1ZSk7XG4gICAgfTtcbiAgfSwgW3BvcnRhbE5vZGUsIHByZXNlcnZlVGFiT3JkZXIsIGZvY3VzTWFuYWdlclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBmb2N1c01hbmFnZXJTdGF0ZS5tb2RhbF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUG9ydGFsQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgICBwcmVzZXJ2ZVRhYk9yZGVyLFxuICAgICAgYmVmb3JlT3V0c2lkZVJlZixcbiAgICAgIGFmdGVyT3V0c2lkZVJlZixcbiAgICAgIGJlZm9yZUluc2lkZVJlZixcbiAgICAgIGFmdGVySW5zaWRlUmVmLFxuICAgICAgcG9ydGFsTm9kZSxcbiAgICAgIHNldEZvY3VzTWFuYWdlclN0YXRlXG4gICAgfSksIFtwcmVzZXJ2ZVRhYk9yZGVyLCBwb3J0YWxOb2RlXSlcbiAgfSwgc2hvdWxkUmVuZGVyR3VhcmRzICYmIHBvcnRhbE5vZGUgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9jdXNHdWFyZCwge1xuICAgIFwiZGF0YS10eXBlXCI6IFwib3V0c2lkZVwiLFxuICAgIHJlZjogYmVmb3JlT3V0c2lkZVJlZixcbiAgICBvbkZvY3VzOiBldmVudCA9PiB7XG4gICAgICBpZiAoaXNPdXRzaWRlRXZlbnQoZXZlbnQsIHBvcnRhbE5vZGUpKSB7XG4gICAgICAgIHZhciBfYmVmb3JlSW5zaWRlUmVmJGN1cnI7XG4gICAgICAgIChfYmVmb3JlSW5zaWRlUmVmJGN1cnIgPSBiZWZvcmVJbnNpZGVSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iZWZvcmVJbnNpZGVSZWYkY3Vyci5mb2N1cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcHJldlRhYmJhYmxlID0gZ2V0UHJldmlvdXNUYWJiYWJsZSgpIHx8IChmb2N1c01hbmFnZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogZm9jdXNNYW5hZ2VyU3RhdGUucmVmcy5kb21SZWZlcmVuY2UuY3VycmVudCk7XG4gICAgICAgIHByZXZUYWJiYWJsZSA9PSBudWxsID8gdm9pZCAwIDogcHJldlRhYmJhYmxlLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuICB9KSwgc2hvdWxkUmVuZGVyR3VhcmRzICYmIHBvcnRhbE5vZGUgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBcImFyaWEtb3duc1wiOiBwb3J0YWxOb2RlLmlkLFxuICAgIHN0eWxlOiBISURERU5fU1RZTEVTXG4gIH0pLCByb290ID8gLyojX19QVVJFX18qL2NyZWF0ZVBvcnRhbChjaGlsZHJlbiwgcm9vdCkgOiBwb3J0YWxOb2RlID8gLyojX19QVVJFX18qL2NyZWF0ZVBvcnRhbChjaGlsZHJlbiwgcG9ydGFsTm9kZSkgOiBudWxsLCBzaG91bGRSZW5kZXJHdWFyZHMgJiYgcG9ydGFsTm9kZSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb2N1c0d1YXJkLCB7XG4gICAgXCJkYXRhLXR5cGVcIjogXCJvdXRzaWRlXCIsXG4gICAgcmVmOiBhZnRlck91dHNpZGVSZWYsXG4gICAgb25Gb2N1czogZXZlbnQgPT4ge1xuICAgICAgaWYgKGlzT3V0c2lkZUV2ZW50KGV2ZW50LCBwb3J0YWxOb2RlKSkge1xuICAgICAgICB2YXIgX2FmdGVySW5zaWRlUmVmJGN1cnJlO1xuICAgICAgICAoX2FmdGVySW5zaWRlUmVmJGN1cnJlID0gYWZ0ZXJJbnNpZGVSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hZnRlckluc2lkZVJlZiRjdXJyZS5mb2N1cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbmV4dFRhYmJhYmxlID0gZ2V0TmV4dFRhYmJhYmxlKCkgfHwgKGZvY3VzTWFuYWdlclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBmb2N1c01hbmFnZXJTdGF0ZS5yZWZzLmRvbVJlZmVyZW5jZS5jdXJyZW50KTtcbiAgICAgICAgbmV4dFRhYmJhYmxlID09IG51bGwgPyB2b2lkIDAgOiBuZXh0VGFiYmFibGUuZm9jdXMoKTtcbiAgICAgICAgKGZvY3VzTWFuYWdlclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBmb2N1c01hbmFnZXJTdGF0ZS5jbG9zZU9uRm9jdXNPdXQpICYmIChmb2N1c01hbmFnZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogZm9jdXNNYW5hZ2VyU3RhdGUub25PcGVuQ2hhbmdlKGZhbHNlKSk7XG4gICAgICB9XG4gICAgfVxuICB9KSk7XG59O1xuY29uc3QgdXNlUG9ydGFsQ29udGV4dCA9ICgpID0+IFJlYWN0LnVzZUNvbnRleHQoUG9ydGFsQ29udGV4dCk7XG5cbmNvbnN0IFZpc3VhbGx5SGlkZGVuRGlzbWlzcyA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIFZpc3VhbGx5SGlkZGVuRGlzbWlzcyhwcm9wcywgcmVmKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgIHJlZjogcmVmLFxuICAgIHRhYkluZGV4OiAtMSxcbiAgICBzdHlsZTogSElEREVOX1NUWUxFU1xuICB9KSk7XG59KTtcbi8qKlxuICogUHJvdmlkZXMgZm9jdXMgbWFuYWdlbWVudCBmb3IgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdGb2N1c01hbmFnZXJcbiAqL1xuZnVuY3Rpb24gRmxvYXRpbmdGb2N1c01hbmFnZXIoX3JlZikge1xuICBsZXQge1xuICAgIGNvbnRleHQsXG4gICAgY2hpbGRyZW4sXG4gICAgb3JkZXIgPSBbJ2NvbnRlbnQnXSxcbiAgICBndWFyZHMgPSB0cnVlLFxuICAgIGluaXRpYWxGb2N1cyA9IDAsXG4gICAgcmV0dXJuRm9jdXMgPSB0cnVlLFxuICAgIG1vZGFsID0gdHJ1ZSxcbiAgICB2aXN1YWxseUhpZGRlbkRpc21pc3MgPSBmYWxzZSxcbiAgICBjbG9zZU9uRm9jdXNPdXQgPSB0cnVlXG4gIH0gPSBfcmVmO1xuICBjb25zdCB7XG4gICAgcmVmcyxcbiAgICBub2RlSWQsXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGV2ZW50cyxcbiAgICBkYXRhUmVmLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBkb21SZWZlcmVuY2UsXG4gICAgICBmbG9hdGluZ1xuICAgIH1cbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IG9yZGVyUmVmID0gdXNlTGF0ZXN0UmVmKG9yZGVyKTtcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBjb25zdCBwb3J0YWxDb250ZXh0ID0gdXNlUG9ydGFsQ29udGV4dCgpO1xuICBjb25zdCBbdGFiYmFibGVDb250ZW50TGVuZ3RoLCBzZXRUYWJiYWJsZUNvbnRlbnRMZW5ndGhdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG5cbiAgLy8gQ29udHJvbGxlZCBieSBgdXNlTGlzdE5hdmlnYXRpb25gLlxuICBjb25zdCBpZ25vcmVJbml0aWFsRm9jdXMgPSB0eXBlb2YgaW5pdGlhbEZvY3VzID09PSAnbnVtYmVyJyAmJiBpbml0aWFsRm9jdXMgPCAwO1xuICBjb25zdCBzdGFydERpc21pc3NCdXR0b25SZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGVuZERpc21pc3NCdXR0b25SZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHByZXZlbnRSZXR1cm5Gb2N1c1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgaXNQb2ludGVyRG93blJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGlzSW5zaWRlUG9ydGFsID0gcG9ydGFsQ29udGV4dCAhPSBudWxsO1xuXG4gIC8vIElmIHRoZSByZWZlcmVuY2UgaXMgYSBjb21ib2JveCBhbmQgaXMgdHlwZWFibGUgKGUuZy4gaW5wdXQvdGV4dGFyZWEpLFxuICAvLyB0aGVyZSBhcmUgZGlmZmVyZW50IGZvY3VzIHNlbWFudGljcy4gVGhlIGd1YXJkcyBzaG91bGQgbm90IGJlIHJlbmRlcmVkLCBidXRcbiAgLy8gYXJpYS1oaWRkZW4gc2hvdWxkIGJlIGFwcGxpZWQgdG8gYWxsIG5vZGVzIHN0aWxsLiBGdXJ0aGVyLCB0aGUgdmlzdWFsbHlcbiAgLy8gaGlkZGVuIGRpc21pc3MgYnV0dG9uIHNob3VsZCBvbmx5IGFwcGVhciBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0LCBub3QgdGhlXG4gIC8vIHN0YXJ0LlxuICBjb25zdCBpc1R5cGVhYmxlQ29tYm9ib3ggPSBkb21SZWZlcmVuY2UgJiYgZG9tUmVmZXJlbmNlLmdldEF0dHJpYnV0ZSgncm9sZScpID09PSAnY29tYm9ib3gnICYmIGlzVHlwZWFibGVFbGVtZW50KGRvbVJlZmVyZW5jZSk7XG4gIGNvbnN0IGdldFRhYmJhYmxlQ29udGVudCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICBpZiAoY29udGFpbmVyID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnRhaW5lciA9IGZsb2F0aW5nO1xuICAgIH1cbiAgICByZXR1cm4gY29udGFpbmVyID8gdGFiYmFibGUoY29udGFpbmVyLCBnZXRUYWJiYWJsZU9wdGlvbnMoKSkgOiBbXTtcbiAgfSwgW2Zsb2F0aW5nXSk7XG4gIGNvbnN0IGdldFRhYmJhYmxlRWxlbWVudHMgPSBSZWFjdC51c2VDYWxsYmFjayhjb250YWluZXIgPT4ge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBnZXRUYWJiYWJsZUNvbnRlbnQoY29udGFpbmVyKTtcbiAgICByZXR1cm4gb3JkZXJSZWYuY3VycmVudC5tYXAodHlwZSA9PiB7XG4gICAgICBpZiAoZG9tUmVmZXJlbmNlICYmIHR5cGUgPT09ICdyZWZlcmVuY2UnKSB7XG4gICAgICAgIHJldHVybiBkb21SZWZlcmVuY2U7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmcgJiYgdHlwZSA9PT0gJ2Zsb2F0aW5nJykge1xuICAgICAgICByZXR1cm4gZmxvYXRpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5maWx0ZXIoQm9vbGVhbikuZmxhdCgpO1xuICB9LCBbZG9tUmVmZXJlbmNlLCBmbG9hdGluZywgb3JkZXJSZWYsIGdldFRhYmJhYmxlQ29udGVudF0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbW9kYWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSAnVGFiJykge1xuICAgICAgICAvLyBUaGUgZm9jdXMgZ3VhcmRzIGhhdmUgbm90aGluZyB0byBmb2N1cywgc28gd2UgbmVlZCB0byBzdG9wIHRoZSBldmVudC5cbiAgICAgICAgaWYgKGdldFRhYmJhYmxlQ29udGVudCgpLmxlbmd0aCA9PT0gMCAmJiAhaXNUeXBlYWJsZUNvbWJvYm94KSB7XG4gICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbHMgPSBnZXRUYWJiYWJsZUVsZW1lbnRzKCk7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldChldmVudCk7XG4gICAgICAgIGlmIChvcmRlclJlZi5jdXJyZW50WzBdID09PSAncmVmZXJlbmNlJyAmJiB0YXJnZXQgPT09IGRvbVJlZmVyZW5jZSkge1xuICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICBlbnF1ZXVlRm9jdXMoZWxzW2Vscy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVucXVldWVGb2N1cyhlbHNbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkZXJSZWYuY3VycmVudFsxXSA9PT0gJ2Zsb2F0aW5nJyAmJiB0YXJnZXQgPT09IGZsb2F0aW5nICYmIGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICBlbnF1ZXVlRm9jdXMoZWxzWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkb2MgPSBnZXREb2N1bWVudChmbG9hdGluZyk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbktleURvd24pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIG9uS2V5RG93bik7XG4gICAgfTtcbiAgfSwgW2RvbVJlZmVyZW5jZSwgZmxvYXRpbmcsIG1vZGFsLCBvcmRlclJlZiwgcmVmcywgaXNUeXBlYWJsZUNvbWJvYm94LCBnZXRUYWJiYWJsZUNvbnRlbnQsIGdldFRhYmJhYmxlRWxlbWVudHNdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNsb3NlT25Gb2N1c091dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEluIFNhZmFyaSwgYnV0dG9ucyBsb3NlIGZvY3VzIHdoZW4gcHJlc3NpbmcgdGhlbS5cbiAgICBmdW5jdGlvbiBoYW5kbGVQb2ludGVyRG93bigpIHtcbiAgICAgIGlzUG9pbnRlckRvd25SZWYuY3VycmVudCA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaXNQb2ludGVyRG93blJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlRm9jdXNPdXRzaWRlKGV2ZW50KSB7XG4gICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICAgIGNvbnN0IG1vdmVkVG9VbnJlbGF0ZWROb2RlID0gIShjb250YWlucyhkb21SZWZlcmVuY2UsIHJlbGF0ZWRUYXJnZXQpIHx8IGNvbnRhaW5zKGZsb2F0aW5nLCByZWxhdGVkVGFyZ2V0KSB8fCBjb250YWlucyhyZWxhdGVkVGFyZ2V0LCBmbG9hdGluZykgfHwgY29udGFpbnMocG9ydGFsQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogcG9ydGFsQ29udGV4dC5wb3J0YWxOb2RlLCByZWxhdGVkVGFyZ2V0KSB8fCByZWxhdGVkVGFyZ2V0ICE9IG51bGwgJiYgcmVsYXRlZFRhcmdldC5oYXNBdHRyaWJ1dGUoJ2RhdGEtZmxvYXRpbmctdWktZm9jdXMtZ3VhcmQnKSB8fCB0cmVlICYmIChnZXRDaGlsZHJlbih0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIG5vZGVJZCkuZmluZChub2RlID0+IHtcbiAgICAgICAgdmFyIF9ub2RlJGNvbnRleHQsIF9ub2RlJGNvbnRleHQyO1xuICAgICAgICByZXR1cm4gY29udGFpbnMoKF9ub2RlJGNvbnRleHQgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0LmVsZW1lbnRzLmZsb2F0aW5nLCByZWxhdGVkVGFyZ2V0KSB8fCBjb250YWlucygoX25vZGUkY29udGV4dDIgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0Mi5lbGVtZW50cy5kb21SZWZlcmVuY2UsIHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgfSkgfHwgZ2V0QW5jZXN0b3JzKHRyZWUubm9kZXNSZWYuY3VycmVudCwgbm9kZUlkKS5maW5kKG5vZGUgPT4ge1xuICAgICAgICB2YXIgX25vZGUkY29udGV4dDMsIF9ub2RlJGNvbnRleHQ0O1xuICAgICAgICByZXR1cm4gKChfbm9kZSRjb250ZXh0MyA9IG5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGNvbnRleHQzLmVsZW1lbnRzLmZsb2F0aW5nKSA9PT0gcmVsYXRlZFRhcmdldCB8fCAoKF9ub2RlJGNvbnRleHQ0ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dDQuZWxlbWVudHMuZG9tUmVmZXJlbmNlKSA9PT0gcmVsYXRlZFRhcmdldDtcbiAgICAgIH0pKSk7XG5cbiAgICAgIC8vIEZvY3VzIGRpZCBub3QgbW92ZSBpbnNpZGUgdGhlIGZsb2F0aW5nIHRyZWUsIGFuZCB0aGVyZSBhcmUgbm8gdGFiYmFibGVcbiAgICAgIC8vIHBvcnRhbCBndWFyZHMgdG8gaGFuZGxlIGNsb3NpbmcuXG4gICAgICBpZiAocmVsYXRlZFRhcmdldCAmJiBtb3ZlZFRvVW5yZWxhdGVkTm9kZSAmJiAhaXNQb2ludGVyRG93blJlZi5jdXJyZW50ICYmXG4gICAgICAvLyBGaXggUmVhY3QgMTggU3RyaWN0IE1vZGUgcmV0dXJuRm9jdXMgZHVlIHRvIGRvdWJsZSByZW5kZXJpbmcuXG4gICAgICByZWxhdGVkVGFyZ2V0ICE9PSBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRSZWYuY3VycmVudCkge1xuICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIC8vIE9uIGlPUyBWb2ljZU92ZXIsIGRpc21pc3NpbmcgdGhlIG5lc3RlZCBzdWJtZW51IHdpbGwgY2F1c2UgdGhlXG4gICAgICAgIC8vIGZpcnN0IGl0ZW0gb2YgdGhlIGxpc3QgdG8gcmVjZWl2ZSBmb2N1cy4gRGVsYXlpbmcgaXQgYXBwZWFycyB0byBmaXhcbiAgICAgICAgLy8gdGhlIGlzc3VlLlxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IG9uT3BlbkNoYW5nZShmYWxzZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmxvYXRpbmcgJiYgaXNIVE1MRWxlbWVudChkb21SZWZlcmVuY2UpKSB7XG4gICAgICBkb21SZWZlcmVuY2UuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBoYW5kbGVGb2N1c091dHNpZGUpO1xuICAgICAgZG9tUmVmZXJlbmNlLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgIW1vZGFsICYmIGZsb2F0aW5nLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgaGFuZGxlRm9jdXNPdXRzaWRlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRvbVJlZmVyZW5jZS5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIGhhbmRsZUZvY3VzT3V0c2lkZSk7XG4gICAgICAgIGRvbVJlZmVyZW5jZS5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIGhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgIW1vZGFsICYmIGZsb2F0aW5nLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgaGFuZGxlRm9jdXNPdXRzaWRlKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbZG9tUmVmZXJlbmNlLCBmbG9hdGluZywgbW9kYWwsIG5vZGVJZCwgdHJlZSwgcG9ydGFsQ29udGV4dCwgb25PcGVuQ2hhbmdlLCBjbG9zZU9uRm9jdXNPdXRdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgX3BvcnRhbENvbnRleHQkcG9ydGFsO1xuICAgIC8vIERvbid0IGhpZGUgcG9ydGFscyBuZXN0ZWQgd2l0aGluIHRoZSBwYXJlbnQgcG9ydGFsLlxuICAgIGNvbnN0IHBvcnRhbE5vZGVzID0gQXJyYXkuZnJvbSgocG9ydGFsQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogKF9wb3J0YWxDb250ZXh0JHBvcnRhbCA9IHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wb3J0YWxDb250ZXh0JHBvcnRhbC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1mbG9hdGluZy11aS1wb3J0YWxdJykpIHx8IFtdKTtcbiAgICBmdW5jdGlvbiBnZXREaXNtaXNzQnV0dG9ucygpIHtcbiAgICAgIHJldHVybiBbc3RhcnREaXNtaXNzQnV0dG9uUmVmLmN1cnJlbnQsIGVuZERpc21pc3NCdXR0b25SZWYuY3VycmVudF0uZmlsdGVyKEJvb2xlYW4pO1xuICAgIH1cbiAgICBpZiAoZmxvYXRpbmcgJiYgbW9kYWwpIHtcbiAgICAgIGNvbnN0IGluc2lkZU5vZGVzID0gW2Zsb2F0aW5nLCAuLi5wb3J0YWxOb2RlcywgLi4uZ2V0RGlzbWlzc0J1dHRvbnMoKV07XG4gICAgICBjb25zdCBjbGVhbnVwID0gaGlkZU90aGVycyhvcmRlclJlZi5jdXJyZW50LmluY2x1ZGVzKCdyZWZlcmVuY2UnKSB8fCBpc1R5cGVhYmxlQ29tYm9ib3ggPyBpbnNpZGVOb2Rlcy5jb25jYXQoZG9tUmVmZXJlbmNlIHx8IFtdKSA6IGluc2lkZU5vZGVzKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbZG9tUmVmZXJlbmNlLCBmbG9hdGluZywgbW9kYWwsIG9yZGVyUmVmLCBwb3J0YWxDb250ZXh0LCBpc1R5cGVhYmxlQ29tYm9ib3hdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAobW9kYWwgJiYgIWd1YXJkcyAmJiBmbG9hdGluZykge1xuICAgICAgY29uc3QgdGFiSW5kZXhWYWx1ZXMgPSBbXTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBnZXRUYWJiYWJsZU9wdGlvbnMoKTtcbiAgICAgIGNvbnN0IGFsbFRhYmJhYmxlID0gdGFiYmFibGUoZ2V0RG9jdW1lbnQoZmxvYXRpbmcpLmJvZHksIG9wdGlvbnMpO1xuICAgICAgY29uc3QgZmxvYXRpbmdUYWJiYWJsZSA9IGdldFRhYmJhYmxlRWxlbWVudHMoKTtcblxuICAgICAgLy8gRXhjbHVkZSBhbGwgdGFiYmFibGUgZWxlbWVudHMgdGhhdCBhcmUgcGFydCBvZiB0aGUgb3JkZXJcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gYWxsVGFiYmFibGUuZmlsdGVyKGVsID0+ICFmbG9hdGluZ1RhYmJhYmxlLmluY2x1ZGVzKGVsKSk7XG4gICAgICBlbGVtZW50cy5mb3JFYWNoKChlbCwgaSkgPT4ge1xuICAgICAgICB0YWJJbmRleFZhbHVlc1tpXSA9IGVsLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKChlbCwgaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGFiSW5kZXhWYWx1ZXNbaV07XG4gICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtmbG9hdGluZywgbW9kYWwsIGd1YXJkcywgZ2V0VGFiYmFibGVFbGVtZW50c10pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKCFmbG9hdGluZykgcmV0dXJuO1xuICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KGZsb2F0aW5nKTtcbiAgICBsZXQgcmV0dXJuRm9jdXNWYWx1ZSA9IHJldHVybkZvY3VzO1xuICAgIGxldCBwcmV2ZW50UmV0dXJuRm9jdXNTY3JvbGwgPSBmYWxzZTtcbiAgICBjb25zdCBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQgPSBhY3RpdmVFbGVtZW50JDEoZG9jKTtcbiAgICBjb25zdCBjb250ZXh0RGF0YSA9IGRhdGFSZWYuY3VycmVudDtcbiAgICBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRSZWYuY3VycmVudCA9IHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudDtcbiAgICBjb25zdCBmb2N1c2FibGVFbGVtZW50cyA9IGdldFRhYmJhYmxlRWxlbWVudHMoZmxvYXRpbmcpO1xuICAgIGNvbnN0IGVsVG9Gb2N1cyA9ICh0eXBlb2YgaW5pdGlhbEZvY3VzID09PSAnbnVtYmVyJyA/IGZvY3VzYWJsZUVsZW1lbnRzW2luaXRpYWxGb2N1c10gOiBpbml0aWFsRm9jdXMuY3VycmVudCkgfHwgZmxvYXRpbmc7XG5cbiAgICAvLyBJZiB0aGUgYHVzZUxpc3ROYXZpZ2F0aW9uYCBob29rIGlzIGFjdGl2ZSwgYWx3YXlzIGlnbm9yZSBgaW5pdGlhbEZvY3VzYFxuICAgIC8vIGJlY2F1c2UgaXQgaGFzIGl0cyBvd24gaGFuZGxpbmcgb2YgdGhlIGluaXRpYWwgZm9jdXMuXG4gICAgIWlnbm9yZUluaXRpYWxGb2N1cyAmJiBlbnF1ZXVlRm9jdXMoZWxUb0ZvY3VzLCB7XG4gICAgICBwcmV2ZW50U2Nyb2xsOiBlbFRvRm9jdXMgPT09IGZsb2F0aW5nXG4gICAgfSk7XG5cbiAgICAvLyBEaXNtaXNzaW5nIHZpYSBvdXRzaWRlIHByZXNzIHNob3VsZCBhbHdheXMgaWdub3JlIGByZXR1cm5Gb2N1c2AgdG9cbiAgICAvLyBwcmV2ZW50IHVud2FudGVkIHNjcm9sbGluZy5cbiAgICBmdW5jdGlvbiBvbkRpc21pc3MocGF5bG9hZCkge1xuICAgICAgaWYgKHBheWxvYWQudHlwZSA9PT0gJ2VzY2FwZUtleScgJiYgcmVmcy5kb21SZWZlcmVuY2UuY3VycmVudCkge1xuICAgICAgICBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRSZWYuY3VycmVudCA9IHJlZnMuZG9tUmVmZXJlbmNlLmN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoWydyZWZlcmVuY2VQcmVzcycsICdlc2NhcGVLZXknXS5pbmNsdWRlcyhwYXlsb2FkLnR5cGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJldHVybkZvY3VzID0gcGF5bG9hZC5kYXRhLnJldHVybkZvY3VzO1xuICAgICAgaWYgKHR5cGVvZiByZXR1cm5Gb2N1cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuRm9jdXNWYWx1ZSA9IHRydWU7XG4gICAgICAgIHByZXZlbnRSZXR1cm5Gb2N1c1Njcm9sbCA9IHJldHVybkZvY3VzLnByZXZlbnRTY3JvbGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm5Gb2N1c1ZhbHVlID0gcmV0dXJuRm9jdXM7XG4gICAgICB9XG4gICAgfVxuICAgIGV2ZW50cy5vbignZGlzbWlzcycsIG9uRGlzbWlzcyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGV2ZW50cy5vZmYoJ2Rpc21pc3MnLCBvbkRpc21pc3MpO1xuICAgICAgaWYgKGNvbnRhaW5zKGZsb2F0aW5nLCBhY3RpdmVFbGVtZW50JDEoZG9jKSkgJiYgcmVmcy5kb21SZWZlcmVuY2UuY3VycmVudCkge1xuICAgICAgICBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRSZWYuY3VycmVudCA9IHJlZnMuZG9tUmVmZXJlbmNlLmN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAocmV0dXJuRm9jdXNWYWx1ZSAmJiBpc0hUTUxFbGVtZW50KHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudFJlZi5jdXJyZW50KSAmJiAhcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgLy8gYGlzUG9pbnRlckRvd25SZWYuY3VycmVudGAgdG8gYXZvaWQgdGhlIGZvY3VzIHJpbmcgZnJvbSBhcHBlYXJpbmcgb25cbiAgICAgICAgLy8gdGhlIHJlZmVyZW5jZSBlbGVtZW50IHdoZW4gY2xpY2stdG9nZ2xpbmcgaXQuXG4gICAgICAgIGlmICghcmVmcy5kb21SZWZlcmVuY2UuY3VycmVudCB8fCBpc1BvaW50ZXJEb3duUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBlbnF1ZXVlRm9jdXMocHJldmlvdXNseUZvY3VzZWRFbGVtZW50UmVmLmN1cnJlbnQsIHtcbiAgICAgICAgICAgIC8vIFdoZW4gZGlzbWlzc2luZyBuZXN0ZWQgZmxvYXRpbmcgZWxlbWVudHMsIGJ5IHRoZSB0aW1lIHRoZSByQUYgaGFzXG4gICAgICAgICAgICAvLyBleGVjdXRlZCwgdGhlIG1lbnVzIHdpbGwgYWxsIGhhdmUgYmVlbiB1bm1vdW50ZWQuIFdoZW4gdGhleSB0cnlcbiAgICAgICAgICAgIC8vIHRvIGdldCBmb2N1c2VkLCB0aGUgY2FsbHMgZ2V0IGlnbm9yZWQg4oCUIGxlYXZpbmcgdGhlIHJvb3RcbiAgICAgICAgICAgIC8vIHJlZmVyZW5jZSBmb2N1c2VkIGFzIGRlc2lyZWQuXG4gICAgICAgICAgICBjYW5jZWxQcmV2aW91czogZmFsc2UsXG4gICAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiBwcmV2ZW50UmV0dXJuRm9jdXNTY3JvbGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX3ByZXZpb3VzbHlGb2N1c2VkRWxlO1xuICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGhhcyBzcGVjaWZpZWQgYSBga2V5ZG93bmAgbGlzdGVuZXIgdGhhdCBjYWxsc1xuICAgICAgICAgIC8vIHNldE9wZW4oZmFsc2UpIChlLmcuIHNlbGVjdGluZyBhbiBpdGVtIGFuZCBjbG9zaW5nIHRoZSBmbG9hdGluZ1xuICAgICAgICAgIC8vIGVsZW1lbnQpLCB0aGVuIHN5bmMgcmV0dXJuIGZvY3VzIGNhdXNlcyBgdXNlQ2xpY2tgIHRvIGltbWVkaWF0ZWx5XG4gICAgICAgICAgLy8gcmUtb3BlbiBpdCwgdW5sZXNzIHRoZXkgY2FsbCBgZXZlbnQucHJldmVudERlZmF1bHQoKWAgaW4gdGhlXG4gICAgICAgICAgLy8gYGtleWRvd25gIGxpc3RlbmVyLiBUaGlzIGhlbHBzIGtlZXAgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aFxuICAgICAgICAgIC8vIG9sZGVyIGV4YW1wbGVzLlxuICAgICAgICAgIGNvbnRleHREYXRhLl9fc3luY1JldHVybkZvY3VzID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIEluIFNhZmFyaSwgYHVzZUxpc3ROYXZpZ2F0aW9uYCBtb3ZlcyBmb2N1cyBzeW5jLCBzbyBtYWtpbmcgdGhpc1xuICAgICAgICAgIC8vIHN5bmMgZW5zdXJlcyB0aGUgaW5pdGlhbCBpdGVtIHJlbWFpbnMgZm9jdXNlZCBkZXNwaXRlIHRoaXMgYmVpbmdcbiAgICAgICAgICAvLyBpbnZva2VkIGluIFN0cmljdCBNb2RlIGR1ZSB0byBkb3VibGUtaW52b2tlZCB1c2VFZmZlY3RzLiBUaGlzIGFsc29cbiAgICAgICAgICAvLyBoYXMgdGhlIHBvc2l0aXZlIHNpZGUgZWZmZWN0IG9mIGNsb3NpbmcgYSBtb2RhbGx5IGZvY3VzLW1hbmFnZWRcbiAgICAgICAgICAvLyA8TWVudT4gb24gYFRhYmAga2V5ZG93biB0byBtb3ZlIG5hdHVyYWxseSB0byB0aGUgbmV4dCBmb2N1c2FibGVcbiAgICAgICAgICAvLyBlbGVtZW50LlxuICAgICAgICAgIChfcHJldmlvdXNseUZvY3VzZWRFbGUgPSBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wcmV2aW91c2x5Rm9jdXNlZEVsZS5mb2N1cyh7XG4gICAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiBwcmV2ZW50UmV0dXJuRm9jdXNTY3JvbGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXNuJ3QgYW4gYWN0dWFsIHByb3BlcnR5IHRoZSB1c2VyIHNob3VsZCBhY2Nlc3MsIG1ha2Ugc3VyZVxuICAgICAgICAgICAgLy8gaXQgZG9lc24ndCBwZXJzaXN0LlxuICAgICAgICAgICAgZGVsZXRlIGNvbnRleHREYXRhLl9fc3luY1JldHVybkZvY3VzO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2Zsb2F0aW5nLCBnZXRUYWJiYWJsZUVsZW1lbnRzLCBpbml0aWFsRm9jdXMsIHJldHVybkZvY3VzLCBkYXRhUmVmLCByZWZzLCBldmVudHMsIGlnbm9yZUluaXRpYWxGb2N1c10pO1xuXG4gIC8vIFN5bmNocm9uaXplIHRoZSBgY29udGV4dGAgJiBgbW9kYWxgIHZhbHVlIHRvIHRoZSBGbG9hdGluZ1BvcnRhbCBjb250ZXh0LlxuICAvLyBJdCB3aWxsIGRlY2lkZSB3aGV0aGVyIG9yIG5vdCBpdCBuZWVkcyB0byByZW5kZXIgaXRzIG93biBndWFyZHMuXG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIXBvcnRhbENvbnRleHQpIHJldHVybjtcbiAgICBwb3J0YWxDb250ZXh0LnNldEZvY3VzTWFuYWdlclN0YXRlKHtcbiAgICAgIC4uLmNvbnRleHQsXG4gICAgICBtb2RhbCxcbiAgICAgIGNsb3NlT25Gb2N1c091dFxuICAgICAgLy8gTm90IGNvbmNlcm5lZCBhYm91dCB0aGUgPFJUPiBnZW5lcmljIHR5cGUuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcG9ydGFsQ29udGV4dC5zZXRGb2N1c01hbmFnZXJTdGF0ZShudWxsKTtcbiAgICB9O1xuICB9LCBbcG9ydGFsQ29udGV4dCwgbW9kYWwsIGNsb3NlT25Gb2N1c091dCwgY29udGV4dF0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKGlnbm9yZUluaXRpYWxGb2N1cyB8fCAhZmxvYXRpbmcpIHJldHVybjtcbiAgICBmdW5jdGlvbiBzZXRTdGF0ZSgpIHtcbiAgICAgIHNldFRhYmJhYmxlQ29udGVudExlbmd0aChnZXRUYWJiYWJsZUNvbnRlbnQoKS5sZW5ndGgpO1xuICAgIH1cbiAgICBzZXRTdGF0ZSgpO1xuICAgIGlmICh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihzZXRTdGF0ZSk7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKGZsb2F0aW5nLCB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2Zsb2F0aW5nLCBnZXRUYWJiYWJsZUNvbnRlbnQsIGlnbm9yZUluaXRpYWxGb2N1cywgcmVmc10pO1xuICBjb25zdCBzaG91bGRSZW5kZXJHdWFyZHMgPSBndWFyZHMgJiYgKGlzSW5zaWRlUG9ydGFsIHx8IG1vZGFsKSAmJiAhaXNUeXBlYWJsZUNvbWJvYm94O1xuICBmdW5jdGlvbiByZW5kZXJEaXNtaXNzQnV0dG9uKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIHZpc3VhbGx5SGlkZGVuRGlzbWlzcyAmJiBtb2RhbCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFZpc3VhbGx5SGlkZGVuRGlzbWlzcywge1xuICAgICAgcmVmOiBsb2NhdGlvbiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0RGlzbWlzc0J1dHRvblJlZiA6IGVuZERpc21pc3NCdXR0b25SZWYsXG4gICAgICBvbkNsaWNrOiAoKSA9PiBvbk9wZW5DaGFuZ2UoZmFsc2UpXG4gICAgfSwgdHlwZW9mIHZpc3VhbGx5SGlkZGVuRGlzbWlzcyA9PT0gJ3N0cmluZycgPyB2aXN1YWxseUhpZGRlbkRpc21pc3MgOiAnRGlzbWlzcycpIDogbnVsbDtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIHNob3VsZFJlbmRlckd1YXJkcyAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb2N1c0d1YXJkLCB7XG4gICAgXCJkYXRhLXR5cGVcIjogXCJpbnNpZGVcIixcbiAgICByZWY6IHBvcnRhbENvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IHBvcnRhbENvbnRleHQuYmVmb3JlSW5zaWRlUmVmLFxuICAgIG9uRm9jdXM6IGV2ZW50ID0+IHtcbiAgICAgIGlmIChtb2RhbCkge1xuICAgICAgICBjb25zdCBlbHMgPSBnZXRUYWJiYWJsZUVsZW1lbnRzKCk7XG4gICAgICAgIGVucXVldWVGb2N1cyhvcmRlclswXSA9PT0gJ3JlZmVyZW5jZScgPyBlbHNbMF0gOiBlbHNbZWxzLmxlbmd0aCAtIDFdKTtcbiAgICAgIH0gZWxzZSBpZiAocG9ydGFsQ29udGV4dCAhPSBudWxsICYmIHBvcnRhbENvbnRleHQucHJlc2VydmVUYWJPcmRlciAmJiBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUpIHtcbiAgICAgICAgcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGlzT3V0c2lkZUV2ZW50KGV2ZW50LCBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUpKSB7XG4gICAgICAgICAgY29uc3QgbmV4dFRhYmJhYmxlID0gZ2V0TmV4dFRhYmJhYmxlKCkgfHwgZG9tUmVmZXJlbmNlO1xuICAgICAgICAgIG5leHRUYWJiYWJsZSA9PSBudWxsID8gdm9pZCAwIDogbmV4dFRhYmJhYmxlLmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9wb3J0YWxDb250ZXh0JGJlZm9yZTtcbiAgICAgICAgICAoX3BvcnRhbENvbnRleHQkYmVmb3JlID0gcG9ydGFsQ29udGV4dC5iZWZvcmVPdXRzaWRlUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfcG9ydGFsQ29udGV4dCRiZWZvcmUuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSksIGlzVHlwZWFibGVDb21ib2JveCA/IG51bGwgOiByZW5kZXJEaXNtaXNzQnV0dG9uKCdzdGFydCcpLCAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkcmVuLCB0YWJiYWJsZUNvbnRlbnRMZW5ndGggPT09IDAgfHwgb3JkZXIuaW5jbHVkZXMoJ2Zsb2F0aW5nJykgPyB7XG4gICAgdGFiSW5kZXg6IDBcbiAgfSA6IHt9KSwgcmVuZGVyRGlzbWlzc0J1dHRvbignZW5kJyksIHNob3VsZFJlbmRlckd1YXJkcyAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb2N1c0d1YXJkLCB7XG4gICAgXCJkYXRhLXR5cGVcIjogXCJpbnNpZGVcIixcbiAgICByZWY6IHBvcnRhbENvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IHBvcnRhbENvbnRleHQuYWZ0ZXJJbnNpZGVSZWYsXG4gICAgb25Gb2N1czogZXZlbnQgPT4ge1xuICAgICAgaWYgKG1vZGFsKSB7XG4gICAgICAgIGVucXVldWVGb2N1cyhnZXRUYWJiYWJsZUVsZW1lbnRzKClbMF0pO1xuICAgICAgfSBlbHNlIGlmIChwb3J0YWxDb250ZXh0ICE9IG51bGwgJiYgcG9ydGFsQ29udGV4dC5wcmVzZXJ2ZVRhYk9yZGVyICYmIHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSkge1xuICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIGlmIChpc091dHNpZGVFdmVudChldmVudCwgcG9ydGFsQ29udGV4dC5wb3J0YWxOb2RlKSkge1xuICAgICAgICAgIGNvbnN0IHByZXZUYWJiYWJsZSA9IGdldFByZXZpb3VzVGFiYmFibGUoKSB8fCBkb21SZWZlcmVuY2U7XG4gICAgICAgICAgcHJldlRhYmJhYmxlID09IG51bGwgPyB2b2lkIDAgOiBwcmV2VGFiYmFibGUuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX3BvcnRhbENvbnRleHQkYWZ0ZXJPO1xuICAgICAgICAgIChfcG9ydGFsQ29udGV4dCRhZnRlck8gPSBwb3J0YWxDb250ZXh0LmFmdGVyT3V0c2lkZVJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3BvcnRhbENvbnRleHQkYWZ0ZXJPLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pKTtcbn1cblxuY29uc3QgaWRlbnRpZmllciA9ICdkYXRhLWZsb2F0aW5nLXVpLXNjcm9sbC1sb2NrJztcblxuLyoqXG4gKiBQcm92aWRlcyBiYXNlIHN0eWxpbmcgZm9yIGEgZml4ZWQgb3ZlcmxheSBlbGVtZW50IHRvIGRpbSBjb250ZW50IG9yIGJsb2NrXG4gKiBwb2ludGVyIGV2ZW50cyBiZWhpbmQgYSBmbG9hdGluZyBlbGVtZW50LlxuICogSXQncyBhIHJlZ3VsYXIgYDxkaXY+YCwgc28gaXQgY2FuIGJlIHN0eWxlZCB2aWEgYW55IENTUyBzb2x1dGlvbiB5b3UgcHJlZmVyLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nT3ZlcmxheVxuICovXG5jb25zdCBGbG9hdGluZ092ZXJsYXkgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBGbG9hdGluZ092ZXJsYXkoX3JlZiwgcmVmKSB7XG4gIGxldCB7XG4gICAgbG9ja1Njcm9sbCA9IGZhbHNlLFxuICAgIC4uLnJlc3RcbiAgfSA9IF9yZWY7XG4gIGluZGV4KCgpID0+IHtcbiAgICB2YXIgX3dpbmRvdyR2aXN1YWxWaWV3cG9yLCBfd2luZG93JHZpc3VhbFZpZXdwb3IyO1xuICAgIGlmICghbG9ja1Njcm9sbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhbHJlYWR5TG9ja2VkID0gZG9jdW1lbnQuYm9keS5oYXNBdHRyaWJ1dGUoaWRlbnRpZmllcik7XG4gICAgaWYgKGFscmVhZHlMb2NrZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZG9jdW1lbnQuYm9keS5zZXRBdHRyaWJ1dGUoaWRlbnRpZmllciwgJycpO1xuXG4gICAgLy8gUlRMIDxib2R5PiBzY3JvbGxiYXJcbiAgICBjb25zdCBzY3JvbGxiYXJYID0gTWF0aC5yb3VuZChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCkgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICBjb25zdCBwYWRkaW5nUHJvcCA9IHNjcm9sbGJhclggPyAncGFkZGluZ0xlZnQnIDogJ3BhZGRpbmdSaWdodCc7XG4gICAgY29uc3Qgc2Nyb2xsYmFyV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcblxuICAgIC8vIE9ubHkgaU9TIGRvZXNuJ3QgcmVzcGVjdCBgb3ZlcmZsb3c6IGhpZGRlbmAgb24gZG9jdW1lbnQuYm9keSwgYW5kIHRoaXNcbiAgICAvLyB0ZWNobmlxdWUgaGFzIGZld2VyIHNpZGUgZWZmZWN0cy5cbiAgICBpZiAoIS9pUChob25lfGFkfG9kKXxpT1MvLnRlc3QoZ2V0UGxhdGZvcm0oKSkpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oZG9jdW1lbnQuYm9keS5zdHlsZSwge1xuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIFtwYWRkaW5nUHJvcF06IHNjcm9sbGJhcldpZHRoICsgXCJweFwiXG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQXR0cmlidXRlKGlkZW50aWZpZXIpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGRvY3VtZW50LmJvZHkuc3R5bGUsIHtcbiAgICAgICAgICBvdmVyZmxvdzogJycsXG4gICAgICAgICAgW3BhZGRpbmdQcm9wXTogJydcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIGlPUyAxMiBkb2VzIG5vdCBzdXBwb3J0IGB2aXN1YWxWaWV3cG9ydGAuXG4gICAgY29uc3Qgb2Zmc2V0TGVmdCA9ICgoX3dpbmRvdyR2aXN1YWxWaWV3cG9yID0gd2luZG93LnZpc3VhbFZpZXdwb3J0KSA9PSBudWxsID8gdm9pZCAwIDogX3dpbmRvdyR2aXN1YWxWaWV3cG9yLm9mZnNldExlZnQpIHx8IDA7XG4gICAgY29uc3Qgb2Zmc2V0VG9wID0gKChfd2luZG93JHZpc3VhbFZpZXdwb3IyID0gd2luZG93LnZpc3VhbFZpZXdwb3J0KSA9PSBudWxsID8gdm9pZCAwIDogX3dpbmRvdyR2aXN1YWxWaWV3cG9yMi5vZmZzZXRUb3ApIHx8IDA7XG4gICAgY29uc3Qgc2Nyb2xsWCA9IHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICBjb25zdCBzY3JvbGxZID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgIE9iamVjdC5hc3NpZ24oZG9jdW1lbnQuYm9keS5zdHlsZSwge1xuICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICB0b3A6IC0oc2Nyb2xsWSAtIE1hdGguZmxvb3Iob2Zmc2V0VG9wKSkgKyBcInB4XCIsXG4gICAgICBsZWZ0OiAtKHNjcm9sbFggLSBNYXRoLmZsb29yKG9mZnNldExlZnQpKSArIFwicHhcIixcbiAgICAgIHJpZ2h0OiAnMCcsXG4gICAgICBbcGFkZGluZ1Byb3BdOiBzY3JvbGxiYXJXaWR0aCArIFwicHhcIlxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBPYmplY3QuYXNzaWduKGRvY3VtZW50LmJvZHkuc3R5bGUsIHtcbiAgICAgICAgcG9zaXRpb246ICcnLFxuICAgICAgICBvdmVyZmxvdzogJycsXG4gICAgICAgIHRvcDogJycsXG4gICAgICAgIGxlZnQ6ICcnLFxuICAgICAgICByaWdodDogJycsXG4gICAgICAgIFtwYWRkaW5nUHJvcF06ICcnXG4gICAgICB9KTtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQXR0cmlidXRlKGlkZW50aWZpZXIpO1xuICAgICAgd2luZG93LnNjcm9sbFRvKHNjcm9sbFgsIHNjcm9sbFkpO1xuICAgIH07XG4gIH0sIFtsb2NrU2Nyb2xsXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiByZWZcbiAgfSwgcmVzdCwge1xuICAgIHN0eWxlOiB7XG4gICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgIG92ZXJmbG93OiAnYXV0bycsXG4gICAgICB0b3A6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIGJvdHRvbTogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICAuLi5yZXN0LnN0eWxlXG4gICAgfVxuICB9KSk7XG59KTtcblxuZnVuY3Rpb24gaXNCdXR0b25UYXJnZXQoZXZlbnQpIHtcbiAgcmV0dXJuIGlzSFRNTEVsZW1lbnQoZXZlbnQudGFyZ2V0KSAmJiBldmVudC50YXJnZXQudGFnTmFtZSA9PT0gJ0JVVFRPTic7XG59XG5mdW5jdGlvbiBpc1NwYWNlSWdub3JlZChlbGVtZW50KSB7XG4gIHJldHVybiBpc1R5cGVhYmxlRWxlbWVudChlbGVtZW50KTtcbn1cbi8qKlxuICogQWRkcyBjbGljayBldmVudCBsaXN0ZW5lcnMgdGhhdCBjaGFuZ2UgdGhlIG9wZW4gc3RhdGUuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlQ2xpY2tcbiAqL1xuY29uc3QgdXNlQ2xpY2sgPSBmdW5jdGlvbiAoX3JlZiwgX3RlbXApIHtcbiAgbGV0IHtcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICBkYXRhUmVmLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBkb21SZWZlcmVuY2VcbiAgICB9XG4gIH0gPSBfcmVmO1xuICBsZXQge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIGV2ZW50OiBldmVudE9wdGlvbiA9ICdjbGljaycsXG4gICAgdG9nZ2xlID0gdHJ1ZSxcbiAgICBpZ25vcmVNb3VzZSA9IGZhbHNlLFxuICAgIGtleWJvYXJkSGFuZGxlcnMgPSB0cnVlXG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgY29uc3QgcG9pbnRlclR5cGVSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgIG9uUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICAgICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gZXZlbnQucG9pbnRlclR5cGU7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgICAgLy8gSWdub3JlIGFsbCBidXR0b25zIGV4Y2VwdCBmb3IgdGhlIFwibWFpblwiIGJ1dHRvbi5cbiAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC9idXR0b25cbiAgICAgICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQsIHRydWUpICYmIGlnbm9yZU1vdXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChldmVudE9wdGlvbiA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgaWYgKHRvZ2dsZSAmJiAoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCA/IGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgOiB0cnVlKSkge1xuICAgICAgICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IHN0ZWFsaW5nIGZvY3VzIGZyb20gdGhlIGZsb2F0aW5nIGVsZW1lbnRcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQgPSBldmVudC5uYXRpdmVFdmVudDtcbiAgICAgICAgfSxcbiAgICAgICAgb25DbGljayhldmVudCkge1xuICAgICAgICAgIGlmIChkYXRhUmVmLmN1cnJlbnQuX19zeW5jUmV0dXJuRm9jdXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV2ZW50T3B0aW9uID09PSAnbW91c2Vkb3duJyAmJiBwb2ludGVyVHlwZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNNb3VzZUxpa2VQb2ludGVyVHlwZShwb2ludGVyVHlwZVJlZi5jdXJyZW50LCB0cnVlKSAmJiBpZ25vcmVNb3VzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgaWYgKHRvZ2dsZSAmJiAoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCA/IGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQudHlwZSA9PT0gJ2NsaWNrJyA6IHRydWUpKSB7XG4gICAgICAgICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCA9IGV2ZW50Lm5hdGl2ZUV2ZW50O1xuICAgICAgICB9LFxuICAgICAgICBvbktleURvd24oZXZlbnQpIHtcbiAgICAgICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmICgha2V5Ym9hcmRIYW5kbGVycykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNCdXR0b25UYXJnZXQoZXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICcgJyAmJiAhaXNTcGFjZUlnbm9yZWQoZG9tUmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgLy8gUHJldmVudCBzY3JvbGxpbmdcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICdFbnRlcicpIHtcbiAgICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICAgIGlmICh0b2dnbGUpIHtcbiAgICAgICAgICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbktleVVwKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKCFrZXlib2FyZEhhbmRsZXJzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0J1dHRvblRhcmdldChldmVudCkgfHwgaXNTcGFjZUlnbm9yZWQoZG9tUmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnICcpIHtcbiAgICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICAgIGlmICh0b2dnbGUpIHtcbiAgICAgICAgICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIGRhdGFSZWYsIGV2ZW50T3B0aW9uLCBpZ25vcmVNb3VzZSwga2V5Ym9hcmRIYW5kbGVycywgZG9tUmVmZXJlbmNlLCB0b2dnbGUsIG9wZW4sIG9uT3BlbkNoYW5nZV0pO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBldmVudC50YXJnZXQgaXMgd2l0aGluIHRoZSBwcm92aWRlZCBub2RlLiBVc2VzIGV2ZW50LmNvbXBvc2VkUGF0aCBpZiBhdmFpbGFibGUgZm9yIGN1c3RvbSBlbGVtZW50IHN1cHBvcnQuXG4gKlxuICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCB3aG9zZSB0YXJnZXQvY29tcG9zZWRQYXRoIHRvIGNoZWNrXG4gKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byBjaGVjayBhZ2FpbnN0XG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBldmVudC50YXJnZXQvY29tcG9zZWRQYXRoIGlzIHdpdGhpbiB0aGUgbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNFdmVudFRhcmdldFdpdGhpbihldmVudCwgbm9kZSkge1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgnY29tcG9zZWRQYXRoJyBpbiBldmVudCkge1xuICAgIHJldHVybiBldmVudC5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyhub2RlKTtcbiAgfVxuXG4gIC8vIFRTIHRoaW5rcyBgZXZlbnRgIGlzIG9mIHR5cGUgbmV2ZXIgYXMgaXQgYXNzdW1lcyBhbGwgYnJvd3NlcnMgc3VwcG9ydCBjb21wb3NlZFBhdGgsIGJ1dCBicm93c2VycyB3aXRob3V0IHNoYWRvdyBkb20gZG9uJ3RcbiAgY29uc3QgZSA9IGV2ZW50O1xuICByZXR1cm4gZS50YXJnZXQgIT0gbnVsbCAmJiBub2RlLmNvbnRhaW5zKGUudGFyZ2V0KTtcbn1cblxuY29uc3QgYnViYmxlSGFuZGxlcktleXMgPSB7XG4gIHBvaW50ZXJkb3duOiAnb25Qb2ludGVyRG93bicsXG4gIG1vdXNlZG93bjogJ29uTW91c2VEb3duJyxcbiAgY2xpY2s6ICdvbkNsaWNrJ1xufTtcbmNvbnN0IGNhcHR1cmVIYW5kbGVyS2V5cyA9IHtcbiAgcG9pbnRlcmRvd246ICdvblBvaW50ZXJEb3duQ2FwdHVyZScsXG4gIG1vdXNlZG93bjogJ29uTW91c2VEb3duQ2FwdHVyZScsXG4gIGNsaWNrOiAnb25DbGlja0NhcHR1cmUnXG59O1xuY29uc3Qgbm9ybWFsaXplQnViYmxlc1Byb3AgPSBmdW5jdGlvbiAoYnViYmxlcykge1xuICB2YXIgX2J1YmJsZXMkZXNjYXBlS2V5LCBfYnViYmxlcyRvdXRzaWRlUHJlc3M7XG4gIGlmIChidWJibGVzID09PSB2b2lkIDApIHtcbiAgICBidWJibGVzID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGVzY2FwZUtleUJ1YmJsZXM6IHR5cGVvZiBidWJibGVzID09PSAnYm9vbGVhbicgPyBidWJibGVzIDogKF9idWJibGVzJGVzY2FwZUtleSA9IGJ1YmJsZXMuZXNjYXBlS2V5KSAhPSBudWxsID8gX2J1YmJsZXMkZXNjYXBlS2V5IDogdHJ1ZSxcbiAgICBvdXRzaWRlUHJlc3NCdWJibGVzOiB0eXBlb2YgYnViYmxlcyA9PT0gJ2Jvb2xlYW4nID8gYnViYmxlcyA6IChfYnViYmxlcyRvdXRzaWRlUHJlc3MgPSBidWJibGVzLm91dHNpZGVQcmVzcykgIT0gbnVsbCA/IF9idWJibGVzJG91dHNpZGVQcmVzcyA6IHRydWVcbiAgfTtcbn07XG4vKipcbiAqIEFkZHMgbGlzdGVuZXJzIHRoYXQgZGlzbWlzcyAoY2xvc2UpIHRoZSBmbG9hdGluZyBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZURpc21pc3NcbiAqL1xuY29uc3QgdXNlRGlzbWlzcyA9IGZ1bmN0aW9uIChfcmVmLCBfdGVtcCkge1xuICBsZXQge1xuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGV2ZW50cyxcbiAgICBub2RlSWQsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIHJlZmVyZW5jZSxcbiAgICAgIGRvbVJlZmVyZW5jZSxcbiAgICAgIGZsb2F0aW5nXG4gICAgfSxcbiAgICBkYXRhUmVmXG4gIH0gPSBfcmVmO1xuICBsZXQge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIGVzY2FwZUtleSA9IHRydWUsXG4gICAgb3V0c2lkZVByZXNzOiB1bnN0YWJsZV9vdXRzaWRlUHJlc3MgPSB0cnVlLFxuICAgIG91dHNpZGVQcmVzc0V2ZW50ID0gJ3BvaW50ZXJkb3duJyxcbiAgICByZWZlcmVuY2VQcmVzcyA9IGZhbHNlLFxuICAgIHJlZmVyZW5jZVByZXNzRXZlbnQgPSAncG9pbnRlcmRvd24nLFxuICAgIGFuY2VzdG9yU2Nyb2xsID0gZmFsc2UsXG4gICAgYnViYmxlcyA9IHRydWVcbiAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICBjb25zdCB0cmVlID0gdXNlRmxvYXRpbmdUcmVlKCk7XG4gIGNvbnN0IG5lc3RlZCA9IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkKCkgIT0gbnVsbDtcbiAgY29uc3Qgb3V0c2lkZVByZXNzRm4gPSB1c2VFdmVudCh0eXBlb2YgdW5zdGFibGVfb3V0c2lkZVByZXNzID09PSAnZnVuY3Rpb24nID8gdW5zdGFibGVfb3V0c2lkZVByZXNzIDogKCkgPT4gZmFsc2UpO1xuICBjb25zdCBvdXRzaWRlUHJlc3MgPSB0eXBlb2YgdW5zdGFibGVfb3V0c2lkZVByZXNzID09PSAnZnVuY3Rpb24nID8gb3V0c2lkZVByZXNzRm4gOiB1bnN0YWJsZV9vdXRzaWRlUHJlc3M7XG4gIGNvbnN0IGluc2lkZVJlYWN0VHJlZVJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHtcbiAgICBlc2NhcGVLZXlCdWJibGVzLFxuICAgIG91dHNpZGVQcmVzc0J1YmJsZXNcbiAgfSA9IG5vcm1hbGl6ZUJ1YmJsZXNQcm9wKGJ1YmJsZXMpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghb3BlbiB8fCAhZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkYXRhUmVmLmN1cnJlbnQuX19lc2NhcGVLZXlCdWJibGVzID0gZXNjYXBlS2V5QnViYmxlcztcbiAgICBkYXRhUmVmLmN1cnJlbnQuX19vdXRzaWRlUHJlc3NCdWJibGVzID0gb3V0c2lkZVByZXNzQnViYmxlcztcbiAgICBmdW5jdGlvbiBvbktleURvd24oZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdHJlZSA/IGdldENoaWxkcmVuKHRyZWUubm9kZXNSZWYuY3VycmVudCwgbm9kZUlkKSA6IFtdO1xuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxldCBzaG91bGREaXNtaXNzID0gdHJ1ZTtcbiAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgIHZhciBfY2hpbGQkY29udGV4dDtcbiAgICAgICAgICAgIGlmICgoX2NoaWxkJGNvbnRleHQgPSBjaGlsZC5jb250ZXh0KSAhPSBudWxsICYmIF9jaGlsZCRjb250ZXh0Lm9wZW4gJiYgIWNoaWxkLmNvbnRleHQuZGF0YVJlZi5jdXJyZW50Ll9fZXNjYXBlS2V5QnViYmxlcykge1xuICAgICAgICAgICAgICBzaG91bGREaXNtaXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIXNob3VsZERpc21pc3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRzLmVtaXQoJ2Rpc21pc3MnLCB7XG4gICAgICAgICAgdHlwZTogJ2VzY2FwZUtleScsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgcmV0dXJuRm9jdXM6IHtcbiAgICAgICAgICAgICAgcHJldmVudFNjcm9sbDogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbk91dHNpZGVQcmVzcyhldmVudCkge1xuICAgICAgLy8gR2l2ZW4gZGV2ZWxvcGVycyBjYW4gc3RvcCB0aGUgcHJvcGFnYXRpb24gb2YgdGhlIHN5bnRoZXRpYyBldmVudCxcbiAgICAgIC8vIHdlIGNhbiBvbmx5IGJlIGNvbmZpZGVudCB3aXRoIGEgcG9zaXRpdmUgdmFsdWUuXG4gICAgICBjb25zdCBpbnNpZGVSZWFjdFRyZWUgPSBpbnNpZGVSZWFjdFRyZWVSZWYuY3VycmVudDtcbiAgICAgIGluc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBpZiAoaW5zaWRlUmVhY3RUcmVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3V0c2lkZVByZXNzID09PSAnZnVuY3Rpb24nICYmICFvdXRzaWRlUHJlc3MoZXZlbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldChldmVudCk7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBjbGljayBvY2N1cnJlZCBvbiB0aGUgc2Nyb2xsYmFyXG4gICAgICBpZiAoaXNIVE1MRWxlbWVudCh0YXJnZXQpICYmIGZsb2F0aW5nKSB7XG4gICAgICAgIGNvbnN0IHdpbiA9IGZsb2F0aW5nLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgICAgICBjb25zdCBjYW5TY3JvbGxYID0gdGFyZ2V0LnNjcm9sbFdpZHRoID4gdGFyZ2V0LmNsaWVudFdpZHRoO1xuICAgICAgICBjb25zdCBjYW5TY3JvbGxZID0gdGFyZ2V0LnNjcm9sbEhlaWdodCA+IHRhcmdldC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGxldCB4Q29uZCA9IGNhblNjcm9sbFkgJiYgZXZlbnQub2Zmc2V0WCA+IHRhcmdldC5jbGllbnRXaWR0aDtcblxuICAgICAgICAvLyBJbiBzb21lIGJyb3dzZXJzIGl0IGlzIHBvc3NpYmxlIHRvIGNoYW5nZSB0aGUgPGJvZHk+IChvciB3aW5kb3cpXG4gICAgICAgIC8vIHNjcm9sbGJhciB0byB0aGUgbGVmdCBzaWRlLCBidXQgaXMgdmVyeSByYXJlIGFuZCBpcyBkaWZmaWN1bHQgdG9cbiAgICAgICAgLy8gY2hlY2sgZm9yLiBQbHVzLCBmb3IgbW9kYWwgZGlhbG9ncyB3aXRoIGJhY2tkcm9wcywgaXQgaXMgbW9yZVxuICAgICAgICAvLyBpbXBvcnRhbnQgdGhhdCB0aGUgYmFja2Ryb3AgaXMgY2hlY2tlZCBidXQgbm90IHNvIG11Y2ggdGhlIHdpbmRvdy5cbiAgICAgICAgaWYgKGNhblNjcm9sbFkpIHtcbiAgICAgICAgICBjb25zdCBpc1JUTCA9IHdpbi5nZXRDb21wdXRlZFN0eWxlKHRhcmdldCkuZGlyZWN0aW9uID09PSAncnRsJztcbiAgICAgICAgICBpZiAoaXNSVEwpIHtcbiAgICAgICAgICAgIHhDb25kID0gZXZlbnQub2Zmc2V0WCA8PSB0YXJnZXQub2Zmc2V0V2lkdGggLSB0YXJnZXQuY2xpZW50V2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh4Q29uZCB8fCBjYW5TY3JvbGxYICYmIGV2ZW50Lm9mZnNldFkgPiB0YXJnZXQuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB0YXJnZXRJc0luc2lkZUNoaWxkcmVuID0gdHJlZSAmJiBnZXRDaGlsZHJlbih0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIG5vZGVJZCkuc29tZShub2RlID0+IHtcbiAgICAgICAgdmFyIF9ub2RlJGNvbnRleHQ7XG4gICAgICAgIHJldHVybiBpc0V2ZW50VGFyZ2V0V2l0aGluKGV2ZW50LCAoX25vZGUkY29udGV4dCA9IG5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGNvbnRleHQuZWxlbWVudHMuZmxvYXRpbmcpO1xuICAgICAgfSk7XG4gICAgICBpZiAoaXNFdmVudFRhcmdldFdpdGhpbihldmVudCwgZmxvYXRpbmcpIHx8IGlzRXZlbnRUYXJnZXRXaXRoaW4oZXZlbnQsIGRvbVJlZmVyZW5jZSkgfHwgdGFyZ2V0SXNJbnNpZGVDaGlsZHJlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHRyZWUgPyBnZXRDaGlsZHJlbih0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIG5vZGVJZCkgOiBbXTtcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBzaG91bGREaXNtaXNzID0gdHJ1ZTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgdmFyIF9jaGlsZCRjb250ZXh0MjtcbiAgICAgICAgICBpZiAoKF9jaGlsZCRjb250ZXh0MiA9IGNoaWxkLmNvbnRleHQpICE9IG51bGwgJiYgX2NoaWxkJGNvbnRleHQyLm9wZW4gJiYgIWNoaWxkLmNvbnRleHQuZGF0YVJlZi5jdXJyZW50Ll9fb3V0c2lkZVByZXNzQnViYmxlcykge1xuICAgICAgICAgICAgc2hvdWxkRGlzbWlzcyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghc2hvdWxkRGlzbWlzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZXZlbnRzLmVtaXQoJ2Rpc21pc3MnLCB7XG4gICAgICAgIHR5cGU6ICdvdXRzaWRlUHJlc3MnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcmV0dXJuRm9jdXM6IG5lc3RlZCA/IHtcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgICAgICB9IDogaXNWaXJ0dWFsQ2xpY2soZXZlbnQpIHx8IGlzVmlydHVhbFBvaW50ZXJFdmVudChldmVudClcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblNjcm9sbCgpIHtcbiAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSk7XG4gICAgfVxuICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KGZsb2F0aW5nKTtcbiAgICBlc2NhcGVLZXkgJiYgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbktleURvd24pO1xuICAgIG91dHNpZGVQcmVzcyAmJiBkb2MuYWRkRXZlbnRMaXN0ZW5lcihvdXRzaWRlUHJlc3NFdmVudCwgb25PdXRzaWRlUHJlc3MpO1xuICAgIGxldCBhbmNlc3RvcnMgPSBbXTtcbiAgICBpZiAoYW5jZXN0b3JTY3JvbGwpIHtcbiAgICAgIGlmIChpc0VsZW1lbnQoZG9tUmVmZXJlbmNlKSkge1xuICAgICAgICBhbmNlc3RvcnMgPSBnZXRPdmVyZmxvd0FuY2VzdG9ycyhkb21SZWZlcmVuY2UpO1xuICAgICAgfVxuICAgICAgaWYgKGlzRWxlbWVudChmbG9hdGluZykpIHtcbiAgICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLmNvbmNhdChnZXRPdmVyZmxvd0FuY2VzdG9ycyhmbG9hdGluZykpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0VsZW1lbnQocmVmZXJlbmNlKSAmJiByZWZlcmVuY2UgJiYgcmVmZXJlbmNlLmNvbnRleHRFbGVtZW50KSB7XG4gICAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycy5jb25jYXQoZ2V0T3ZlcmZsb3dBbmNlc3RvcnMocmVmZXJlbmNlLmNvbnRleHRFbGVtZW50KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWdub3JlIHRoZSB2aXN1YWwgdmlld3BvcnQgZm9yIHNjcm9sbGluZyBkaXNtaXNzYWwgKGFsbG93IHBpbmNoLXpvb20pXG4gICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLmZpbHRlcihhbmNlc3RvciA9PiB7XG4gICAgICB2YXIgX2RvYyRkZWZhdWx0VmlldztcbiAgICAgIHJldHVybiBhbmNlc3RvciAhPT0gKChfZG9jJGRlZmF1bHRWaWV3ID0gZG9jLmRlZmF1bHRWaWV3KSA9PSBudWxsID8gdm9pZCAwIDogX2RvYyRkZWZhdWx0Vmlldy52aXN1YWxWaWV3cG9ydCk7XG4gICAgfSk7XG4gICAgYW5jZXN0b3JzLmZvckVhY2goYW5jZXN0b3IgPT4ge1xuICAgICAgYW5jZXN0b3IuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25TY3JvbGwsIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGVzY2FwZUtleSAmJiBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIG9uS2V5RG93bik7XG4gICAgICBvdXRzaWRlUHJlc3MgJiYgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIob3V0c2lkZVByZXNzRXZlbnQsIG9uT3V0c2lkZVByZXNzKTtcbiAgICAgIGFuY2VzdG9ycy5mb3JFYWNoKGFuY2VzdG9yID0+IHtcbiAgICAgICAgYW5jZXN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25TY3JvbGwpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSwgW2RhdGFSZWYsIGZsb2F0aW5nLCBkb21SZWZlcmVuY2UsIHJlZmVyZW5jZSwgZXNjYXBlS2V5LCBvdXRzaWRlUHJlc3MsIG91dHNpZGVQcmVzc0V2ZW50LCBldmVudHMsIHRyZWUsIG5vZGVJZCwgb3Blbiwgb25PcGVuQ2hhbmdlLCBhbmNlc3RvclNjcm9sbCwgZW5hYmxlZCwgZXNjYXBlS2V5QnViYmxlcywgb3V0c2lkZVByZXNzQnViYmxlcywgbmVzdGVkXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaW5zaWRlUmVhY3RUcmVlUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgfSwgW291dHNpZGVQcmVzcywgb3V0c2lkZVByZXNzRXZlbnRdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgIFtidWJibGVIYW5kbGVyS2V5c1tyZWZlcmVuY2VQcmVzc0V2ZW50XV06ICgpID0+IHtcbiAgICAgICAgICBpZiAocmVmZXJlbmNlUHJlc3MpIHtcbiAgICAgICAgICAgIGV2ZW50cy5lbWl0KCdkaXNtaXNzJywge1xuICAgICAgICAgICAgICB0eXBlOiAncmVmZXJlbmNlUHJlc3MnLFxuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuRm9jdXM6IGZhbHNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmbG9hdGluZzoge1xuICAgICAgICBbY2FwdHVyZUhhbmRsZXJLZXlzW291dHNpZGVQcmVzc0V2ZW50XV06ICgpID0+IHtcbiAgICAgICAgICBpbnNpZGVSZWFjdFRyZWVSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgZXZlbnRzLCByZWZlcmVuY2VQcmVzcywgb3V0c2lkZVByZXNzRXZlbnQsIHJlZmVyZW5jZVByZXNzRXZlbnQsIG9uT3BlbkNoYW5nZV0pO1xufTtcblxuLyoqXG4gKiBBZGRzIGZvY3VzIGV2ZW50IGxpc3RlbmVycyB0aGF0IGNoYW5nZSB0aGUgb3BlbiBzdGF0ZSwgbGlrZSBDU1MgOmZvY3VzLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUZvY3VzXG4gKi9cbmNvbnN0IHVzZUZvY3VzID0gZnVuY3Rpb24gKF9yZWYsIF90ZW1wKSB7XG4gIGxldCB7XG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgZGF0YVJlZixcbiAgICBldmVudHMsXG4gICAgcmVmcyxcbiAgICBlbGVtZW50czoge1xuICAgICAgZmxvYXRpbmcsXG4gICAgICBkb21SZWZlcmVuY2VcbiAgICB9XG4gIH0gPSBfcmVmO1xuICBsZXQge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIGtleWJvYXJkT25seSA9IHRydWVcbiAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICBjb25zdCBwb2ludGVyVHlwZVJlZiA9IFJlYWN0LnVzZVJlZignJyk7XG4gIGNvbnN0IGJsb2NrRm9jdXNSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCB0aW1lb3V0UmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KGZsb2F0aW5nKTtcbiAgICBjb25zdCB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuXG4gICAgLy8gSWYgdGhlIHJlZmVyZW5jZSB3YXMgZm9jdXNlZCBhbmQgdGhlIHVzZXIgbGVmdCB0aGUgdGFiL3dpbmRvdywgYW5kIHRoZVxuICAgIC8vIGZsb2F0aW5nIGVsZW1lbnQgd2FzIG5vdCBvcGVuLCB0aGUgZm9jdXMgc2hvdWxkIGJlIGJsb2NrZWQgd2hlbiB0aGV5XG4gICAgLy8gcmV0dXJuIHRvIHRoZSB0YWIvd2luZG93LlxuICAgIGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICAgIGlmICghb3BlbiAmJiBpc0hUTUxFbGVtZW50KGRvbVJlZmVyZW5jZSkgJiYgZG9tUmVmZXJlbmNlID09PSBhY3RpdmVFbGVtZW50JDEoZ2V0RG9jdW1lbnQoZG9tUmVmZXJlbmNlKSkpIHtcbiAgICAgICAgYmxvY2tGb2N1c1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBvbkJsdXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIG9uQmx1cik7XG4gICAgfTtcbiAgfSwgW2Zsb2F0aW5nLCBkb21SZWZlcmVuY2UsIG9wZW4sIGVuYWJsZWRdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25EaXNtaXNzKHBheWxvYWQpIHtcbiAgICAgIGlmIChwYXlsb2FkLnR5cGUgPT09ICdyZWZlcmVuY2VQcmVzcycgfHwgcGF5bG9hZC50eXBlID09PSAnZXNjYXBlS2V5Jykge1xuICAgICAgICBibG9ja0ZvY3VzUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBldmVudHMub24oJ2Rpc21pc3MnLCBvbkRpc21pc3MpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBldmVudHMub2ZmKCdkaXNtaXNzJywgb25EaXNtaXNzKTtcbiAgICB9O1xuICB9LCBbZXZlbnRzLCBlbmFibGVkXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgIG9uUG9pbnRlckRvd24oX3JlZjIpIHtcbiAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgcG9pbnRlclR5cGVcbiAgICAgICAgICB9ID0gX3JlZjI7XG4gICAgICAgICAgcG9pbnRlclR5cGVSZWYuY3VycmVudCA9IHBvaW50ZXJUeXBlO1xuICAgICAgICAgIGJsb2NrRm9jdXNSZWYuY3VycmVudCA9ICEhKHBvaW50ZXJUeXBlICYmIGtleWJvYXJkT25seSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VMZWF2ZSgpIHtcbiAgICAgICAgICBibG9ja0ZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Gb2N1cyhldmVudCkge1xuICAgICAgICAgIHZhciBfZGF0YVJlZiRjdXJyZW50JG9wZW47XG4gICAgICAgICAgaWYgKGJsb2NrRm9jdXNSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERpc21pc3Mgd2l0aCBjbGljayBzaG91bGQgaWdub3JlIHRoZSBzdWJzZXF1ZW50IGBmb2N1c2AgdHJpZ2dlcixcbiAgICAgICAgICAvLyBidXQgb25seSBpZiB0aGUgY2xpY2sgb3JpZ2luYXRlZCBpbnNpZGUgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAnZm9jdXMnICYmICgoX2RhdGFSZWYkY3VycmVudCRvcGVuID0gZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhUmVmJGN1cnJlbnQkb3Blbi50eXBlKSA9PT0gJ21vdXNlZG93bicgJiYgZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCAmJiBpc0V2ZW50VGFyZ2V0V2l0aGluKGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQsIGRvbVJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCA9IGV2ZW50Lm5hdGl2ZUV2ZW50O1xuICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25CbHVyKGV2ZW50KSB7XG4gICAgICAgICAgYmxvY2tGb2N1c1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG5cbiAgICAgICAgICAvLyBIaXQgdGhlIG5vbi1tb2RhbCBmb2N1cyBtYW5hZ2VtZW50IHBvcnRhbCBndWFyZC4gRm9jdXMgd2lsbCBiZVxuICAgICAgICAgIC8vIG1vdmVkIGludG8gdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW1tZWRpYXRlbHkgYWZ0ZXIuXG4gICAgICAgICAgY29uc3QgbW92ZWRUb0ZvY3VzR3VhcmQgPSBpc0VsZW1lbnQocmVsYXRlZFRhcmdldCkgJiYgcmVsYXRlZFRhcmdldC5oYXNBdHRyaWJ1dGUoJ2RhdGEtZmxvYXRpbmctdWktZm9jdXMtZ3VhcmQnKSAmJiByZWxhdGVkVGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS10eXBlJykgPT09ICdvdXRzaWRlJztcblxuICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSB3aW5kb3cgYmx1ciBsaXN0ZW5lciB0byBmaXJlLlxuICAgICAgICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgLy8gV2hlbiBmb2N1c2luZyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgKGUuZy4gcmVndWxhciBjbGljayksIHRoZW5cbiAgICAgICAgICAgIC8vIGNsaWNraW5nIGludG8gdGhlIGZsb2F0aW5nIGVsZW1lbnQsIHByZXZlbnQgaXQgZnJvbSBoaWRpbmcuXG4gICAgICAgICAgICAvLyBOb3RlOiBpdCBtdXN0IGJlIGZvY3VzYWJsZSwgZS5nLiBgdGFiaW5kZXg9XCItMVwiYC5cbiAgICAgICAgICAgIGlmIChjb250YWlucyhyZWZzLmZsb2F0aW5nLmN1cnJlbnQsIHJlbGF0ZWRUYXJnZXQpIHx8IGNvbnRhaW5zKGRvbVJlZmVyZW5jZSwgcmVsYXRlZFRhcmdldCkgfHwgbW92ZWRUb0ZvY3VzR3VhcmQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtlbmFibGVkLCBrZXlib2FyZE9ubHksIGRvbVJlZmVyZW5jZSwgcmVmcywgZGF0YVJlZiwgb25PcGVuQ2hhbmdlXSk7XG59O1xuXG5sZXQgaXNQcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gZmFsc2U7XG5jb25zdCBBUlJPV19VUCA9ICdBcnJvd1VwJztcbmNvbnN0IEFSUk9XX0RPV04gPSAnQXJyb3dEb3duJztcbmNvbnN0IEFSUk9XX0xFRlQgPSAnQXJyb3dMZWZ0JztcbmNvbnN0IEFSUk9XX1JJR0hUID0gJ0Fycm93UmlnaHQnO1xuZnVuY3Rpb24gaXNEaWZmZXJlbnRSb3coaW5kZXgsIGNvbHMsIHByZXZSb3cpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoaW5kZXggLyBjb2xzKSAhPT0gcHJldlJvdztcbn1cbmZ1bmN0aW9uIGlzSW5kZXhPdXRPZkJvdW5kcyhsaXN0UmVmLCBpbmRleCkge1xuICByZXR1cm4gaW5kZXggPCAwIHx8IGluZGV4ID49IGxpc3RSZWYuY3VycmVudC5sZW5ndGg7XG59XG5mdW5jdGlvbiBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCBfdGVtcCkge1xuICBsZXQge1xuICAgIHN0YXJ0aW5nSW5kZXggPSAtMSxcbiAgICBkZWNyZW1lbnQgPSBmYWxzZSxcbiAgICBkaXNhYmxlZEluZGljZXMsXG4gICAgYW1vdW50ID0gMVxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGNvbnN0IGxpc3QgPSBsaXN0UmVmLmN1cnJlbnQ7XG4gIGxldCBpbmRleCA9IHN0YXJ0aW5nSW5kZXg7XG4gIGRvIHtcbiAgICB2YXIgX2xpc3QkaW5kZXgsIF9saXN0JGluZGV4MjtcbiAgICBpbmRleCA9IGluZGV4ICsgKGRlY3JlbWVudCA/IC1hbW91bnQgOiBhbW91bnQpO1xuICB9IHdoaWxlIChpbmRleCA+PSAwICYmIGluZGV4IDw9IGxpc3QubGVuZ3RoIC0gMSAmJiAoZGlzYWJsZWRJbmRpY2VzID8gZGlzYWJsZWRJbmRpY2VzLmluY2x1ZGVzKGluZGV4KSA6IGxpc3RbaW5kZXhdID09IG51bGwgfHwgKChfbGlzdCRpbmRleCA9IGxpc3RbaW5kZXhdKSA9PSBudWxsID8gdm9pZCAwIDogX2xpc3QkaW5kZXguaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpKSB8fCAoKF9saXN0JGluZGV4MiA9IGxpc3RbaW5kZXhdKSA9PSBudWxsID8gdm9pZCAwIDogX2xpc3QkaW5kZXgyLmdldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcpKSA9PT0gJ3RydWUnKSk7XG4gIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIGRvU3dpdGNoKG9yaWVudGF0aW9uLCB2ZXJ0aWNhbCwgaG9yaXpvbnRhbCkge1xuICBzd2l0Y2ggKG9yaWVudGF0aW9uKSB7XG4gICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgcmV0dXJuIHZlcnRpY2FsO1xuICAgIGNhc2UgJ2hvcml6b250YWwnOlxuICAgICAgcmV0dXJuIGhvcml6b250YWw7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB2ZXJ0aWNhbCB8fCBob3Jpem9udGFsO1xuICB9XG59XG5mdW5jdGlvbiBpc01haW5PcmllbnRhdGlvbktleShrZXksIG9yaWVudGF0aW9uKSB7XG4gIGNvbnN0IHZlcnRpY2FsID0ga2V5ID09PSBBUlJPV19VUCB8fCBrZXkgPT09IEFSUk9XX0RPV047XG4gIGNvbnN0IGhvcml6b250YWwgPSBrZXkgPT09IEFSUk9XX0xFRlQgfHwga2V5ID09PSBBUlJPV19SSUdIVDtcbiAgcmV0dXJuIGRvU3dpdGNoKG9yaWVudGF0aW9uLCB2ZXJ0aWNhbCwgaG9yaXpvbnRhbCk7XG59XG5mdW5jdGlvbiBpc01haW5PcmllbnRhdGlvblRvRW5kS2V5KGtleSwgb3JpZW50YXRpb24sIHJ0bCkge1xuICBjb25zdCB2ZXJ0aWNhbCA9IGtleSA9PT0gQVJST1dfRE9XTjtcbiAgY29uc3QgaG9yaXpvbnRhbCA9IHJ0bCA/IGtleSA9PT0gQVJST1dfTEVGVCA6IGtleSA9PT0gQVJST1dfUklHSFQ7XG4gIHJldHVybiBkb1N3aXRjaChvcmllbnRhdGlvbiwgdmVydGljYWwsIGhvcml6b250YWwpIHx8IGtleSA9PT0gJ0VudGVyJyB8fCBrZXkgPT0gJyAnIHx8IGtleSA9PT0gJyc7XG59XG5mdW5jdGlvbiBpc0Nyb3NzT3JpZW50YXRpb25PcGVuS2V5KGtleSwgb3JpZW50YXRpb24sIHJ0bCkge1xuICBjb25zdCB2ZXJ0aWNhbCA9IHJ0bCA/IGtleSA9PT0gQVJST1dfTEVGVCA6IGtleSA9PT0gQVJST1dfUklHSFQ7XG4gIGNvbnN0IGhvcml6b250YWwgPSBrZXkgPT09IEFSUk9XX0RPV047XG4gIHJldHVybiBkb1N3aXRjaChvcmllbnRhdGlvbiwgdmVydGljYWwsIGhvcml6b250YWwpO1xufVxuZnVuY3Rpb24gaXNDcm9zc09yaWVudGF0aW9uQ2xvc2VLZXkoa2V5LCBvcmllbnRhdGlvbiwgcnRsKSB7XG4gIGNvbnN0IHZlcnRpY2FsID0gcnRsID8ga2V5ID09PSBBUlJPV19SSUdIVCA6IGtleSA9PT0gQVJST1dfTEVGVDtcbiAgY29uc3QgaG9yaXpvbnRhbCA9IGtleSA9PT0gQVJST1dfVVA7XG4gIHJldHVybiBkb1N3aXRjaChvcmllbnRhdGlvbiwgdmVydGljYWwsIGhvcml6b250YWwpO1xufVxuZnVuY3Rpb24gZ2V0TWluSW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzKSB7XG4gIHJldHVybiBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCB7XG4gICAgZGlzYWJsZWRJbmRpY2VzXG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0TWF4SW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzKSB7XG4gIHJldHVybiBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCB7XG4gICAgZGVjcmVtZW50OiB0cnVlLFxuICAgIHN0YXJ0aW5nSW5kZXg6IGxpc3RSZWYuY3VycmVudC5sZW5ndGgsXG4gICAgZGlzYWJsZWRJbmRpY2VzXG4gIH0pO1xufVxuLyoqXG4gKiBBZGRzIGZvY3VzLW1hbmFnZWQgaW5kZXhlZCBuYXZpZ2F0aW9uIHZpYSBhcnJvdyBrZXlzIHRvIGEgbGlzdCBvZiBpdGVtc1xuICogd2l0aGluIHRoZSBmbG9hdGluZyBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUxpc3ROYXZpZ2F0aW9uXG4gKi9cbmNvbnN0IHVzZUxpc3ROYXZpZ2F0aW9uID0gZnVuY3Rpb24gKF9yZWYsIF90ZW1wMikge1xuICBsZXQge1xuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIHJlZnMsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIGRvbVJlZmVyZW5jZVxuICAgIH1cbiAgfSA9IF9yZWY7XG4gIGxldCB7XG4gICAgbGlzdFJlZixcbiAgICBhY3RpdmVJbmRleCxcbiAgICBvbk5hdmlnYXRlOiB1bnN0YWJsZV9vbk5hdmlnYXRlID0gKCkgPT4ge30sXG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgc2VsZWN0ZWRJbmRleCA9IG51bGwsXG4gICAgYWxsb3dFc2NhcGUgPSBmYWxzZSxcbiAgICBsb29wID0gZmFsc2UsXG4gICAgbmVzdGVkID0gZmFsc2UsXG4gICAgcnRsID0gZmFsc2UsXG4gICAgdmlydHVhbCA9IGZhbHNlLFxuICAgIGZvY3VzSXRlbU9uT3BlbiA9ICdhdXRvJyxcbiAgICBmb2N1c0l0ZW1PbkhvdmVyID0gdHJ1ZSxcbiAgICBvcGVuT25BcnJvd0tleURvd24gPSB0cnVlLFxuICAgIGRpc2FibGVkSW5kaWNlcyA9IHVuZGVmaW5lZCxcbiAgICBvcmllbnRhdGlvbiA9ICd2ZXJ0aWNhbCcsXG4gICAgY29scyA9IDEsXG4gICAgc2Nyb2xsSXRlbUludG9WaWV3ID0gdHJ1ZVxuICB9ID0gX3RlbXAyID09PSB2b2lkIDAgPyB7XG4gICAgbGlzdFJlZjoge1xuICAgICAgY3VycmVudDogW11cbiAgICB9LFxuICAgIGFjdGl2ZUluZGV4OiBudWxsLFxuICAgIG9uTmF2aWdhdGU6ICgpID0+IHt9XG4gIH0gOiBfdGVtcDI7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoYWxsb3dFc2NhcGUpIHtcbiAgICAgIGlmICghbG9vcCkge1xuICAgICAgICBjb25zb2xlLndhcm4oWydGbG9hdGluZyBVSTogYHVzZUxpc3ROYXZpZ2F0aW9uYCBsb29waW5nIG11c3QgYmUgZW5hYmxlZCB0byBhbGxvdycsICdlc2NhcGluZy4nXS5qb2luKCcgJykpO1xuICAgICAgfVxuICAgICAgaWYgKCF2aXJ0dWFsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihbJ0Zsb2F0aW5nIFVJOiBgdXNlTGlzdE5hdmlnYXRpb25gIG11c3QgYmUgdmlydHVhbCB0byBhbGxvdycsICdlc2NhcGluZy4nXS5qb2luKCcgJykpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgJiYgY29scyA+IDEpIHtcbiAgICAgIGNvbnNvbGUud2FybihbJ0Zsb2F0aW5nIFVJOiBJbiBncmlkIGxpc3QgbmF2aWdhdGlvbiBtb2RlIChgY29sc2AgPiAxKSwgdGhlJywgJ2BvcmllbnRhdGlvbmAgc2hvdWxkIGJlIGVpdGhlciBcImhvcml6b250YWxcIiBvciBcImJvdGhcIi4nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfVxuICBjb25zdCBwYXJlbnRJZCA9IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkKCk7XG4gIGNvbnN0IHRyZWUgPSB1c2VGbG9hdGluZ1RyZWUoKTtcbiAgY29uc3Qgb25OYXZpZ2F0ZSA9IHVzZUV2ZW50KHVuc3RhYmxlX29uTmF2aWdhdGUpO1xuICBjb25zdCBmb2N1c0l0ZW1Pbk9wZW5SZWYgPSBSZWFjdC51c2VSZWYoZm9jdXNJdGVtT25PcGVuKTtcbiAgY29uc3QgaW5kZXhSZWYgPSBSZWFjdC51c2VSZWYoc2VsZWN0ZWRJbmRleCAhPSBudWxsID8gc2VsZWN0ZWRJbmRleCA6IC0xKTtcbiAgY29uc3Qga2V5UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBpc1BvaW50ZXJNb2RhbGl0eVJlZiA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgY29uc3QgcHJldmlvdXNPbk5hdmlnYXRlUmVmID0gUmVhY3QudXNlUmVmKG9uTmF2aWdhdGUpO1xuICBjb25zdCBwcmV2aW91c09wZW5SZWYgPSBSZWFjdC51c2VSZWYob3Blbik7XG4gIGNvbnN0IGZvcmNlU3luY0ZvY3VzID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgZm9yY2VTY3JvbGxJbnRvVmlld1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGRpc2FibGVkSW5kaWNlc1JlZiA9IHVzZUxhdGVzdFJlZihkaXNhYmxlZEluZGljZXMpO1xuICBjb25zdCBsYXRlc3RPcGVuUmVmID0gdXNlTGF0ZXN0UmVmKG9wZW4pO1xuICBjb25zdCBzY3JvbGxJdGVtSW50b1ZpZXdSZWYgPSB1c2VMYXRlc3RSZWYoc2Nyb2xsSXRlbUludG9WaWV3KTtcbiAgY29uc3QgW2FjdGl2ZUlkLCBzZXRBY3RpdmVJZF0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICBjb25zdCBmb2N1c0l0ZW0gPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAobGlzdFJlZiwgaW5kZXhSZWYsIGZvcmNlU2Nyb2xsSW50b1ZpZXcpIHtcbiAgICBpZiAoZm9yY2VTY3JvbGxJbnRvVmlldyA9PT0gdm9pZCAwKSB7XG4gICAgICBmb3JjZVNjcm9sbEludG9WaWV3ID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSBsaXN0UmVmLmN1cnJlbnRbaW5kZXhSZWYuY3VycmVudF07XG4gICAgaWYgKHZpcnR1YWwpIHtcbiAgICAgIHNldEFjdGl2ZUlkKGl0ZW0gPT0gbnVsbCA/IHZvaWQgMCA6IGl0ZW0uaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnF1ZXVlRm9jdXMoaXRlbSwge1xuICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlLFxuICAgICAgICAvLyBNYWMgU2FmYXJpIGRvZXMgbm90IG1vdmUgdGhlIHZpcnR1YWwgY3Vyc29yIHVubGVzcyB0aGUgZm9jdXMgY2FsbFxuICAgICAgICAvLyBpcyBzeW5jLiBIb3dldmVyLCBmb3IgdGhlIHZlcnkgZmlyc3QgZm9jdXMgY2FsbCwgd2UgbmVlZCB0byB3YWl0XG4gICAgICAgIC8vIGZvciB0aGUgcG9zaXRpb24gdG8gYmUgcmVhZHkgaW4gb3JkZXIgdG8gcHJldmVudCB1bndhbnRlZFxuICAgICAgICAvLyBzY3JvbGxpbmcuIFRoaXMgbWVhbnMgdGhlIHZpcnR1YWwgY3Vyc29yIHdpbGwgbm90IG1vdmUgdG8gdGhlIGZpcnN0XG4gICAgICAgIC8vIGl0ZW0gd2hlbiBmaXJzdCBvcGVuaW5nIHRoZSBmbG9hdGluZyBlbGVtZW50LCBidXQgd2lsbCBvblxuICAgICAgICAvLyBzdWJzZXF1ZW50IGNhbGxzLiBgcHJldmVudFNjcm9sbGAgaXMgc3VwcG9ydGVkIGluIG1vZGVybiBTYWZhcmksXG4gICAgICAgIC8vIHNvIHdlIGNhbiB1c2UgdGhhdCBpbnN0ZWFkLlxuICAgICAgICAvLyBpT1MgU2FmYXJpIG11c3QgYmUgYXN5bmMgb3IgdGhlIGZpcnN0IGl0ZW0gd2lsbCBub3QgYmUgZm9jdXNlZC5cbiAgICAgICAgc3luYzogaXNNYWMoKSAmJiBpc1NhZmFyaSgpID8gaXNQcmV2ZW50U2Nyb2xsU3VwcG9ydGVkIHx8IGZvcmNlU3luY0ZvY3VzLmN1cnJlbnQgOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBjb25zdCBzY3JvbGxJbnRvVmlld09wdGlvbnMgPSBzY3JvbGxJdGVtSW50b1ZpZXdSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IHNob3VsZFNjcm9sbEludG9WaWV3ID0gc2Nyb2xsSW50b1ZpZXdPcHRpb25zICYmIGl0ZW0gJiYgKGZvcmNlU2Nyb2xsSW50b1ZpZXcgfHwgIWlzUG9pbnRlck1vZGFsaXR5UmVmLmN1cnJlbnQpO1xuICAgICAgaWYgKHNob3VsZFNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgIC8vIEpTRE9NIGRvZXNuJ3Qgc3VwcG9ydCBgLnNjcm9sbEludG9WaWV3KClgIGJ1dCBpdCdzIHdpZGVseSBzdXBwb3J0ZWRcbiAgICAgICAgLy8gYnkgYWxsIGJyb3dzZXJzLlxuICAgICAgICBpdGVtLnNjcm9sbEludG9WaWV3ID09IG51bGwgPyB2b2lkIDAgOiBpdGVtLnNjcm9sbEludG9WaWV3KHR5cGVvZiBzY3JvbGxJbnRvVmlld09wdGlvbnMgPT09ICdib29sZWFuJyA/IHtcbiAgICAgICAgICBibG9jazogJ25lYXJlc3QnLFxuICAgICAgICAgIGlubGluZTogJ25lYXJlc3QnXG4gICAgICAgIH0gOiBzY3JvbGxJbnRvVmlld09wdGlvbnMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbdmlydHVhbCwgc2Nyb2xsSXRlbUludG9WaWV3UmVmXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5mb2N1cyh7XG4gICAgICBnZXQgcHJldmVudFNjcm9sbCgpIHtcbiAgICAgICAgaXNQcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbXSk7XG5cbiAgLy8gU3luYyBgc2VsZWN0ZWRJbmRleGAgdG8gYmUgdGhlIGBhY3RpdmVJbmRleGAgdXBvbiBvcGVuaW5nIHRoZSBmbG9hdGluZ1xuICAvLyBlbGVtZW50LiBBbHNvLCByZXNldCBgYWN0aXZlSW5kZXhgIHVwb24gY2xvc2luZyB0aGUgZmxvYXRpbmcgZWxlbWVudC5cbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3Blbikge1xuICAgICAgaWYgKGZvY3VzSXRlbU9uT3BlblJlZi5jdXJyZW50ICYmIHNlbGVjdGVkSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAvLyBSZWdhcmRsZXNzIG9mIHRoZSBwb2ludGVyIG1vZGFsaXR5LCB3ZSB3YW50IHRvIGVuc3VyZSB0aGUgc2VsZWN0ZWRcbiAgICAgICAgLy8gaXRlbSBjb21lcyBpbnRvIHZpZXcgd2hlbiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpcyBvcGVuZWQuXG4gICAgICAgIGZvcmNlU2Nyb2xsSW50b1ZpZXdSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIG9uTmF2aWdhdGUoc2VsZWN0ZWRJbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcmV2aW91c09wZW5SZWYuY3VycmVudCkge1xuICAgICAgLy8gU2luY2UgdGhlIHVzZXIgY2FuIHNwZWNpZnkgYG9uTmF2aWdhdGVgIGNvbmRpdGlvbmFsbHlcbiAgICAgIC8vIChvbk5hdmlnYXRlOiBvcGVuID8gc2V0QWN0aXZlSW5kZXggOiBzZXRTZWxlY3RlZEluZGV4KSxcbiAgICAgIC8vIHdlIHN0b3JlIGFuZCBjYWxsIHRoZSBwcmV2aW91cyBmdW5jdGlvbi5cbiAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSAtMTtcbiAgICAgIHByZXZpb3VzT25OYXZpZ2F0ZVJlZi5jdXJyZW50KG51bGwpO1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIG9wZW4sIHNlbGVjdGVkSW5kZXgsIG9uTmF2aWdhdGVdKTtcblxuICAvLyBTeW5jIGBhY3RpdmVJbmRleGAgdG8gYmUgdGhlIGZvY3VzZWQgaXRlbSB3aGlsZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBpc1xuICAvLyBvcGVuLlxuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvcGVuKSB7XG4gICAgICBpZiAoYWN0aXZlSW5kZXggPT0gbnVsbCkge1xuICAgICAgICBmb3JjZVN5bmNGb2N1cy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIGlmIChzZWxlY3RlZEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNldCB3aGlsZSB0aGUgZmxvYXRpbmcgZWxlbWVudCB3YXMgb3BlbiAoZS5nLiB0aGUgbGlzdCBjaGFuZ2VkKS5cbiAgICAgICAgaWYgKHByZXZpb3VzT3BlblJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IC0xO1xuICAgICAgICAgIGZvY3VzSXRlbShsaXN0UmVmLCBpbmRleFJlZik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbml0aWFsIHN5bmMuXG4gICAgICAgIGlmICghcHJldmlvdXNPcGVuUmVmLmN1cnJlbnQgJiYgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgJiYgKGtleVJlZi5jdXJyZW50ICE9IG51bGwgfHwgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgPT09IHRydWUgJiYga2V5UmVmLmN1cnJlbnQgPT0gbnVsbCkpIHtcbiAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0ga2V5UmVmLmN1cnJlbnQgPT0gbnVsbCB8fCBpc01haW5PcmllbnRhdGlvblRvRW5kS2V5KGtleVJlZi5jdXJyZW50LCBvcmllbnRhdGlvbiwgcnRsKSB8fCBuZXN0ZWQgPyBnZXRNaW5JbmRleChsaXN0UmVmLCBkaXNhYmxlZEluZGljZXNSZWYuY3VycmVudCkgOiBnZXRNYXhJbmRleChsaXN0UmVmLCBkaXNhYmxlZEluZGljZXNSZWYuY3VycmVudCk7XG4gICAgICAgICAgb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaXNJbmRleE91dE9mQm91bmRzKGxpc3RSZWYsIGFjdGl2ZUluZGV4KSkge1xuICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gYWN0aXZlSW5kZXg7XG4gICAgICAgIGZvY3VzSXRlbShsaXN0UmVmLCBpbmRleFJlZiwgZm9yY2VTY3JvbGxJbnRvVmlld1JlZi5jdXJyZW50KTtcbiAgICAgICAgZm9yY2VTY3JvbGxJbnRvVmlld1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgb3BlbiwgYWN0aXZlSW5kZXgsIHNlbGVjdGVkSW5kZXgsIG5lc3RlZCwgbGlzdFJlZiwgb3JpZW50YXRpb24sIHJ0bCwgb25OYXZpZ2F0ZSwgZm9jdXNJdGVtLCBkaXNhYmxlZEluZGljZXNSZWZdKTtcblxuICAvLyBFbnN1cmUgdGhlIHBhcmVudCBmbG9hdGluZyBlbGVtZW50IGhhcyBmb2N1cyB3aGVuIGEgbmVzdGVkIGNoaWxkIGNsb3Nlc1xuICAvLyB0byBhbGxvdyBhcnJvdyBrZXkgbmF2aWdhdGlvbiB0byB3b3JrIGFmdGVyIHRoZSBwb2ludGVyIGxlYXZlcyB0aGUgY2hpbGQuXG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByZXZpb3VzT3BlblJlZi5jdXJyZW50ICYmICFvcGVuKSB7XG4gICAgICB2YXIgX3RyZWUkbm9kZXNSZWYkY3VycmVuLCBfdHJlZSRub2Rlc1JlZiRjdXJyZW4yO1xuICAgICAgY29uc3QgcGFyZW50RmxvYXRpbmcgPSB0cmVlID09IG51bGwgPyB2b2lkIDAgOiAoX3RyZWUkbm9kZXNSZWYkY3VycmVuID0gdHJlZS5ub2Rlc1JlZi5jdXJyZW50LmZpbmQobm9kZSA9PiBub2RlLmlkID09PSBwYXJlbnRJZCkpID09IG51bGwgPyB2b2lkIDAgOiAoX3RyZWUkbm9kZXNSZWYkY3VycmVuMiA9IF90cmVlJG5vZGVzUmVmJGN1cnJlbi5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX3RyZWUkbm9kZXNSZWYkY3VycmVuMi5lbGVtZW50cy5mbG9hdGluZztcbiAgICAgIGlmIChwYXJlbnRGbG9hdGluZyAmJiAhY29udGFpbnMocGFyZW50RmxvYXRpbmcsIGFjdGl2ZUVsZW1lbnQkMShnZXREb2N1bWVudChwYXJlbnRGbG9hdGluZykpKSkge1xuICAgICAgICBwYXJlbnRGbG9hdGluZy5mb2N1cyh7XG4gICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuLCB0cmVlLCBwYXJlbnRJZF0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAga2V5UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIHByZXZpb3VzT25OYXZpZ2F0ZVJlZi5jdXJyZW50ID0gb25OYXZpZ2F0ZTtcbiAgICBwcmV2aW91c09wZW5SZWYuY3VycmVudCA9IG9wZW47XG4gIH0pO1xuICBjb25zdCBoYXNBY3RpdmVJbmRleCA9IGFjdGl2ZUluZGV4ICE9IG51bGw7XG4gIGNvbnN0IGl0ZW0gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBmdW5jdGlvbiBzeW5jQ3VycmVudFRhcmdldChjdXJyZW50VGFyZ2V0KSB7XG4gICAgICBpZiAoIW9wZW4pIHJldHVybjtcbiAgICAgIGNvbnN0IGluZGV4ID0gbGlzdFJlZi5jdXJyZW50LmluZGV4T2YoY3VycmVudFRhcmdldCk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIG9uTmF2aWdhdGUoaW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgIG9uRm9jdXMoX3JlZjIpIHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBjdXJyZW50VGFyZ2V0XG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgc3luY0N1cnJlbnRUYXJnZXQoY3VycmVudFRhcmdldCk7XG4gICAgICB9LFxuICAgICAgb25DbGljazogX3JlZjMgPT4ge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGN1cnJlbnRUYXJnZXRcbiAgICAgICAgfSA9IF9yZWYzO1xuICAgICAgICByZXR1cm4gY3VycmVudFRhcmdldC5mb2N1cyh7XG4gICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICAvLyBTYWZhcmlcbiAgICAgIC4uLihmb2N1c0l0ZW1PbkhvdmVyICYmIHtcbiAgICAgICAgb25Nb3VzZU1vdmUoX3JlZjQpIHtcbiAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgY3VycmVudFRhcmdldFxuICAgICAgICAgIH0gPSBfcmVmNDtcbiAgICAgICAgICBzeW5jQ3VycmVudFRhcmdldChjdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Qb2ludGVyTGVhdmUoKSB7XG4gICAgICAgICAgaWYgKCFpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSAtMTtcbiAgICAgICAgICBmb2N1c0l0ZW0obGlzdFJlZiwgaW5kZXhSZWYpO1xuXG4gICAgICAgICAgLy8gVmlydHVhbCBjdXJzb3Igd2l0aCBWb2ljZU92ZXIgb24gaU9TIG5lZWRzIHRoaXMgdG8gYmUgZmx1c2hlZFxuICAgICAgICAgIC8vIHN5bmNocm9ub3VzbHkgb3IgdGhlcmUgaXMgYSBnbGl0Y2ggdGhhdCBwcmV2ZW50cyBuZXN0ZWRcbiAgICAgICAgICAvLyBzdWJtZW51cyBmcm9tIGJlaW5nIGFjY2Vzc2libGUuXG4gICAgICAgICAgZmx1c2hTeW5jKCgpID0+IG9uTmF2aWdhdGUobnVsbCkpO1xuICAgICAgICAgIGlmICghdmlydHVhbCkge1xuICAgICAgICAgICAgdmFyIF9yZWZzJGZsb2F0aW5nJGN1cnJlbjtcbiAgICAgICAgICAgIC8vIFRoaXMgYWxzbyBuZWVkcyB0byBiZSBzeW5jIHRvIHByZXZlbnQgZmFzdCBtb3VzZSBtb3ZlbWVudHNcbiAgICAgICAgICAgIC8vIGZyb20gbGVhdmluZyBiZWhpbmQgYSBzdGFsZSBhY3RpdmUgaXRlbSB3aGVuIGxhbmRpbmcgb24gYVxuICAgICAgICAgICAgLy8gZGlzYWJsZWQgYnV0dG9uIGl0ZW0uXG4gICAgICAgICAgICAoX3JlZnMkZmxvYXRpbmckY3VycmVuID0gcmVmcy5mbG9hdGluZy5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3JlZnMkZmxvYXRpbmckY3VycmVuLmZvY3VzKHtcbiAgICAgICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH07XG4gICAgcmV0dXJuIHByb3BzO1xuICB9LCBbb3BlbiwgcmVmcywgZm9jdXNJdGVtLCBmb2N1c0l0ZW1PbkhvdmVyLCBsaXN0UmVmLCBvbk5hdmlnYXRlLCB2aXJ0dWFsXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgZGlzYWJsZWRJbmRpY2VzID0gZGlzYWJsZWRJbmRpY2VzUmVmLmN1cnJlbnQ7XG4gICAgZnVuY3Rpb24gb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICBpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBmb3JjZVN5bmNGb2N1cy5jdXJyZW50ID0gdHJ1ZTtcblxuICAgICAgLy8gSWYgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgYW5pbWF0aW5nIG91dCwgaWdub3JlIG5hdmlnYXRpb24uIE90aGVyd2lzZSxcbiAgICAgIC8vIHRoZSBgYWN0aXZlSW5kZXhgIGdldHMgc2V0IHRvIDAgZGVzcGl0ZSBub3QgYmVpbmcgb3BlbiBzbyB0aGUgbmV4dCB0aW1lXG4gICAgICAvLyB0aGUgdXNlciBBcnJvd0Rvd25zLCB0aGUgZmlyc3QgaXRlbSB3b24ndCBiZSBmb2N1c2VkLlxuICAgICAgaWYgKCFsYXRlc3RPcGVuUmVmLmN1cnJlbnQgJiYgZXZlbnQuY3VycmVudFRhcmdldCA9PT0gcmVmcy5mbG9hdGluZy5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChuZXN0ZWQgJiYgaXNDcm9zc09yaWVudGF0aW9uQ2xvc2VLZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbiwgcnRsKSkge1xuICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UpO1xuICAgICAgICBpZiAoaXNIVE1MRWxlbWVudChkb21SZWZlcmVuY2UpKSB7XG4gICAgICAgICAgZG9tUmVmZXJlbmNlLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gaW5kZXhSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IG1pbkluZGV4ID0gZ2V0TWluSW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzKTtcbiAgICAgIGNvbnN0IG1heEluZGV4ID0gZ2V0TWF4SW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzKTtcbiAgICAgIGlmIChldmVudC5rZXkgPT09ICdIb21lJykge1xuICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gbWluSW5kZXg7XG4gICAgICAgIG9uTmF2aWdhdGUoaW5kZXhSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSAnRW5kJykge1xuICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gbWF4SW5kZXg7XG4gICAgICAgIG9uTmF2aWdhdGUoaW5kZXhSZWYuY3VycmVudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEdyaWQgbmF2aWdhdGlvbi5cbiAgICAgIGlmIChjb2xzID4gMSkge1xuICAgICAgICBjb25zdCBwcmV2SW5kZXggPSBpbmRleFJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoZXZlbnQua2V5ID09PSBBUlJPV19VUCkge1xuICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgaWYgKHByZXZJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBtYXhJbmRleDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4LFxuICAgICAgICAgICAgICBhbW91bnQ6IGNvbHMsXG4gICAgICAgICAgICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChsb29wICYmIChwcmV2SW5kZXggLSBjb2xzIDwgbWluSW5kZXggfHwgaW5kZXhSZWYuY3VycmVudCA8IDApKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbCA9IHByZXZJbmRleCAlIGNvbHM7XG4gICAgICAgICAgICAgIGNvbnN0IG1heENvbCA9IG1heEluZGV4ICUgY29scztcbiAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gbWF4SW5kZXggLSAobWF4Q29sIC0gY29sKTtcbiAgICAgICAgICAgICAgaWYgKG1heENvbCA9PT0gY29sKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IG1heEluZGV4O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBtYXhDb2wgPiBjb2wgPyBvZmZzZXQgOiBvZmZzZXQgLSBjb2xzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0luZGV4T3V0T2ZCb3VuZHMobGlzdFJlZiwgaW5kZXhSZWYuY3VycmVudCkpIHtcbiAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBwcmV2SW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9uTmF2aWdhdGUoaW5kZXhSZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gQVJST1dfRE9XTikge1xuICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgaWYgKHByZXZJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBtaW5JbmRleDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4LFxuICAgICAgICAgICAgICBhbW91bnQ6IGNvbHMsXG4gICAgICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobG9vcCAmJiBwcmV2SW5kZXggKyBjb2xzID4gbWF4SW5kZXgpIHtcbiAgICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXggJSBjb2xzIC0gY29scyxcbiAgICAgICAgICAgICAgICBhbW91bnQ6IGNvbHMsXG4gICAgICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNJbmRleE91dE9mQm91bmRzKGxpc3RSZWYsIGluZGV4UmVmLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gcHJldkluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtYWlucyBvbiB0aGUgc2FtZSByb3cvY29sdW1uLlxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT09ICdib3RoJykge1xuICAgICAgICAgIGNvbnN0IHByZXZSb3cgPSBNYXRoLmZsb29yKHByZXZJbmRleCAvIGNvbHMpO1xuICAgICAgICAgIGlmIChldmVudC5rZXkgPT09IEFSUk9XX1JJR0hUKSB7XG4gICAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKHByZXZJbmRleCAlIGNvbHMgIT09IGNvbHMgLSAxKSB7XG4gICAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCB7XG4gICAgICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4LFxuICAgICAgICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGxvb3AgJiYgaXNEaWZmZXJlbnRSb3coaW5kZXhSZWYuY3VycmVudCwgY29scywgcHJldlJvdykpIHtcbiAgICAgICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4IC0gcHJldkluZGV4ICUgY29scyAtIDEsXG4gICAgICAgICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChsb29wKSB7XG4gICAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCB7XG4gICAgICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4IC0gcHJldkluZGV4ICUgY29scyAtIDEsXG4gICAgICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGlmZmVyZW50Um93KGluZGV4UmVmLmN1cnJlbnQsIGNvbHMsIHByZXZSb3cpKSB7XG4gICAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBwcmV2SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChldmVudC5rZXkgPT09IEFSUk9XX0xFRlQpIHtcbiAgICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgICBpZiAocHJldkluZGV4ICUgY29scyAhPT0gMCkge1xuICAgICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZEluZGljZXMsXG4gICAgICAgICAgICAgICAgZGVjcmVtZW50OiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAobG9vcCAmJiBpc0RpZmZlcmVudFJvdyhpbmRleFJlZi5jdXJyZW50LCBjb2xzLCBwcmV2Um93KSkge1xuICAgICAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCB7XG4gICAgICAgICAgICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXggKyAoY29scyAtIHByZXZJbmRleCAlIGNvbHMpLFxuICAgICAgICAgICAgICAgICAgZGVjcmVtZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobG9vcCkge1xuICAgICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCArIChjb2xzIC0gcHJldkluZGV4ICUgY29scyksXG4gICAgICAgICAgICAgICAgZGVjcmVtZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RpZmZlcmVudFJvdyhpbmRleFJlZi5jdXJyZW50LCBjb2xzLCBwcmV2Um93KSkge1xuICAgICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gcHJldkluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBsYXN0Um93ID0gTWF0aC5mbG9vcihtYXhJbmRleCAvIGNvbHMpID09PSBwcmV2Um93O1xuICAgICAgICAgIGlmIChpc0luZGV4T3V0T2ZCb3VuZHMobGlzdFJlZiwgaW5kZXhSZWYuY3VycmVudCkpIHtcbiAgICAgICAgICAgIGlmIChsb29wICYmIGxhc3RSb3cpIHtcbiAgICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGV2ZW50LmtleSA9PT0gQVJST1dfTEVGVCA/IG1heEluZGV4IDogZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCAtIHByZXZJbmRleCAlIGNvbHMgLSAxLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBwcmV2SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG9uTmF2aWdhdGUoaW5kZXhSZWYuY3VycmVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNNYWluT3JpZW50YXRpb25LZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbikpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcblxuICAgICAgICAvLyBSZXNldCB0aGUgaW5kZXggaWYgbm8gaXRlbSBpcyBmb2N1c2VkLlxuICAgICAgICBpZiAob3BlbiAmJiAhdmlydHVhbCAmJiBhY3RpdmVFbGVtZW50JDEoZXZlbnQuY3VycmVudFRhcmdldC5vd25lckRvY3VtZW50KSA9PT0gZXZlbnQuY3VycmVudFRhcmdldCkge1xuICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBpc01haW5PcmllbnRhdGlvblRvRW5kS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24sIHJ0bCkgPyBtaW5JbmRleCA6IG1heEluZGV4O1xuICAgICAgICAgIG9uTmF2aWdhdGUoaW5kZXhSZWYuY3VycmVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc01haW5PcmllbnRhdGlvblRvRW5kS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24sIHJ0bCkpIHtcbiAgICAgICAgICBpZiAobG9vcCkge1xuICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGN1cnJlbnRJbmRleCA+PSBtYXhJbmRleCA/IGFsbG93RXNjYXBlICYmIGN1cnJlbnRJbmRleCAhPT0gbGlzdFJlZi5jdXJyZW50Lmxlbmd0aCA/IC0xIDogbWluSW5kZXggOiBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCB7XG4gICAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IGN1cnJlbnRJbmRleCxcbiAgICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IE1hdGgubWluKG1heEluZGV4LCBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCB7XG4gICAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IGN1cnJlbnRJbmRleCxcbiAgICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChsb29wKSB7XG4gICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gY3VycmVudEluZGV4IDw9IG1pbkluZGV4ID8gYWxsb3dFc2NhcGUgJiYgY3VycmVudEluZGV4ICE9PSAtMSA/IGxpc3RSZWYuY3VycmVudC5sZW5ndGggOiBtYXhJbmRleCA6IGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogY3VycmVudEluZGV4LFxuICAgICAgICAgICAgICBkZWNyZW1lbnQ6IHRydWUsXG4gICAgICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBNYXRoLm1heChtaW5JbmRleCwgZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgICAgICBzdGFydGluZ0luZGV4OiBjdXJyZW50SW5kZXgsXG4gICAgICAgICAgICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0luZGV4T3V0T2ZCb3VuZHMobGlzdFJlZiwgaW5kZXhSZWYuY3VycmVudCkpIHtcbiAgICAgICAgICBvbk5hdmlnYXRlKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9uTmF2aWdhdGUoaW5kZXhSZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tWaXJ0dWFsTW91c2UoZXZlbnQpIHtcbiAgICAgIGlmIChmb2N1c0l0ZW1Pbk9wZW4gPT09ICdhdXRvJyAmJiBpc1ZpcnR1YWxDbGljayhldmVudC5uYXRpdmVFdmVudCkpIHtcbiAgICAgICAgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1ZpcnR1YWxQb2ludGVyKGV2ZW50KSB7XG4gICAgICAvLyBgcG9pbnRlcmRvd25gIGZpcmVzIGZpcnN0LCByZXNldCB0aGUgc3RhdGUgdGhlbiBwZXJmb3JtIHRoZSBjaGVja3MuXG4gICAgICBmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCA9IGZvY3VzSXRlbU9uT3BlbjtcbiAgICAgIGlmIChmb2N1c0l0ZW1Pbk9wZW4gPT09ICdhdXRvJyAmJiBpc1ZpcnR1YWxQb2ludGVyRXZlbnQoZXZlbnQubmF0aXZlRXZlbnQpKSB7XG4gICAgICAgIGZvY3VzSXRlbU9uT3BlblJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYXJpYUFjdGl2ZURlc2NlbmRhbnRQcm9wID0gdmlydHVhbCAmJiBvcGVuICYmIGhhc0FjdGl2ZUluZGV4ICYmIHtcbiAgICAgICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiBhY3RpdmVJZFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICAuLi5hcmlhQWN0aXZlRGVzY2VuZGFudFByb3AsXG4gICAgICAgIG9uS2V5RG93bihldmVudCkge1xuICAgICAgICAgIGlzUG9pbnRlck1vZGFsaXR5UmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBpc0Fycm93S2V5ID0gZXZlbnQua2V5LmluZGV4T2YoJ0Fycm93JykgPT09IDA7XG4gICAgICAgICAgaWYgKHZpcnR1YWwgJiYgb3Blbikge1xuICAgICAgICAgICAgcmV0dXJuIG9uS2V5RG93bihldmVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgYSBmbG9hdGluZyBlbGVtZW50IHNob3VsZCBub3Qgb3BlbiBvbiBhcnJvdyBrZXkgZG93biwgYXZvaWRcbiAgICAgICAgICAvLyBzZXR0aW5nIGBhY3RpdmVJbmRleGAgd2hpbGUgaXQncyBjbG9zZWQuXG4gICAgICAgICAgaWYgKCFvcGVuICYmICFvcGVuT25BcnJvd0tleURvd24gJiYgaXNBcnJvd0tleSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpc05hdmlnYXRpb25LZXkgPSBpc0Fycm93S2V5IHx8IGV2ZW50LmtleSA9PT0gJ0VudGVyJyB8fCBldmVudC5rZXkgPT09ICcgJyB8fCBldmVudC5rZXkgPT09ICcnO1xuICAgICAgICAgIGlmIChpc05hdmlnYXRpb25LZXkpIHtcbiAgICAgICAgICAgIGtleVJlZi5jdXJyZW50ID0gZXZlbnQua2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmVzdGVkKSB7XG4gICAgICAgICAgICBpZiAoaXNDcm9zc09yaWVudGF0aW9uT3BlbktleShldmVudC5rZXksIG9yaWVudGF0aW9uLCBydGwpKSB7XG4gICAgICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGdldE1pbkluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlcyk7XG4gICAgICAgICAgICAgICAgb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzTWFpbk9yaWVudGF0aW9uS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24pKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBzZWxlY3RlZEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghb3BlbiAmJiBvcGVuT25BcnJvd0tleURvd24pIHtcbiAgICAgICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb25LZXlEb3duKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICAgIG9uTmF2aWdhdGUoaW5kZXhSZWYuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkZvY3VzKCkge1xuICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICBvbk5hdmlnYXRlKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25Qb2ludGVyRG93bjogY2hlY2tWaXJ0dWFsUG9pbnRlcixcbiAgICAgICAgb25Nb3VzZURvd246IGNoZWNrVmlydHVhbE1vdXNlLFxuICAgICAgICBvbkNsaWNrOiBjaGVja1ZpcnR1YWxNb3VzZVxuICAgICAgfSxcbiAgICAgIGZsb2F0aW5nOiB7XG4gICAgICAgICdhcmlhLW9yaWVudGF0aW9uJzogb3JpZW50YXRpb24gPT09ICdib3RoJyA/IHVuZGVmaW5lZCA6IG9yaWVudGF0aW9uLFxuICAgICAgICAuLi5hcmlhQWN0aXZlRGVzY2VuZGFudFByb3AsXG4gICAgICAgIG9uS2V5RG93bixcbiAgICAgICAgb25Qb2ludGVyTW92ZSgpIHtcbiAgICAgICAgICBpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGl0ZW1cbiAgICB9O1xuICB9LCBbZG9tUmVmZXJlbmNlLCByZWZzLCBhY3RpdmVJZCwgZGlzYWJsZWRJbmRpY2VzUmVmLCBsYXRlc3RPcGVuUmVmLCBsaXN0UmVmLCBlbmFibGVkLCBvcmllbnRhdGlvbiwgcnRsLCB2aXJ0dWFsLCBvcGVuLCBoYXNBY3RpdmVJbmRleCwgbmVzdGVkLCBzZWxlY3RlZEluZGV4LCBvcGVuT25BcnJvd0tleURvd24sIGFsbG93RXNjYXBlLCBjb2xzLCBsb29wLCBmb2N1c0l0ZW1Pbk9wZW4sIG9uTmF2aWdhdGUsIG9uT3BlbkNoYW5nZSwgaXRlbV0pO1xufTtcblxuZnVuY3Rpb24gdXNlTWVyZ2VSZWZzKHJlZnMpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChyZWZzLmV2ZXJ5KHJlZiA9PiByZWYgPT0gbnVsbCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgPT4ge1xuICAgICAgcmVmcy5mb3JFYWNoKHJlZiA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmVmKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCByZWZzKTtcbn1cblxuLyoqXG4gKiBBZGRzIHJlbGV2YW50IHNjcmVlbiByZWFkZXIgcHJvcHMgZm9yIGEgZ2l2ZW4gZWxlbWVudCBgcm9sZWAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlUm9sZVxuICovXG5jb25zdCB1c2VSb2xlID0gZnVuY3Rpb24gKF9yZWYsIF90ZW1wKSB7XG4gIGxldCB7XG4gICAgb3BlblxuICB9ID0gX3JlZjtcbiAgbGV0IHtcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICByb2xlID0gJ2RpYWxvZydcbiAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICBjb25zdCByb290SWQgPSB1c2VJZCgpO1xuICBjb25zdCByZWZlcmVuY2VJZCA9IHVzZUlkKCk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBmbG9hdGluZ1Byb3BzID0ge1xuICAgICAgaWQ6IHJvb3RJZCxcbiAgICAgIHJvbGVcbiAgICB9O1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAocm9sZSA9PT0gJ3Rvb2x0aXAnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgICAnYXJpYS1kZXNjcmliZWRieSc6IG9wZW4gPyByb290SWQgOiB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgZmxvYXRpbmc6IGZsb2F0aW5nUHJvcHNcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBvcGVuID8gJ3RydWUnIDogJ2ZhbHNlJyxcbiAgICAgICAgJ2FyaWEtaGFzcG9wdXAnOiByb2xlID09PSAnYWxlcnRkaWFsb2cnID8gJ2RpYWxvZycgOiByb2xlLFxuICAgICAgICAnYXJpYS1jb250cm9scyc6IG9wZW4gPyByb290SWQgOiB1bmRlZmluZWQsXG4gICAgICAgIC4uLihyb2xlID09PSAnbGlzdGJveCcgJiYge1xuICAgICAgICAgIHJvbGU6ICdjb21ib2JveCdcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihyb2xlID09PSAnbWVudScgJiYge1xuICAgICAgICAgIGlkOiByZWZlcmVuY2VJZFxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIGZsb2F0aW5nOiB7XG4gICAgICAgIC4uLmZsb2F0aW5nUHJvcHMsXG4gICAgICAgIC4uLihyb2xlID09PSAnbWVudScgJiYge1xuICAgICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiByZWZlcmVuY2VJZFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtlbmFibGVkLCByb2xlLCBvcGVuLCByb290SWQsIHJlZmVyZW5jZUlkXSk7XG59O1xuXG4vLyBDb252ZXJ0cyBhIEpTIHN0eWxlIGtleSBsaWtlIGBiYWNrZ3JvdW5kQ29sb3JgIHRvIGEgQ1NTIHRyYW5zaXRpb24tcHJvcGVydHlcbi8vIGxpa2UgYGJhY2tncm91bmQtY29sb3JgLlxuY29uc3QgY2FtZWxDYXNlVG9LZWJhYkNhc2UgPSBzdHIgPT4gc3RyLnJlcGxhY2UoL1tBLVpdKyg/IVthLXpdKXxbQS1aXS9nLCAoJCwgb2ZzKSA9PiAob2ZzID8gJy0nIDogJycpICsgJC50b0xvd2VyQ2FzZSgpKTtcbmZ1bmN0aW9uIHVzZURlbGF5VW5tb3VudChvcGVuLCBkdXJhdGlvbk1zKSB7XG4gIGNvbnN0IFtpc01vdW50ZWQsIHNldElzTW91bnRlZF0gPSBSZWFjdC51c2VTdGF0ZShvcGVuKTtcbiAgaWYgKG9wZW4gJiYgIWlzTW91bnRlZCkge1xuICAgIHNldElzTW91bnRlZCh0cnVlKTtcbiAgfVxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghb3Blbikge1xuICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gc2V0SXNNb3VudGVkKGZhbHNlKSwgZHVyYXRpb25Ncyk7XG4gICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIH1cbiAgfSwgW29wZW4sIGR1cmF0aW9uTXNdKTtcbiAgcmV0dXJuIGlzTW91bnRlZDtcbn1cbi8qKlxuICogUHJvdmlkZXMgYSBzdGF0dXMgc3RyaW5nIHRvIGFwcGx5IENTUyB0cmFuc2l0aW9ucyB0byBhIGZsb2F0aW5nIGVsZW1lbnQsXG4gKiBjb3JyZWN0bHkgaGFuZGxpbmcgcGxhY2VtZW50LWF3YXJlIHRyYW5zaXRpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZVRyYW5zaXRpb24jdXNldHJhbnNpdGlvbnN0YXR1c1xuICovXG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uU3RhdHVzKF9yZWYsIF90ZW1wKSB7XG4gIGxldCB7XG4gICAgb3BlbixcbiAgICBlbGVtZW50czoge1xuICAgICAgZmxvYXRpbmdcbiAgICB9XG4gIH0gPSBfcmVmO1xuICBsZXQge1xuICAgIGR1cmF0aW9uID0gMjUwXG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgY29uc3QgaXNOdW1iZXJEdXJhdGlvbiA9IHR5cGVvZiBkdXJhdGlvbiA9PT0gJ251bWJlcic7XG4gIGNvbnN0IGNsb3NlRHVyYXRpb24gPSAoaXNOdW1iZXJEdXJhdGlvbiA/IGR1cmF0aW9uIDogZHVyYXRpb24uY2xvc2UpIHx8IDA7XG4gIGNvbnN0IFtpbml0aWF0ZWQsIHNldEluaXRpYXRlZF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzdGF0dXMsIHNldFN0YXR1c10gPSBSZWFjdC51c2VTdGF0ZSgndW5tb3VudGVkJyk7XG4gIGNvbnN0IGlzTW91bnRlZCA9IHVzZURlbGF5VW5tb3VudChvcGVuLCBjbG9zZUR1cmF0aW9uKTtcblxuICAvLyBgaW5pdGlhdGVkYCBjaGVjayBwcmV2ZW50cyB0aGlzIGBzZXRTdGF0ZWAgY2FsbCBmcm9tIGJyZWFraW5nXG4gIC8vIDxGbG9hdGluZ1BvcnRhbCAvPi4gVGhpcyBjYWxsIGlzIG5lY2Vzc2FyeSB0byBlbnN1cmUgc3Vic2VxdWVudCBvcGVuc1xuICAvLyBhZnRlciB0aGUgaW5pdGlhbCBvbmUgYWxsb3dzIHRoZSBjb3JyZWN0IHNpZGUgYW5pbWF0aW9uIHRvIHBsYXkgd2hlbiB0aGVcbiAgLy8gcGxhY2VtZW50IGhhcyBjaGFuZ2VkLlxuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKGluaXRpYXRlZCAmJiAhaXNNb3VudGVkKSB7XG4gICAgICBzZXRTdGF0dXMoJ3VubW91bnRlZCcpO1xuICAgIH1cbiAgfSwgW2luaXRpYXRlZCwgaXNNb3VudGVkXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIWZsb2F0aW5nKSByZXR1cm47XG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIHNldFN0YXR1cygnaW5pdGlhbCcpO1xuICAgICAgY29uc3QgZnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBzZXRTdGF0dXMoJ29wZW4nKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWUpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0SW5pdGlhdGVkKHRydWUpO1xuICAgICAgc2V0U3RhdHVzKCdjbG9zZScpO1xuICAgIH1cbiAgfSwgW29wZW4sIGZsb2F0aW5nXSk7XG4gIHJldHVybiB7XG4gICAgaXNNb3VudGVkLFxuICAgIHN0YXR1c1xuICB9O1xufVxuLyoqXG4gKiBQcm92aWRlcyBzdHlsZXMgdG8gYXBwbHkgQ1NTIHRyYW5zaXRpb25zIHRvIGEgZmxvYXRpbmcgZWxlbWVudCwgY29ycmVjdGx5XG4gKiBoYW5kbGluZyBwbGFjZW1lbnQtYXdhcmUgdHJhbnNpdGlvbnMuIFdyYXBwZXIgYXJvdW5kIGB1c2VUcmFuc2l0aW9uU3RhdHVzYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VUcmFuc2l0aW9uI3VzZXRyYW5zaXRpb25zdHlsZXNcbiAqL1xuZnVuY3Rpb24gdXNlVHJhbnNpdGlvblN0eWxlcyhjb250ZXh0LCBfdGVtcDIpIHtcbiAgbGV0IHtcbiAgICBpbml0aWFsOiB1bnN0YWJsZV9pbml0aWFsID0ge1xuICAgICAgb3BhY2l0eTogMFxuICAgIH0sXG4gICAgb3BlbjogdW5zdGFibGVfb3BlbixcbiAgICBjbG9zZTogdW5zdGFibGVfY2xvc2UsXG4gICAgY29tbW9uOiB1bnN0YWJsZV9jb21tb24sXG4gICAgZHVyYXRpb24gPSAyNTBcbiAgfSA9IF90ZW1wMiA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDI7XG4gIGNvbnN0IHBsYWNlbWVudCA9IGNvbnRleHQucGxhY2VtZW50O1xuICBjb25zdCBzaWRlID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIGNvbnN0IFtzdHlsZXMsIHNldFN0eWxlc10gPSBSZWFjdC51c2VTdGF0ZSh7fSk7XG4gIGNvbnN0IHtcbiAgICBpc01vdW50ZWQsXG4gICAgc3RhdHVzXG4gIH0gPSB1c2VUcmFuc2l0aW9uU3RhdHVzKGNvbnRleHQsIHtcbiAgICBkdXJhdGlvblxuICB9KTtcbiAgY29uc3QgaW5pdGlhbFJlZiA9IHVzZUxhdGVzdFJlZih1bnN0YWJsZV9pbml0aWFsKTtcbiAgY29uc3Qgb3BlblJlZiA9IHVzZUxhdGVzdFJlZih1bnN0YWJsZV9vcGVuKTtcbiAgY29uc3QgY2xvc2VSZWYgPSB1c2VMYXRlc3RSZWYodW5zdGFibGVfY2xvc2UpO1xuICBjb25zdCBjb21tb25SZWYgPSB1c2VMYXRlc3RSZWYodW5zdGFibGVfY29tbW9uKTtcbiAgY29uc3QgaXNOdW1iZXJEdXJhdGlvbiA9IHR5cGVvZiBkdXJhdGlvbiA9PT0gJ251bWJlcic7XG4gIGNvbnN0IG9wZW5EdXJhdGlvbiA9IChpc051bWJlckR1cmF0aW9uID8gZHVyYXRpb24gOiBkdXJhdGlvbi5vcGVuKSB8fCAwO1xuICBjb25zdCBjbG9zZUR1cmF0aW9uID0gKGlzTnVtYmVyRHVyYXRpb24gPyBkdXJhdGlvbiA6IGR1cmF0aW9uLmNsb3NlKSB8fCAwO1xuICBpbmRleCgoKSA9PiB7XG4gICAgY29uc3QgZm5BcmdzID0ge1xuICAgICAgc2lkZSxcbiAgICAgIHBsYWNlbWVudFxuICAgIH07XG4gICAgY29uc3QgaW5pdGlhbCA9IGluaXRpYWxSZWYuY3VycmVudDtcbiAgICBjb25zdCBjbG9zZSA9IGNsb3NlUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qgb3BlbiA9IG9wZW5SZWYuY3VycmVudDtcbiAgICBjb25zdCBjb21tb24gPSBjb21tb25SZWYuY3VycmVudDtcbiAgICBjb25zdCBpbml0aWFsU3R5bGVzID0gdHlwZW9mIGluaXRpYWwgPT09ICdmdW5jdGlvbicgPyBpbml0aWFsKGZuQXJncykgOiBpbml0aWFsO1xuICAgIGNvbnN0IGNsb3NlU3R5bGVzID0gdHlwZW9mIGNsb3NlID09PSAnZnVuY3Rpb24nID8gY2xvc2UoZm5BcmdzKSA6IGNsb3NlO1xuICAgIGNvbnN0IGNvbW1vblN0eWxlcyA9IHR5cGVvZiBjb21tb24gPT09ICdmdW5jdGlvbicgPyBjb21tb24oZm5BcmdzKSA6IGNvbW1vbjtcbiAgICBjb25zdCBvcGVuU3R5bGVzID0gKHR5cGVvZiBvcGVuID09PSAnZnVuY3Rpb24nID8gb3BlbihmbkFyZ3MpIDogb3BlbikgfHwgT2JqZWN0LmtleXMoaW5pdGlhbFN0eWxlcykucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgYWNjW2tleV0gPSAnJztcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIGlmIChzdGF0dXMgPT09ICdpbml0aWFsJykge1xuICAgICAgc2V0U3R5bGVzKHN0eWxlcyA9PiAoe1xuICAgICAgICB0cmFuc2l0aW9uUHJvcGVydHk6IHN0eWxlcy50cmFuc2l0aW9uUHJvcGVydHksXG4gICAgICAgIC4uLmNvbW1vblN0eWxlcyxcbiAgICAgICAgLi4uaW5pdGlhbFN0eWxlc1xuICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSAnb3BlbicpIHtcbiAgICAgIHNldFN0eWxlcyh7XG4gICAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogT2JqZWN0LmtleXMob3BlblN0eWxlcykubWFwKGNhbWVsQ2FzZVRvS2ViYWJDYXNlKS5qb2luKCcsJyksXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogb3BlbkR1cmF0aW9uICsgXCJtc1wiLFxuICAgICAgICAuLi5jb21tb25TdHlsZXMsXG4gICAgICAgIC4uLm9wZW5TdHlsZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSAnY2xvc2UnKSB7XG4gICAgICBjb25zdCBzdHlsZXMgPSBjbG9zZVN0eWxlcyB8fCBpbml0aWFsU3R5bGVzO1xuICAgICAgc2V0U3R5bGVzKHtcbiAgICAgICAgdHJhbnNpdGlvblByb3BlcnR5OiBPYmplY3Qua2V5cyhzdHlsZXMpLm1hcChjYW1lbENhc2VUb0tlYmFiQ2FzZSkuam9pbignLCcpLFxuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGNsb3NlRHVyYXRpb24gKyBcIm1zXCIsXG4gICAgICAgIC4uLmNvbW1vblN0eWxlcyxcbiAgICAgICAgLi4uc3R5bGVzXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtzaWRlLCBwbGFjZW1lbnQsIGNsb3NlRHVyYXRpb24sIGNsb3NlUmVmLCBpbml0aWFsUmVmLCBvcGVuUmVmLCBjb21tb25SZWYsIG9wZW5EdXJhdGlvbiwgc3RhdHVzXSk7XG4gIHJldHVybiB7XG4gICAgaXNNb3VudGVkLFxuICAgIHN0eWxlc1xuICB9O1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGEgbWF0Y2hpbmcgY2FsbGJhY2sgdGhhdCBjYW4gYmUgdXNlZCB0byBmb2N1cyBhbiBpdGVtIGFzIHRoZSB1c2VyXG4gKiB0eXBlcywgb2Z0ZW4gdXNlZCBpbiB0YW5kZW0gd2l0aCBgdXNlTGlzdE5hdmlnYXRpb24oKWAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlVHlwZWFoZWFkXG4gKi9cbmNvbnN0IHVzZVR5cGVhaGVhZCA9IGZ1bmN0aW9uIChfcmVmLCBfdGVtcCkge1xuICB2YXIgX3JlZjI7XG4gIGxldCB7XG4gICAgb3BlbixcbiAgICBkYXRhUmVmXG4gIH0gPSBfcmVmO1xuICBsZXQge1xuICAgIGxpc3RSZWYsXG4gICAgYWN0aXZlSW5kZXgsXG4gICAgb25NYXRjaDogdW5zdGFibGVfb25NYXRjaCA9ICgpID0+IHt9LFxuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIGZpbmRNYXRjaCA9IG51bGwsXG4gICAgcmVzZXRNcyA9IDEwMDAsXG4gICAgaWdub3JlS2V5cyA9IFtdLFxuICAgIHNlbGVjdGVkSW5kZXggPSBudWxsXG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge1xuICAgIGxpc3RSZWY6IHtcbiAgICAgIGN1cnJlbnQ6IFtdXG4gICAgfSxcbiAgICBhY3RpdmVJbmRleDogbnVsbFxuICB9IDogX3RlbXA7XG4gIGNvbnN0IHRpbWVvdXRJZFJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCBzdHJpbmdSZWYgPSBSZWFjdC51c2VSZWYoJycpO1xuICBjb25zdCBwcmV2SW5kZXhSZWYgPSBSZWFjdC51c2VSZWYoKF9yZWYyID0gc2VsZWN0ZWRJbmRleCAhPSBudWxsID8gc2VsZWN0ZWRJbmRleCA6IGFjdGl2ZUluZGV4KSAhPSBudWxsID8gX3JlZjIgOiAtMSk7XG4gIGNvbnN0IG1hdGNoSW5kZXhSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IG9uTWF0Y2ggPSB1c2VFdmVudCh1bnN0YWJsZV9vbk1hdGNoKTtcbiAgY29uc3QgZmluZE1hdGNoUmVmID0gdXNlTGF0ZXN0UmVmKGZpbmRNYXRjaCk7XG4gIGNvbnN0IGlnbm9yZUtleXNSZWYgPSB1c2VMYXRlc3RSZWYoaWdub3JlS2V5cyk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAob3Blbikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZFJlZi5jdXJyZW50KTtcbiAgICAgIG1hdGNoSW5kZXhSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICBzdHJpbmdSZWYuY3VycmVudCA9ICcnO1xuICAgIH1cbiAgfSwgW29wZW5dKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIC8vIFN5bmMgYXJyb3cga2V5IG5hdmlnYXRpb24gYnV0IG5vdCB0eXBlYWhlYWQgbmF2aWdhdGlvbi5cbiAgICBpZiAob3BlbiAmJiBzdHJpbmdSZWYuY3VycmVudCA9PT0gJycpIHtcbiAgICAgIHZhciBfcmVmMztcbiAgICAgIHByZXZJbmRleFJlZi5jdXJyZW50ID0gKF9yZWYzID0gc2VsZWN0ZWRJbmRleCAhPSBudWxsID8gc2VsZWN0ZWRJbmRleCA6IGFjdGl2ZUluZGV4KSAhPSBudWxsID8gX3JlZjMgOiAtMTtcbiAgICB9XG4gIH0sIFtvcGVuLCBzZWxlY3RlZEluZGV4LCBhY3RpdmVJbmRleF0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uS2V5RG93bihldmVudCkge1xuICAgICAgLy8gQ29ycmVjdGx5IHNjb3BlIG5lc3RlZCBub24tcG9ydGFsbGVkIGZsb2F0aW5nIGVsZW1lbnRzLiBTaW5jZSB0aGUgbmVzdGVkXG4gICAgICAvLyBmbG9hdGluZyBlbGVtZW50IGlzIGluc2lkZSBvZiB0aGUgYW5vdGhlciwgd2UgZmluZCB0aGUgY2xvc2VzdCByb2xlXG4gICAgICAvLyB0aGF0IGluZGljYXRlcyB0aGUgZmxvYXRpbmcgZWxlbWVudCBzY29wZS5cbiAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldChldmVudC5uYXRpdmVFdmVudCk7XG4gICAgICBpZiAoaXNFbGVtZW50KHRhcmdldCkgJiYgKGFjdGl2ZUVsZW1lbnQkMShnZXREb2N1bWVudCh0YXJnZXQpKSAhPT0gZXZlbnQuY3VycmVudFRhcmdldCA/IHRhcmdldC5jbG9zZXN0KCdbcm9sZT1cImRpYWxvZ1wiXSxbcm9sZT1cIm1lbnVcIl0sW3JvbGU9XCJsaXN0Ym94XCJdLFtyb2xlPVwidHJlZVwiXSxbcm9sZT1cImdyaWRcIl0nKSAhPT0gZXZlbnQuY3VycmVudFRhcmdldCA6IGZhbHNlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc3RyaW5nUmVmLmN1cnJlbnQubGVuZ3RoID4gMCAmJiBzdHJpbmdSZWYuY3VycmVudFswXSAhPT0gJyAnKSB7XG4gICAgICAgIGRhdGFSZWYuY3VycmVudC50eXBpbmcgPSB0cnVlO1xuICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnICcpIHtcbiAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBsaXN0Q29udGVudCA9IGxpc3RSZWYuY3VycmVudDtcbiAgICAgIGlmIChsaXN0Q29udGVudCA9PSBudWxsIHx8IGlnbm9yZUtleXNSZWYuY3VycmVudC5pbmNsdWRlcyhldmVudC5rZXkpIHx8XG4gICAgICAvLyBDaGFyYWN0ZXIga2V5LlxuICAgICAgZXZlbnQua2V5Lmxlbmd0aCAhPT0gMSB8fFxuICAgICAgLy8gTW9kaWZpZXIga2V5LlxuICAgICAgZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEJhaWwgb3V0IGlmIHRoZSBsaXN0IGNvbnRhaW5zIGEgd29yZCBsaWtlIFwibGxhbWFcIiBvciBcImFhcm9uXCIuIFRPRE86XG4gICAgICAvLyBhbGxvdyBpdCBpbiB0aGlzIGNhc2UsIHRvby5cbiAgICAgIGNvbnN0IGFsbG93UmFwaWRTdWNjZXNzaW9uT2ZGaXJzdExldHRlciA9IGxpc3RDb250ZW50LmV2ZXJ5KHRleHQgPT4ge1xuICAgICAgICB2YXIgX3RleHQkLCBfdGV4dCQyO1xuICAgICAgICByZXR1cm4gdGV4dCA/ICgoX3RleHQkID0gdGV4dFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90ZXh0JC50b0xvY2FsZUxvd2VyQ2FzZSgpKSAhPT0gKChfdGV4dCQyID0gdGV4dFsxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90ZXh0JDIudG9Mb2NhbGVMb3dlckNhc2UoKSkgOiB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEFsbG93cyB0aGUgdXNlciB0byBjeWNsZSB0aHJvdWdoIGl0ZW1zIHRoYXQgc3RhcnQgd2l0aCB0aGUgc2FtZSBsZXR0ZXJcbiAgICAgIC8vIGluIHJhcGlkIHN1Y2Nlc3Npb24uXG4gICAgICBpZiAoYWxsb3dSYXBpZFN1Y2Nlc3Npb25PZkZpcnN0TGV0dGVyICYmIHN0cmluZ1JlZi5jdXJyZW50ID09PSBldmVudC5rZXkpIHtcbiAgICAgICAgc3RyaW5nUmVmLmN1cnJlbnQgPSAnJztcbiAgICAgICAgcHJldkluZGV4UmVmLmN1cnJlbnQgPSBtYXRjaEluZGV4UmVmLmN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBzdHJpbmdSZWYuY3VycmVudCArPSBldmVudC5rZXk7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkUmVmLmN1cnJlbnQpO1xuICAgICAgdGltZW91dElkUmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc3RyaW5nUmVmLmN1cnJlbnQgPSAnJztcbiAgICAgICAgcHJldkluZGV4UmVmLmN1cnJlbnQgPSBtYXRjaEluZGV4UmVmLmN1cnJlbnQ7XG4gICAgICAgIGRhdGFSZWYuY3VycmVudC50eXBpbmcgPSBmYWxzZTtcbiAgICAgIH0sIHJlc2V0TXMpO1xuICAgICAgY29uc3QgcHJldkluZGV4ID0gcHJldkluZGV4UmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBvcmRlcmVkTGlzdCA9IFsuLi5saXN0Q29udGVudC5zbGljZSgocHJldkluZGV4IHx8IDApICsgMSksIC4uLmxpc3RDb250ZW50LnNsaWNlKDAsIChwcmV2SW5kZXggfHwgMCkgKyAxKV07XG4gICAgICBjb25zdCBzdHIgPSBmaW5kTWF0Y2hSZWYuY3VycmVudCA/IGZpbmRNYXRjaFJlZi5jdXJyZW50KG9yZGVyZWRMaXN0LCBzdHJpbmdSZWYuY3VycmVudCkgOiBvcmRlcmVkTGlzdC5maW5kKHRleHQgPT4gKHRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IHRleHQudG9Mb2NhbGVMb3dlckNhc2UoKS5pbmRleE9mKHN0cmluZ1JlZi5jdXJyZW50LnRvTG9jYWxlTG93ZXJDYXNlKCkpKSA9PT0gMCk7XG4gICAgICBjb25zdCBpbmRleCA9IHN0ciA/IGxpc3RDb250ZW50LmluZGV4T2Yoc3RyKSA6IC0xO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICBvbk1hdGNoKGluZGV4KTtcbiAgICAgICAgbWF0Y2hJbmRleFJlZi5jdXJyZW50ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgb25LZXlEb3duXG4gICAgICB9LFxuICAgICAgZmxvYXRpbmc6IHtcbiAgICAgICAgb25LZXlEb3duXG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIGRhdGFSZWYsIGxpc3RSZWYsIHJlc2V0TXMsIGlnbm9yZUtleXNSZWYsIGZpbmRNYXRjaFJlZiwgb25NYXRjaF0pO1xufTtcblxuZnVuY3Rpb24gZ2V0QXJnc1dpdGhDdXN0b21GbG9hdGluZ0hlaWdodChhcmdzLCBoZWlnaHQpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5hcmdzLFxuICAgIHJlY3RzOiB7XG4gICAgICAuLi5hcmdzLnJlY3RzLFxuICAgICAgZmxvYXRpbmc6IHtcbiAgICAgICAgLi4uYXJncy5yZWN0cy5mbG9hdGluZyxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuLyoqXG4gKiBQb3NpdGlvbnMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgc3VjaCB0aGF0IGFuIGlubmVyIGVsZW1lbnQgaW5zaWRlXG4gKiBvZiBpdCBpcyBhbmNob3JlZCB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaW5uZXJcbiAqL1xuY29uc3QgaW5uZXIgPSBwcm9wcyA9PiAoe1xuICBuYW1lOiAnaW5uZXInLFxuICBvcHRpb25zOiBwcm9wcyxcbiAgYXN5bmMgZm4obWlkZGxld2FyZUFyZ3VtZW50cykge1xuICAgIGNvbnN0IHtcbiAgICAgIGxpc3RSZWYsXG4gICAgICBvdmVyZmxvd1JlZixcbiAgICAgIG9uRmFsbGJhY2tDaGFuZ2UsXG4gICAgICBvZmZzZXQ6IGlubmVyT2Zmc2V0ID0gMCxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIG1pbkl0ZW1zVmlzaWJsZSA9IDQsXG4gICAgICByZWZlcmVuY2VPdmVyZmxvd1RocmVzaG9sZCA9IDAsXG4gICAgICBzY3JvbGxSZWYsXG4gICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICB9ID0gcHJvcHM7XG4gICAgY29uc3Qge1xuICAgICAgcmVjdHMsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICBmbG9hdGluZ1xuICAgICAgfVxuICAgIH0gPSBtaWRkbGV3YXJlQXJndW1lbnRzO1xuICAgIGNvbnN0IGl0ZW0gPSBsaXN0UmVmLmN1cnJlbnRbaW5kZXhdO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghbWlkZGxld2FyZUFyZ3VtZW50cy5wbGFjZW1lbnQuc3RhcnRzV2l0aCgnYm90dG9tJykpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFsnRmxvYXRpbmcgVUk6IGBwbGFjZW1lbnRgIHNpZGUgbXVzdCBiZSBcImJvdHRvbVwiIHdoZW4gdXNpbmcgdGhlJywgJ2Bpbm5lcmAgbWlkZGxld2FyZS4nXS5qb2luKCcgJykpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgbmV4dEFyZ3MgPSB7XG4gICAgICAuLi5taWRkbGV3YXJlQXJndW1lbnRzLFxuICAgICAgLi4uKGF3YWl0IG9mZnNldCgtaXRlbS5vZmZzZXRUb3AgLSByZWN0cy5yZWZlcmVuY2UuaGVpZ2h0IC8gMiAtIGl0ZW0ub2Zmc2V0SGVpZ2h0IC8gMiAtIGlubmVyT2Zmc2V0KS5mbihtaWRkbGV3YXJlQXJndW1lbnRzKSlcbiAgICB9O1xuICAgIGNvbnN0IGVsID0gKHNjcm9sbFJlZiA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsUmVmLmN1cnJlbnQpIHx8IGZsb2F0aW5nO1xuICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coZ2V0QXJnc1dpdGhDdXN0b21GbG9hdGluZ0hlaWdodChuZXh0QXJncywgZWwuc2Nyb2xsSGVpZ2h0KSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICBjb25zdCByZWZPdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KG5leHRBcmdzLCB7XG4gICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnMsXG4gICAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgICB9KTtcbiAgICBjb25zdCBkaWZmWSA9IE1hdGgubWF4KDAsIG92ZXJmbG93LnRvcCk7XG4gICAgY29uc3QgbmV4dFkgPSBuZXh0QXJncy55ICsgZGlmZlk7XG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gTWF0aC5tYXgoMCwgZWwuc2Nyb2xsSGVpZ2h0IC0gZGlmZlkgLSBNYXRoLm1heCgwLCBvdmVyZmxvdy5ib3R0b20pKTtcbiAgICBlbC5zdHlsZS5tYXhIZWlnaHQgPSBtYXhIZWlnaHQgKyBcInB4XCI7XG4gICAgZWwuc2Nyb2xsVG9wID0gZGlmZlk7XG5cbiAgICAvLyBUaGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlLCBmYWxsYmFjayB0byBzdGFuZGFyZCBhbmNob3JlZCBwb3NpdGlvbmluZ1xuICAgIGlmIChvbkZhbGxiYWNrQ2hhbmdlKSB7XG4gICAgICBpZiAoZWwub2Zmc2V0SGVpZ2h0IDwgaXRlbS5vZmZzZXRIZWlnaHQgKiBNYXRoLm1pbihtaW5JdGVtc1Zpc2libGUsIGxpc3RSZWYuY3VycmVudC5sZW5ndGggLSAxKSAtIDEgfHwgcmVmT3ZlcmZsb3cudG9wID49IC1yZWZlcmVuY2VPdmVyZmxvd1RocmVzaG9sZCB8fCByZWZPdmVyZmxvdy5ib3R0b20gPj0gLXJlZmVyZW5jZU92ZXJmbG93VGhyZXNob2xkKSB7XG4gICAgICAgIGZsdXNoU3luYygoKSA9PiBvbkZhbGxiYWNrQ2hhbmdlKHRydWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZsdXNoU3luYygoKSA9PiBvbkZhbGxiYWNrQ2hhbmdlKGZhbHNlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvdmVyZmxvd1JlZikge1xuICAgICAgb3ZlcmZsb3dSZWYuY3VycmVudCA9IGF3YWl0IGRldGVjdE92ZXJmbG93KGdldEFyZ3NXaXRoQ3VzdG9tRmxvYXRpbmdIZWlnaHQoe1xuICAgICAgICAuLi5uZXh0QXJncyxcbiAgICAgICAgeTogbmV4dFlcbiAgICAgIH0sIGVsLm9mZnNldEhlaWdodCksIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB5OiBuZXh0WVxuICAgIH07XG4gIH1cbn0pO1xuLyoqXG4gKiBDaGFuZ2VzIHRoZSBgaW5uZXJgIG1pZGRsZXdhcmUncyBgb2Zmc2V0YCB1cG9uIGEgYHdoZWVsYCBldmVudCB0b1xuICogZXhwYW5kIHRoZSBmbG9hdGluZyBlbGVtZW50J3MgaGVpZ2h0LCByZXZlYWxpbmcgbW9yZSBsaXN0IGl0ZW1zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubmVyXG4gKi9cbmNvbnN0IHVzZUlubmVyT2Zmc2V0ID0gKF9yZWYsIF9yZWYyKSA9PiB7XG4gIGxldCB7XG4gICAgb3BlbixcbiAgICBlbGVtZW50c1xuICB9ID0gX3JlZjtcbiAgbGV0IHtcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICBvdmVyZmxvd1JlZixcbiAgICBzY3JvbGxSZWYsXG4gICAgb25DaGFuZ2U6IHVuc3RhYmxlX29uQ2hhbmdlXG4gIH0gPSBfcmVmMjtcbiAgY29uc3Qgb25DaGFuZ2UgPSB1c2VFdmVudCh1bnN0YWJsZV9vbkNoYW5nZSk7XG4gIGNvbnN0IGNvbnRyb2xsZWRTY3JvbGxpbmdSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCBwcmV2U2Nyb2xsVG9wUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBpbml0aWFsT3ZlcmZsb3dSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uV2hlZWwoZSkge1xuICAgICAgaWYgKGUuY3RybEtleSB8fCAhZWwgfHwgb3ZlcmZsb3dSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRZID0gZS5kZWx0YVk7XG4gICAgICBjb25zdCBpc0F0VG9wID0gb3ZlcmZsb3dSZWYuY3VycmVudC50b3AgPj0gLTAuNTtcbiAgICAgIGNvbnN0IGlzQXRCb3R0b20gPSBvdmVyZmxvd1JlZi5jdXJyZW50LmJvdHRvbSA+PSAtMC41O1xuICAgICAgY29uc3QgcmVtYWluaW5nU2Nyb2xsID0gZWwuc2Nyb2xsSGVpZ2h0IC0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgY29uc3Qgc2lnbiA9IGRZIDwgMCA/IC0xIDogMTtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IGRZIDwgMCA/ICdtYXgnIDogJ21pbic7XG4gICAgICBpZiAoZWwuc2Nyb2xsSGVpZ2h0IDw9IGVsLmNsaWVudEhlaWdodCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXRUb3AgJiYgZFkgPiAwIHx8ICFpc0F0Qm90dG9tICYmIGRZIDwgMCkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgICAgb25DaGFuZ2UoZCA9PiBkICsgTWF0aFttZXRob2RdKGRZLCByZW1haW5pbmdTY3JvbGwgKiBzaWduKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICgvZmlyZWZveC9pLnRlc3QoZ2V0VXNlckFnZW50KCkpKSB7XG4gICAgICAgIC8vIE5lZWRlZCB0byBwcm9wYWdhdGUgc2Nyb2xsaW5nIGR1cmluZyBtb21lbnR1bSBzY3JvbGxpbmcgcGhhc2Ugb25jZVxuICAgICAgICAvLyBpdCBnZXRzIGxpbWl0ZWQgYnkgdGhlIGJvdW5kYXJ5LiBVWCBpbXByb3ZlbWVudCwgbm90IGNyaXRpY2FsLlxuICAgICAgICBlbC5zY3JvbGxUb3AgKz0gZFk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVsID0gKHNjcm9sbFJlZiA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsUmVmLmN1cnJlbnQpIHx8IGVsZW1lbnRzLmZsb2F0aW5nO1xuICAgIGlmIChvcGVuICYmIGVsKSB7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIG9uV2hlZWwpO1xuXG4gICAgICAvLyBXYWl0IGZvciB0aGUgcG9zaXRpb24gdG8gYmUgcmVhZHkuXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQgPSBlbC5zY3JvbGxUb3A7XG4gICAgICAgIGlmIChvdmVyZmxvd1JlZi5jdXJyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBpbml0aWFsT3ZlcmZsb3dSZWYuY3VycmVudCA9IHtcbiAgICAgICAgICAgIC4uLm92ZXJmbG93UmVmLmN1cnJlbnRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHByZXZTY3JvbGxUb3BSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIGluaXRpYWxPdmVyZmxvd1JlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBvbldoZWVsKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgb3BlbiwgZWxlbWVudHMuZmxvYXRpbmcsIG92ZXJmbG93UmVmLCBzY3JvbGxSZWYsIG9uQ2hhbmdlXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGZsb2F0aW5nOiB7XG4gICAgICAgIG9uS2V5RG93bigpIHtcbiAgICAgICAgICBjb250cm9sbGVkU2Nyb2xsaW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBvbldoZWVsKCkge1xuICAgICAgICAgIGNvbnRyb2xsZWRTY3JvbGxpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBvblBvaW50ZXJNb3ZlKCkge1xuICAgICAgICAgIGNvbnRyb2xsZWRTY3JvbGxpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBvblNjcm9sbCgpIHtcbiAgICAgICAgICBjb25zdCBlbCA9IChzY3JvbGxSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IHNjcm9sbFJlZi5jdXJyZW50KSB8fCBlbGVtZW50cy5mbG9hdGluZztcbiAgICAgICAgICBpZiAoIW92ZXJmbG93UmVmLmN1cnJlbnQgfHwgIWVsIHx8ICFjb250cm9sbGVkU2Nyb2xsaW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByZXZTY3JvbGxUb3BSZWYuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsRGlmZiA9IGVsLnNjcm9sbFRvcCAtIHByZXZTY3JvbGxUb3BSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChvdmVyZmxvd1JlZi5jdXJyZW50LmJvdHRvbSA8IC0wLjUgJiYgc2Nyb2xsRGlmZiA8IC0xIHx8IG92ZXJmbG93UmVmLmN1cnJlbnQudG9wIDwgLTAuNSAmJiBzY3JvbGxEaWZmID4gMSkge1xuICAgICAgICAgICAgICBmbHVzaFN5bmMoKCkgPT4gb25DaGFuZ2UoZCA9PiBkICsgc2Nyb2xsRGlmZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFtGaXJlZm94XSBXYWl0IGZvciB0aGUgaGVpZ2h0IGNoYW5nZSB0byBoYXZlIGJlZW4gYXBwbGllZC5cbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgcHJldlNjcm9sbFRvcFJlZi5jdXJyZW50ID0gZWwuc2Nyb2xsVG9wO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIG92ZXJmbG93UmVmLCBlbGVtZW50cy5mbG9hdGluZywgc2Nyb2xsUmVmLCBvbkNoYW5nZV0pO1xufTtcblxuZnVuY3Rpb24gaXNQb2ludEluUG9seWdvbihwb2ludCwgcG9seWdvbikge1xuICBjb25zdCBbeCwgeV0gPSBwb2ludDtcbiAgbGV0IGlzSW5zaWRlID0gZmFsc2U7XG4gIGNvbnN0IGxlbmd0aCA9IHBvbHlnb24ubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMCwgaiA9IGxlbmd0aCAtIDE7IGkgPCBsZW5ndGg7IGogPSBpKyspIHtcbiAgICBjb25zdCBbeGksIHlpXSA9IHBvbHlnb25baV0gfHwgWzAsIDBdO1xuICAgIGNvbnN0IFt4aiwgeWpdID0gcG9seWdvbltqXSB8fCBbMCwgMF07XG4gICAgY29uc3QgaW50ZXJzZWN0ID0geWkgPj0geSAhPT0geWogPj0geSAmJiB4IDw9ICh4aiAtIHhpKSAqICh5IC0geWkpIC8gKHlqIC0geWkpICsgeGk7XG4gICAgaWYgKGludGVyc2VjdCkge1xuICAgICAgaXNJbnNpZGUgPSAhaXNJbnNpZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBpc0luc2lkZTtcbn1cbmZ1bmN0aW9uIGlzSW5zaWRlKHBvaW50LCByZWN0KSB7XG4gIHJldHVybiBwb2ludFswXSA+PSByZWN0LnggJiYgcG9pbnRbMF0gPD0gcmVjdC54ICsgcmVjdC53aWR0aCAmJiBwb2ludFsxXSA+PSByZWN0LnkgJiYgcG9pbnRbMV0gPD0gcmVjdC55ICsgcmVjdC5oZWlnaHQ7XG59XG5mdW5jdGlvbiBzYWZlUG9seWdvbihfdGVtcCkge1xuICBsZXQge1xuICAgIHJlc3RNcyA9IDAsXG4gICAgYnVmZmVyID0gMC41LFxuICAgIGJsb2NrUG9pbnRlckV2ZW50cyA9IGZhbHNlXG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgbGV0IHRpbWVvdXRJZDtcbiAgbGV0IGlzSW5zaWRlUmVjdCA9IGZhbHNlO1xuICBsZXQgaGFzTGFuZGVkID0gZmFsc2U7XG4gIGNvbnN0IGZuID0gX3JlZiA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcGxhY2VtZW50LFxuICAgICAgZWxlbWVudHMsXG4gICAgICBvbkNsb3NlLFxuICAgICAgbm9kZUlkLFxuICAgICAgdHJlZVxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiBmdW5jdGlvbiBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICBvbkNsb3NlKCk7XG4gICAgICB9XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIGlmICghZWxlbWVudHMuZG9tUmVmZXJlbmNlIHx8ICFlbGVtZW50cy5mbG9hdGluZyB8fCBwbGFjZW1lbnQgPT0gbnVsbCB8fCB4ID09IG51bGwgfHwgeSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2xpZW50WCxcbiAgICAgICAgY2xpZW50WVxuICAgICAgfSA9IGV2ZW50O1xuICAgICAgY29uc3QgY2xpZW50UG9pbnQgPSBbY2xpZW50WCwgY2xpZW50WV07XG4gICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQoZXZlbnQpO1xuICAgICAgY29uc3QgaXNMZWF2ZSA9IGV2ZW50LnR5cGUgPT09ICdtb3VzZWxlYXZlJztcbiAgICAgIGNvbnN0IGlzT3ZlckZsb2F0aW5nRWwgPSBjb250YWlucyhlbGVtZW50cy5mbG9hdGluZywgdGFyZ2V0KTtcbiAgICAgIGNvbnN0IGlzT3ZlclJlZmVyZW5jZUVsID0gY29udGFpbnMoZWxlbWVudHMuZG9tUmVmZXJlbmNlLCB0YXJnZXQpO1xuICAgICAgY29uc3QgcmVmUmVjdCA9IGVsZW1lbnRzLmRvbVJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHJlY3QgPSBlbGVtZW50cy5mbG9hdGluZy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHNpZGUgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgICAgIGNvbnN0IGN1cnNvckxlYXZlRnJvbVJpZ2h0ID0geCA+IHJlY3QucmlnaHQgLSByZWN0LndpZHRoIC8gMjtcbiAgICAgIGNvbnN0IGN1cnNvckxlYXZlRnJvbUJvdHRvbSA9IHkgPiByZWN0LmJvdHRvbSAtIHJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgIGNvbnN0IGlzT3ZlclJlZmVyZW5jZVJlY3QgPSBpc0luc2lkZShjbGllbnRQb2ludCwgcmVmUmVjdCk7XG4gICAgICBpZiAoaXNPdmVyRmxvYXRpbmdFbCkge1xuICAgICAgICBoYXNMYW5kZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzT3ZlclJlZmVyZW5jZUVsKSB7XG4gICAgICAgIGhhc0xhbmRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzT3ZlclJlZmVyZW5jZUVsICYmICFpc0xlYXZlKSB7XG4gICAgICAgIGhhc0xhbmRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUHJldmVudCBvdmVybGFwcGluZyBmbG9hdGluZyBlbGVtZW50IGZyb20gYmVpbmcgc3R1Y2sgaW4gYW4gb3Blbi1jbG9zZVxuICAgICAgLy8gbG9vcDogaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8xOTEwXG4gICAgICBpZiAoaXNMZWF2ZSAmJiBpc0VsZW1lbnQoZXZlbnQucmVsYXRlZFRhcmdldCkgJiYgY29udGFpbnMoZWxlbWVudHMuZmxvYXRpbmcsIGV2ZW50LnJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYW55IG5lc3RlZCBjaGlsZCBpcyBvcGVuLCBhYm9ydC5cbiAgICAgIGlmICh0cmVlICYmIGdldENoaWxkcmVuKHRyZWUubm9kZXNSZWYuY3VycmVudCwgbm9kZUlkKS5zb21lKF9yZWYyID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBjb250ZXh0XG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRleHQub3BlbjtcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIHBvaW50ZXIgaXMgbGVhdmluZyBmcm9tIHRoZSBvcHBvc2l0ZSBzaWRlLCB0aGUgXCJidWZmZXJcIiBsb2dpY1xuICAgICAgLy8gY3JlYXRlcyBhIHBvaW50IHdoZXJlIHRoZSBmbG9hdGluZyBlbGVtZW50IHJlbWFpbnMgb3BlbiwgYnV0IHNob3VsZCBiZVxuICAgICAgLy8gaWdub3JlZC5cbiAgICAgIC8vIEEgY29uc3RhbnQgb2YgMSBoYW5kbGVzIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycy5cbiAgICAgIGlmIChzaWRlID09PSAndG9wJyAmJiB5ID49IHJlZlJlY3QuYm90dG9tIC0gMSB8fCBzaWRlID09PSAnYm90dG9tJyAmJiB5IDw9IHJlZlJlY3QudG9wICsgMSB8fCBzaWRlID09PSAnbGVmdCcgJiYgeCA+PSByZWZSZWN0LnJpZ2h0IC0gMSB8fCBzaWRlID09PSAncmlnaHQnICYmIHggPD0gcmVmUmVjdC5sZWZ0ICsgMSkge1xuICAgICAgICByZXR1cm4gY2xvc2UoKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWdub3JlIHdoZW4gdGhlIGN1cnNvciBpcyB3aXRoaW4gdGhlIHJlY3Rhbmd1bGFyIHRyb3VnaCBiZXR3ZWVuIHRoZVxuICAgICAgLy8gdHdvIGVsZW1lbnRzLiBTaW5jZSB0aGUgdHJpYW5nbGUgaXMgY3JlYXRlZCBmcm9tIHRoZSBjdXJzb3IgcG9pbnQsXG4gICAgICAvLyB3aGljaCBjYW4gc3RhcnQgYmV5b25kIHRoZSByZWYgZWxlbWVudCdzIGVkZ2UsIHRyYXZlcnNpbmcgYmFjayBhbmRcbiAgICAgIC8vIGZvcnRoIGZyb20gdGhlIHJlZiB0byB0aGUgZmxvYXRpbmcgZWxlbWVudCBjYW4gY2F1c2UgaXQgdG8gY2xvc2UuIFRoaXNcbiAgICAgIC8vIGVuc3VyZXMgaXQgYWx3YXlzIHJlbWFpbnMgb3BlbiBpbiB0aGF0IGNhc2UuXG4gICAgICBsZXQgcmVjdFBvbHkgPSBbXTtcbiAgICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIHJlY3RQb2x5ID0gW1tyZWN0LmxlZnQsIHJlZlJlY3QudG9wICsgMV0sIFtyZWN0LmxlZnQsIHJlY3QuYm90dG9tIC0gMV0sIFtyZWN0LnJpZ2h0LCByZWN0LmJvdHRvbSAtIDFdLCBbcmVjdC5yaWdodCwgcmVmUmVjdC50b3AgKyAxXV07XG4gICAgICAgICAgaXNJbnNpZGVSZWN0ID0gY2xpZW50WCA+PSByZWN0LmxlZnQgJiYgY2xpZW50WCA8PSByZWN0LnJpZ2h0ICYmIGNsaWVudFkgPj0gcmVjdC50b3AgJiYgY2xpZW50WSA8PSByZWZSZWN0LnRvcCArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgcmVjdFBvbHkgPSBbW3JlY3QubGVmdCwgcmVjdC50b3AgKyAxXSwgW3JlY3QubGVmdCwgcmVmUmVjdC5ib3R0b20gLSAxXSwgW3JlY3QucmlnaHQsIHJlZlJlY3QuYm90dG9tIC0gMV0sIFtyZWN0LnJpZ2h0LCByZWN0LnRvcCArIDFdXTtcbiAgICAgICAgICBpc0luc2lkZVJlY3QgPSBjbGllbnRYID49IHJlY3QubGVmdCAmJiBjbGllbnRYIDw9IHJlY3QucmlnaHQgJiYgY2xpZW50WSA+PSByZWZSZWN0LmJvdHRvbSAtIDEgJiYgY2xpZW50WSA8PSByZWN0LmJvdHRvbTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgcmVjdFBvbHkgPSBbW3JlY3QucmlnaHQgLSAxLCByZWN0LmJvdHRvbV0sIFtyZWN0LnJpZ2h0IC0gMSwgcmVjdC50b3BdLCBbcmVmUmVjdC5sZWZ0ICsgMSwgcmVjdC50b3BdLCBbcmVmUmVjdC5sZWZ0ICsgMSwgcmVjdC5ib3R0b21dXTtcbiAgICAgICAgICBpc0luc2lkZVJlY3QgPSBjbGllbnRYID49IHJlY3QubGVmdCAmJiBjbGllbnRYIDw9IHJlZlJlY3QubGVmdCArIDEgJiYgY2xpZW50WSA+PSByZWN0LnRvcCAmJiBjbGllbnRZIDw9IHJlY3QuYm90dG9tO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgcmVjdFBvbHkgPSBbW3JlZlJlY3QucmlnaHQgLSAxLCByZWN0LmJvdHRvbV0sIFtyZWZSZWN0LnJpZ2h0IC0gMSwgcmVjdC50b3BdLCBbcmVjdC5sZWZ0ICsgMSwgcmVjdC50b3BdLCBbcmVjdC5sZWZ0ICsgMSwgcmVjdC5ib3R0b21dXTtcbiAgICAgICAgICBpc0luc2lkZVJlY3QgPSBjbGllbnRYID49IHJlZlJlY3QucmlnaHQgLSAxICYmIGNsaWVudFggPD0gcmVjdC5yaWdodCAmJiBjbGllbnRZID49IHJlY3QudG9wICYmIGNsaWVudFkgPD0gcmVjdC5ib3R0b207XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBnZXRQb2x5Z29uKF9yZWYzKSB7XG4gICAgICAgIGxldCBbeCwgeV0gPSBfcmVmMztcbiAgICAgICAgY29uc3QgaXNGbG9hdGluZ1dpZGVyID0gcmVjdC53aWR0aCA+IHJlZlJlY3Qud2lkdGg7XG4gICAgICAgIGNvbnN0IGlzRmxvYXRpbmdUYWxsZXIgPSByZWN0LmhlaWdodCA+IHJlZlJlY3QuaGVpZ2h0O1xuICAgICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludE9uZSA9IFtpc0Zsb2F0aW5nV2lkZXIgPyB4ICsgYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8geCArIGJ1ZmZlciAqIDQgOiB4IC0gYnVmZmVyICogNCwgeSArIGJ1ZmZlciArIDFdO1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludFR3byA9IFtpc0Zsb2F0aW5nV2lkZXIgPyB4IC0gYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8geCArIGJ1ZmZlciAqIDQgOiB4IC0gYnVmZmVyICogNCwgeSArIGJ1ZmZlciArIDFdO1xuICAgICAgICAgICAgICBjb25zdCBjb21tb25Qb2ludHMgPSBbW3JlY3QubGVmdCwgY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyByZWN0LmJvdHRvbSAtIGJ1ZmZlciA6IGlzRmxvYXRpbmdXaWRlciA/IHJlY3QuYm90dG9tIC0gYnVmZmVyIDogcmVjdC50b3BdLCBbcmVjdC5yaWdodCwgY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyBpc0Zsb2F0aW5nV2lkZXIgPyByZWN0LmJvdHRvbSAtIGJ1ZmZlciA6IHJlY3QudG9wIDogcmVjdC5ib3R0b20gLSBidWZmZXJdXTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjdXJzb3JQb2ludE9uZSwgY3Vyc29yUG9pbnRUd28sIC4uLmNvbW1vblBvaW50c107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRPbmUgPSBbaXNGbG9hdGluZ1dpZGVyID8geCArIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IHggKyBidWZmZXIgKiA0IDogeCAtIGJ1ZmZlciAqIDQsIHkgLSBidWZmZXJdO1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludFR3byA9IFtpc0Zsb2F0aW5nV2lkZXIgPyB4IC0gYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8geCArIGJ1ZmZlciAqIDQgOiB4IC0gYnVmZmVyICogNCwgeSAtIGJ1ZmZlcl07XG4gICAgICAgICAgICAgIGNvbnN0IGNvbW1vblBvaW50cyA9IFtbcmVjdC5sZWZ0LCBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IHJlY3QudG9wICsgYnVmZmVyIDogaXNGbG9hdGluZ1dpZGVyID8gcmVjdC50b3AgKyBidWZmZXIgOiByZWN0LmJvdHRvbV0sIFtyZWN0LnJpZ2h0LCBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IGlzRmxvYXRpbmdXaWRlciA/IHJlY3QudG9wICsgYnVmZmVyIDogcmVjdC5ib3R0b20gOiByZWN0LnRvcCArIGJ1ZmZlcl1dO1xuICAgICAgICAgICAgICByZXR1cm4gW2N1cnNvclBvaW50T25lLCBjdXJzb3JQb2ludFR3bywgLi4uY29tbW9uUG9pbnRzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRPbmUgPSBbeCArIGJ1ZmZlciArIDEsIGlzRmxvYXRpbmdUYWxsZXIgPyB5ICsgYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbUJvdHRvbSA/IHkgKyBidWZmZXIgKiA0IDogeSAtIGJ1ZmZlciAqIDRdO1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludFR3byA9IFt4ICsgYnVmZmVyICsgMSwgaXNGbG9hdGluZ1RhbGxlciA/IHkgLSBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tQm90dG9tID8geSArIGJ1ZmZlciAqIDQgOiB5IC0gYnVmZmVyICogNF07XG4gICAgICAgICAgICAgIGNvbnN0IGNvbW1vblBvaW50cyA9IFtbY3Vyc29yTGVhdmVGcm9tQm90dG9tID8gcmVjdC5yaWdodCAtIGJ1ZmZlciA6IGlzRmxvYXRpbmdUYWxsZXIgPyByZWN0LnJpZ2h0IC0gYnVmZmVyIDogcmVjdC5sZWZ0LCByZWN0LnRvcF0sIFtjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyBpc0Zsb2F0aW5nVGFsbGVyID8gcmVjdC5yaWdodCAtIGJ1ZmZlciA6IHJlY3QubGVmdCA6IHJlY3QucmlnaHQgLSBidWZmZXIsIHJlY3QuYm90dG9tXV07XG4gICAgICAgICAgICAgIHJldHVybiBbLi4uY29tbW9uUG9pbnRzLCBjdXJzb3JQb2ludE9uZSwgY3Vyc29yUG9pbnRUd29dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRPbmUgPSBbeCAtIGJ1ZmZlciwgaXNGbG9hdGluZ1RhbGxlciA/IHkgKyBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tQm90dG9tID8geSArIGJ1ZmZlciAqIDQgOiB5IC0gYnVmZmVyICogNF07XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50VHdvID0gW3ggLSBidWZmZXIsIGlzRmxvYXRpbmdUYWxsZXIgPyB5IC0gYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbUJvdHRvbSA/IHkgKyBidWZmZXIgKiA0IDogeSAtIGJ1ZmZlciAqIDRdO1xuICAgICAgICAgICAgICBjb25zdCBjb21tb25Qb2ludHMgPSBbW2N1cnNvckxlYXZlRnJvbUJvdHRvbSA/IHJlY3QubGVmdCArIGJ1ZmZlciA6IGlzRmxvYXRpbmdUYWxsZXIgPyByZWN0LmxlZnQgKyBidWZmZXIgOiByZWN0LnJpZ2h0LCByZWN0LnRvcF0sIFtjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyBpc0Zsb2F0aW5nVGFsbGVyID8gcmVjdC5sZWZ0ICsgYnVmZmVyIDogcmVjdC5yaWdodCA6IHJlY3QubGVmdCArIGJ1ZmZlciwgcmVjdC5ib3R0b21dXTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjdXJzb3JQb2ludE9uZSwgY3Vyc29yUG9pbnRUd28sIC4uLmNvbW1vblBvaW50c107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvbHkgPSBpc0luc2lkZVJlY3QgPyByZWN0UG9seSA6IGdldFBvbHlnb24oW3gsIHldKTtcbiAgICAgIGlmIChpc0luc2lkZVJlY3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChoYXNMYW5kZWQgJiYgIWlzT3ZlclJlZmVyZW5jZVJlY3QpIHtcbiAgICAgICAgcmV0dXJuIGNsb3NlKCk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzUG9pbnRJblBvbHlnb24oW2NsaWVudFgsIGNsaWVudFldLCBwb2x5KSkge1xuICAgICAgICBjbG9zZSgpO1xuICAgICAgfSBlbHNlIGlmIChyZXN0TXMgJiYgIWhhc0xhbmRlZCkge1xuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGNsb3NlLCByZXN0TXMpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIGZuLl9fb3B0aW9ucyA9IHtcbiAgICBibG9ja1BvaW50ZXJFdmVudHNcbiAgfTtcbiAgcmV0dXJuIGZuO1xufVxuXG5mdW5jdGlvbiB1c2VGbG9hdGluZyhvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4gPSBmYWxzZSxcbiAgICBvbk9wZW5DaGFuZ2U6IHVuc3RhYmxlX29uT3BlbkNoYW5nZSxcbiAgICBub2RlSWRcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHBvc2l0aW9uID0gdXNlRmxvYXRpbmckMShvcHRpb25zKTtcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBjb25zdCBkb21SZWZlcmVuY2VSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGRhdGFSZWYgPSBSZWFjdC51c2VSZWYoe30pO1xuICBjb25zdCBldmVudHMgPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBjcmVhdGVQdWJTdWIoKSlbMF07XG4gIGNvbnN0IFtkb21SZWZlcmVuY2UsIHNldERvbVJlZmVyZW5jZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3Qgc2V0UG9zaXRpb25SZWZlcmVuY2UgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBjb25zdCBwb3NpdGlvblJlZmVyZW5jZSA9IGlzRWxlbWVudChub2RlKSA/IHtcbiAgICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdDogKCkgPT4gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIGNvbnRleHRFbGVtZW50OiBub2RlXG4gICAgfSA6IG5vZGU7XG4gICAgcG9zaXRpb24ucmVmcy5zZXRSZWZlcmVuY2UocG9zaXRpb25SZWZlcmVuY2UpO1xuICB9LCBbcG9zaXRpb24ucmVmc10pO1xuICBjb25zdCBzZXRSZWZlcmVuY2UgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBpZiAoaXNFbGVtZW50KG5vZGUpIHx8IG5vZGUgPT09IG51bGwpIHtcbiAgICAgIGRvbVJlZmVyZW5jZVJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgIHNldERvbVJlZmVyZW5jZShub2RlKTtcbiAgICB9XG5cbiAgICAvLyBCYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgcGFzc2luZyBhIHZpcnR1YWwgZWxlbWVudCB0byBgcmVmZXJlbmNlYFxuICAgIC8vIGFmdGVyIGl0IGhhcyBzZXQgdGhlIERPTSByZWZlcmVuY2UuXG4gICAgaWYgKGlzRWxlbWVudChwb3NpdGlvbi5yZWZzLnJlZmVyZW5jZS5jdXJyZW50KSB8fCBwb3NpdGlvbi5yZWZzLnJlZmVyZW5jZS5jdXJyZW50ID09PSBudWxsIHx8XG4gICAgLy8gRG9uJ3QgYWxsb3cgc2V0dGluZyB2aXJ0dWFsIGVsZW1lbnRzIHVzaW5nIHRoZSBvbGQgdGVjaG5pcXVlIGJhY2sgdG9cbiAgICAvLyBgbnVsbGAgdG8gc3VwcG9ydCBgcG9zaXRpb25SZWZlcmVuY2VgICsgYW4gdW5zdGFibGUgYHJlZmVyZW5jZWBcbiAgICAvLyBjYWxsYmFjayByZWYuXG4gICAgbm9kZSAhPT0gbnVsbCAmJiAhaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgICBwb3NpdGlvbi5yZWZzLnNldFJlZmVyZW5jZShub2RlKTtcbiAgICB9XG4gIH0sIFtwb3NpdGlvbi5yZWZzXSk7XG4gIGNvbnN0IHJlZnMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgLi4ucG9zaXRpb24ucmVmcyxcbiAgICBzZXRSZWZlcmVuY2UsXG4gICAgc2V0UG9zaXRpb25SZWZlcmVuY2UsXG4gICAgZG9tUmVmZXJlbmNlOiBkb21SZWZlcmVuY2VSZWZcbiAgfSksIFtwb3NpdGlvbi5yZWZzLCBzZXRSZWZlcmVuY2UsIHNldFBvc2l0aW9uUmVmZXJlbmNlXSk7XG4gIGNvbnN0IGVsZW1lbnRzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIC4uLnBvc2l0aW9uLmVsZW1lbnRzLFxuICAgIGRvbVJlZmVyZW5jZTogZG9tUmVmZXJlbmNlXG4gIH0pLCBbcG9zaXRpb24uZWxlbWVudHMsIGRvbVJlZmVyZW5jZV0pO1xuICBjb25zdCBvbk9wZW5DaGFuZ2UgPSB1c2VFdmVudCh1bnN0YWJsZV9vbk9wZW5DaGFuZ2UpO1xuICBjb25zdCBjb250ZXh0ID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIC4uLnBvc2l0aW9uLFxuICAgIHJlZnMsXG4gICAgZWxlbWVudHMsXG4gICAgZGF0YVJlZixcbiAgICBub2RlSWQsXG4gICAgZXZlbnRzLFxuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlXG4gIH0pLCBbcG9zaXRpb24sIG5vZGVJZCwgZXZlbnRzLCBvcGVuLCBvbk9wZW5DaGFuZ2UsIHJlZnMsIGVsZW1lbnRzXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBjb25zdCBub2RlID0gdHJlZSA9PSBudWxsID8gdm9pZCAwIDogdHJlZS5ub2Rlc1JlZi5jdXJyZW50LmZpbmQobm9kZSA9PiBub2RlLmlkID09PSBub2RlSWQpO1xuICAgIGlmIChub2RlKSB7XG4gICAgICBub2RlLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgLi4ucG9zaXRpb24sXG4gICAgY29udGV4dCxcbiAgICByZWZzLFxuICAgIHJlZmVyZW5jZTogc2V0UmVmZXJlbmNlLFxuICAgIHBvc2l0aW9uUmVmZXJlbmNlOiBzZXRQb3NpdGlvblJlZmVyZW5jZVxuICB9KSwgW3Bvc2l0aW9uLCByZWZzLCBjb250ZXh0LCBzZXRSZWZlcmVuY2UsIHNldFBvc2l0aW9uUmVmZXJlbmNlXSk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHModXNlclByb3BzLCBwcm9wc0xpc3QsIGVsZW1lbnRLZXkpIHtcbiAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuICByZXR1cm4ge1xuICAgIC4uLihlbGVtZW50S2V5ID09PSAnZmxvYXRpbmcnICYmIHtcbiAgICAgIHRhYkluZGV4OiAtMVxuICAgIH0pLFxuICAgIC4uLnVzZXJQcm9wcyxcbiAgICAuLi5wcm9wc0xpc3QubWFwKHZhbHVlID0+IHZhbHVlID8gdmFsdWVbZWxlbWVudEtleV0gOiBudWxsKS5jb25jYXQodXNlclByb3BzKS5yZWR1Y2UoKGFjYywgcHJvcHMpID0+IHtcbiAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIE9iamVjdC5lbnRyaWVzKHByb3BzKS5mb3JFYWNoKF9yZWYgPT4ge1xuICAgICAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjtcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKCdvbicpID09PSAwKSB7XG4gICAgICAgICAgaWYgKCFtYXAuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIG1hcC5zZXQoa2V5LCBbXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBfbWFwJGdldDtcbiAgICAgICAgICAgIChfbWFwJGdldCA9IG1hcC5nZXQoa2V5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tYXAkZ2V0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgYWNjW2tleV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBfbWFwJGdldDI7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKF9tYXAkZ2V0MiA9IG1hcC5nZXQoa2V5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tYXAkZ2V0Mi5mb3JFYWNoKGZuID0+IGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSlcbiAgfTtcbn1cbmNvbnN0IHVzZUludGVyYWN0aW9ucyA9IGZ1bmN0aW9uIChwcm9wc0xpc3QpIHtcbiAgaWYgKHByb3BzTGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHNMaXN0ID0gW107XG4gIH1cbiAgLy8gVGhlIGRlcGVuZGVuY2llcyBhcmUgYSBkeW5hbWljIGFycmF5LCBzbyB3ZSBjYW4ndCB1c2UgdGhlIGxpbnRlcidzXG4gIC8vIHN1Z2dlc3Rpb24gdG8gYWRkIGl0IHRvIHRoZSBkZXBzIGFycmF5LlxuICBjb25zdCBkZXBzID0gcHJvcHNMaXN0O1xuICBjb25zdCBnZXRSZWZlcmVuY2VQcm9wcyA9IFJlYWN0LnVzZUNhbGxiYWNrKHVzZXJQcm9wcyA9PiBtZXJnZVByb3BzKHVzZXJQcm9wcywgcHJvcHNMaXN0LCAncmVmZXJlbmNlJyksXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgZGVwcyk7XG4gIGNvbnN0IGdldEZsb2F0aW5nUHJvcHMgPSBSZWFjdC51c2VDYWxsYmFjayh1c2VyUHJvcHMgPT4gbWVyZ2VQcm9wcyh1c2VyUHJvcHMsIHByb3BzTGlzdCwgJ2Zsb2F0aW5nJyksXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgZGVwcyk7XG4gIGNvbnN0IGdldEl0ZW1Qcm9wcyA9IFJlYWN0LnVzZUNhbGxiYWNrKHVzZXJQcm9wcyA9PiBtZXJnZVByb3BzKHVzZXJQcm9wcywgcHJvcHNMaXN0LCAnaXRlbScpLFxuICAvLyBHcmFudWxhcmx5IGNoZWNrIGZvciBgaXRlbWAgY2hhbmdlcywgYmVjYXVzZSB0aGUgYGdldEl0ZW1Qcm9wc2AgZ2V0dGVyXG4gIC8vIHNob3VsZCBiZSBhcyByZWZlcmVudGlhbGx5IHN0YWJsZSBhcyBwb3NzaWJsZSBzaW5jZSBpdCBtYXkgYmUgcGFzc2VkIGFzXG4gIC8vIGEgcHJvcCB0byBtYW55IGNvbXBvbmVudHMuIEFsbCBgaXRlbWAga2V5IHZhbHVlcyBtdXN0IHRoZXJlZm9yZSBiZVxuICAvLyBtZW1vaXplZC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBwcm9wc0xpc3QubWFwKGtleSA9PiBrZXkgPT0gbnVsbCA/IHZvaWQgMCA6IGtleS5pdGVtKSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgZ2V0UmVmZXJlbmNlUHJvcHMsXG4gICAgZ2V0RmxvYXRpbmdQcm9wcyxcbiAgICBnZXRJdGVtUHJvcHNcbiAgfSksIFtnZXRSZWZlcmVuY2VQcm9wcywgZ2V0RmxvYXRpbmdQcm9wcywgZ2V0SXRlbVByb3BzXSk7XG59O1xuXG5leHBvcnQgeyBGbG9hdGluZ0RlbGF5R3JvdXAsIEZsb2F0aW5nRm9jdXNNYW5hZ2VyLCBGbG9hdGluZ05vZGUsIEZsb2F0aW5nT3ZlcmxheSwgRmxvYXRpbmdQb3J0YWwsIEZsb2F0aW5nVHJlZSwgaW5uZXIsIHNhZmVQb2x5Z29uLCB1c2VDbGljaywgdXNlRGVsYXlHcm91cCwgdXNlRGVsYXlHcm91cENvbnRleHQsIHVzZURpc21pc3MsIHVzZUZsb2F0aW5nLCB1c2VGbG9hdGluZ05vZGVJZCwgdXNlRmxvYXRpbmdQYXJlbnROb2RlSWQsIHVzZUZsb2F0aW5nUG9ydGFsTm9kZSwgdXNlRmxvYXRpbmdUcmVlLCB1c2VGb2N1cywgdXNlSG92ZXIsIHVzZUlkLCB1c2VJbm5lck9mZnNldCwgdXNlSW50ZXJhY3Rpb25zLCB1c2VMaXN0TmF2aWdhdGlvbiwgdXNlTWVyZ2VSZWZzLCB1c2VSb2xlLCB1c2VUcmFuc2l0aW9uU3RhdHVzLCB1c2VUcmFuc2l0aW9uU3R5bGVzLCB1c2VUeXBlYWhlYWQgfTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsInVzZVJlZiIsImhpZGVPdGhlcnMiLCJ0YWJiYWJsZSIsImNyZWF0ZVBvcnRhbCIsImZsdXNoU3luYyIsImdldE92ZXJmbG93QW5jZXN0b3JzIiwib2Zmc2V0IiwiZGV0ZWN0T3ZlcmZsb3ciLCJ1c2VGbG9hdGluZyIsInVzZUZsb2F0aW5nJDEiLCJhcnJvdyIsImF1dG9QbGFjZW1lbnQiLCJhdXRvVXBkYXRlIiwiY29tcHV0ZVBvc2l0aW9uIiwiZmxpcCIsImhpZGUiLCJpbmxpbmUiLCJsaW1pdFNoaWZ0IiwicGxhdGZvcm0iLCJzaGlmdCIsInNpemUiLCJpbmRleCIsImRvY3VtZW50Iiwic2VydmVySGFuZG9mZkNvbXBsZXRlIiwiY291bnQiLCJnZW5JZCIsInVzZUZsb2F0aW5nSWQiLCJpZCIsInNldElkIiwidXNlU3RhdGUiLCJ1bmRlZmluZWQiLCJ1c2VSZWFjdElkIiwidG9TdHJpbmciLCJ1c2VJZCIsImNyZWF0ZVB1YlN1YiIsIm1hcCIsIk1hcCIsImVtaXQiLCJldmVudCIsImRhdGEiLCJfbWFwJGdldCIsImdldCIsImZvckVhY2giLCJoYW5kbGVyIiwib24iLCJsaXN0ZW5lciIsInNldCIsIm9mZiIsImZpbHRlciIsImwiLCJGbG9hdGluZ05vZGVDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsIkZsb2F0aW5nVHJlZUNvbnRleHQiLCJ1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCIsIl9SZWFjdCR1c2VDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZUZsb2F0aW5nVHJlZSIsInVzZUZsb2F0aW5nTm9kZUlkIiwiY3VzdG9tUGFyZW50SWQiLCJ0cmVlIiwicmVhY3RQYXJlbnRJZCIsInBhcmVudElkIiwibm9kZSIsImFkZE5vZGUiLCJyZW1vdmVOb2RlIiwiRmxvYXRpbmdOb2RlIiwiX3JlZiIsImNoaWxkcmVuIiwiY3JlYXRlRWxlbWVudCIsIlByb3ZpZGVyIiwidmFsdWUiLCJ1c2VNZW1vIiwiRmxvYXRpbmdUcmVlIiwiX3JlZjIiLCJub2Rlc1JlZiIsInVzZUNhbGxiYWNrIiwiY3VycmVudCIsIm4iLCJldmVudHMiLCJnZXREb2N1bWVudCIsIm93bmVyRG9jdW1lbnQiLCJnZXRQbGF0Zm9ybSIsInVhRGF0YSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudERhdGEiLCJnZXRVc2VyQWdlbnQiLCJBcnJheSIsImlzQXJyYXkiLCJicmFuZHMiLCJicmFuZCIsInZlcnNpb24iLCJqb2luIiwidXNlckFnZW50IiwiZ2V0V2luZG93IiwiZGVmYXVsdFZpZXciLCJ3aW5kb3ciLCJpc0VsZW1lbnQiLCJFbGVtZW50IiwiaXNIVE1MRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiaXNTaGFkb3dSb290IiwiU2hhZG93Um9vdCIsIk93bkVsZW1lbnQiLCJpc1ZpcnR1YWxDbGljayIsIm1veklucHV0U291cmNlIiwiaXNUcnVzdGVkIiwiYW5kcm9pZFJlIiwidGVzdCIsInBvaW50ZXJUeXBlIiwidHlwZSIsImJ1dHRvbnMiLCJkZXRhaWwiLCJpc1ZpcnR1YWxQb2ludGVyRXZlbnQiLCJ3aWR0aCIsImhlaWdodCIsInByZXNzdXJlIiwiaXNTYWZhcmkiLCJ2ZW5kb3IiLCJpc01hYyIsInRvTG93ZXJDYXNlIiwic3RhcnRzV2l0aCIsIm1heFRvdWNoUG9pbnRzIiwiaXNNb3VzZUxpa2VQb2ludGVyVHlwZSIsInN0cmljdCIsInZhbHVlcyIsInB1c2giLCJpbmNsdWRlcyIsInVzZUxhdGVzdFJlZiIsInJlZiIsInNhZmVQb2x5Z29uSWRlbnRpZmllciIsImdldERlbGF5IiwicHJvcCIsInVzZUhvdmVyIiwiY29udGV4dCIsIl90ZW1wIiwiZW5hYmxlZCIsImRlbGF5IiwiaGFuZGxlQ2xvc2UiLCJtb3VzZU9ubHkiLCJyZXN0TXMiLCJtb3ZlIiwib3BlbiIsIm9uT3BlbkNoYW5nZSIsImRhdGFSZWYiLCJlbGVtZW50cyIsImRvbVJlZmVyZW5jZSIsImZsb2F0aW5nIiwicmVmcyIsImhhbmRsZUNsb3NlUmVmIiwiZGVsYXlSZWYiLCJwb2ludGVyVHlwZVJlZiIsInRpbWVvdXRSZWYiLCJoYW5kbGVyUmVmIiwicmVzdFRpbWVvdXRSZWYiLCJibG9ja01vdXNlTW92ZVJlZiIsInBlcmZvcm1lZFBvaW50ZXJFdmVudHNNdXRhdGlvblJlZiIsInVuYmluZE1vdXNlTW92ZVJlZiIsImlzSG92ZXJPcGVuIiwiX2RhdGFSZWYkY3VycmVudCRvcGVuIiwib3BlbkV2ZW50Iiwib25EaXNtaXNzIiwiY2xlYXJUaW1lb3V0Iiwib25MZWF2ZSIsImh0bWwiLCJkb2N1bWVudEVsZW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNsb3NlV2l0aERlbGF5IiwicnVuRWxzZUJyYW5jaCIsImNsb3NlRGVsYXkiLCJzZXRUaW1lb3V0IiwiY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIiLCJjbGVhclBvaW50ZXJFdmVudHMiLCJib2R5Iiwic3R5bGUiLCJwb2ludGVyRXZlbnRzIiwicmVtb3ZlQXR0cmlidXRlIiwiaXNDbGlja0xpa2VPcGVuRXZlbnQiLCJvbk1vdXNlRW50ZXIiLCJvcGVuRGVsYXkiLCJvbk1vdXNlTGVhdmUiLCJkb2MiLCJ4IiwiY2xpZW50WCIsInkiLCJjbGllbnRZIiwib25DbG9zZSIsIm9uU2Nyb2xsTW91c2VMZWF2ZSIsIm9uY2UiLCJfaGFuZGxlQ2xvc2VSZWYkY3VycmUiLCJfX29wdGlvbnMiLCJibG9ja1BvaW50ZXJFdmVudHMiLCJzZXRBdHRyaWJ1dGUiLCJfdHJlZSRub2Rlc1JlZiRjdXJyZW4iLCJfdHJlZSRub2Rlc1JlZiRjdXJyZW4yIiwicGFyZW50RmxvYXRpbmciLCJmaW5kIiwic2V0UG9pbnRlclJlZiIsInJlZmVyZW5jZSIsIm9uUG9pbnRlckRvd24iLCJvblBvaW50ZXJFbnRlciIsIm9uTW91c2VNb3ZlIiwicmV0dXJuRm9jdXMiLCJGbG9hdGluZ0RlbGF5R3JvdXBDb250ZXh0IiwiaW5pdGlhbERlbGF5IiwidGltZW91dE1zIiwiY3VycmVudElkIiwic2V0Q3VycmVudElkIiwic2V0U3RhdGUiLCJpc0luc3RhbnRQaGFzZSIsInVzZURlbGF5R3JvdXBDb250ZXh0IiwiRmxvYXRpbmdEZWxheUdyb3VwIiwic3RhdGUiLCJ1c2VSZWR1Y2VyIiwicHJldiIsIm5leHQiLCJpbml0aWFsQ3VycmVudElkUmVmIiwidXNlRGVsYXlHcm91cCIsIl9yZWYzIiwiY2xvc2UiLCJ1bnNldCIsInRpbWVvdXQiLCJfZXh0ZW5kcyIsIk9iamVjdCIsImFzc2lnbiIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsImFjdGl2ZUVsZW1lbnQkMSIsImFjdGl2ZUVsZW1lbnQiLCJfYWN0aXZlRWxlbWVudCIsIl9hY3RpdmVFbGVtZW50JHNoYWRvdyIsInNoYWRvd1Jvb3QiLCJjb250YWlucyIsInBhcmVudCIsImNoaWxkIiwicm9vdE5vZGUiLCJnZXRSb290Tm9kZSIsInBhcmVudE5vZGUiLCJob3N0IiwicmFmSWQiLCJlbnF1ZXVlRm9jdXMiLCJlbCIsIm9wdGlvbnMiLCJwcmV2ZW50U2Nyb2xsIiwiY2FuY2VsUHJldmlvdXMiLCJzeW5jIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJleGVjIiwiZm9jdXMiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJnZXRBbmNlc3RvcnMiLCJub2RlcyIsIl9ub2RlcyRmaW5kIiwiYWxsQW5jZXN0b3JzIiwiY3VycmVudFBhcmVudElkIiwiY3VycmVudE5vZGUiLCJjb25jYXQiLCJnZXRDaGlsZHJlbiIsImFsbENoaWxkcmVuIiwiX25vZGUkY29udGV4dCIsImN1cnJlbnRDaGlsZHJlbiIsIl9jdXJyZW50Q2hpbGRyZW4iLCJzb21lIiwiX25vZGUkY29udGV4dDIiLCJnZXRUYXJnZXQiLCJjb21wb3NlZFBhdGgiLCJUWVBFQUJMRV9TRUxFQ1RPUiIsImlzVHlwZWFibGVFbGVtZW50IiwiZWxlbWVudCIsIm1hdGNoZXMiLCJzdG9wRXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsImdldFRhYmJhYmxlT3B0aW9ucyIsImdldFNoYWRvd1Jvb3QiLCJkaXNwbGF5Q2hlY2siLCJSZXNpemVPYnNlcnZlciIsImdldFRhYmJhYmxlSW4iLCJjb250YWluZXIiLCJkaXJlY3Rpb24iLCJhbGxUYWJiYWJsZSIsInJldmVyc2UiLCJhY3RpdmVJbmRleCIsImluZGV4T2YiLCJuZXh0VGFiYmFibGVFbGVtZW50cyIsInNsaWNlIiwiZ2V0TmV4dFRhYmJhYmxlIiwiZ2V0UHJldmlvdXNUYWJiYWJsZSIsImlzT3V0c2lkZUV2ZW50IiwiY29udGFpbmVyRWxlbWVudCIsImN1cnJlbnRUYXJnZXQiLCJyZWxhdGVkVGFyZ2V0IiwiZGlzYWJsZUZvY3VzSW5zaWRlIiwidGFiYmFibGVFbGVtZW50cyIsImRhdGFzZXQiLCJ0YWJpbmRleCIsImdldEF0dHJpYnV0ZSIsImVuYWJsZUZvY3VzSW5zaWRlIiwicXVlcnlTZWxlY3RvckFsbCIsInVzZUluc2VydGlvbkVmZmVjdCIsInVzZVNhZmVJbnNlcnRpb25FZmZlY3QiLCJmbiIsInVzZUV2ZW50IiwiY2FsbGJhY2siLCJwcm9jZXNzIiwiRXJyb3IiLCJfbGVuIiwiYXJncyIsIl9rZXkiLCJISURERU5fU1RZTEVTIiwiYm9yZGVyIiwiY2xpcCIsIm1hcmdpbiIsIm92ZXJmbG93IiwicGFkZGluZyIsInBvc2l0aW9uIiwid2hpdGVTcGFjZSIsInRvcCIsImxlZnQiLCJ0aW1lb3V0SWQiLCJzZXRBY3RpdmVFbGVtZW50T25UYWIiLCJpc1RhYkZvY3VzIiwicmVzdWx0IiwiRm9jdXNHdWFyZCIsImZvcndhcmRSZWYiLCJwcm9wcyIsIm9uRm9jdXMiLCJyb2xlIiwic2V0Um9sZSIsInRhYkluZGV4IiwicGVyc2lzdCIsIlBvcnRhbENvbnRleHQiLCJ1c2VGbG9hdGluZ1BvcnRhbE5vZGUiLCJwb3J0YWxFbCIsInNldFBvcnRhbEVsIiwidW5pcXVlSWQiLCJwb3J0YWxDb250ZXh0IiwidXNlUG9ydGFsQ29udGV4dCIsImdldEVsZW1lbnRCeUlkIiwibmV3UG9ydGFsRWwiLCJwb3J0YWxOb2RlIiwiYXBwZW5kQ2hpbGQiLCJyZW1vdmVDaGlsZCIsIkZsb2F0aW5nUG9ydGFsIiwicm9vdCIsInByZXNlcnZlVGFiT3JkZXIiLCJmb2N1c01hbmFnZXJTdGF0ZSIsInNldEZvY3VzTWFuYWdlclN0YXRlIiwiYmVmb3JlT3V0c2lkZVJlZiIsImFmdGVyT3V0c2lkZVJlZiIsImJlZm9yZUluc2lkZVJlZiIsImFmdGVySW5zaWRlUmVmIiwic2hvdWxkUmVuZGVyR3VhcmRzIiwibW9kYWwiLCJmb2N1c2luZyIsIm1hbmFnZUZvY3VzIiwiX2JlZm9yZUluc2lkZVJlZiRjdXJyIiwicHJldlRhYmJhYmxlIiwiX2FmdGVySW5zaWRlUmVmJGN1cnJlIiwibmV4dFRhYmJhYmxlIiwiY2xvc2VPbkZvY3VzT3V0IiwiVmlzdWFsbHlIaWRkZW5EaXNtaXNzIiwiRmxvYXRpbmdGb2N1c01hbmFnZXIiLCJvcmRlciIsImd1YXJkcyIsImluaXRpYWxGb2N1cyIsInZpc3VhbGx5SGlkZGVuRGlzbWlzcyIsIm5vZGVJZCIsIm9yZGVyUmVmIiwidGFiYmFibGVDb250ZW50TGVuZ3RoIiwic2V0VGFiYmFibGVDb250ZW50TGVuZ3RoIiwiaWdub3JlSW5pdGlhbEZvY3VzIiwic3RhcnREaXNtaXNzQnV0dG9uUmVmIiwiZW5kRGlzbWlzc0J1dHRvblJlZiIsInByZXZlbnRSZXR1cm5Gb2N1c1JlZiIsInByZXZpb3VzbHlGb2N1c2VkRWxlbWVudFJlZiIsImlzUG9pbnRlckRvd25SZWYiLCJpc0luc2lkZVBvcnRhbCIsImlzVHlwZWFibGVDb21ib2JveCIsImdldFRhYmJhYmxlQ29udGVudCIsImdldFRhYmJhYmxlRWxlbWVudHMiLCJjb250ZW50IiwiQm9vbGVhbiIsImZsYXQiLCJvbktleURvd24iLCJlbHMiLCJzaGlmdEtleSIsImhhbmRsZVBvaW50ZXJEb3duIiwiaGFuZGxlRm9jdXNPdXRzaWRlIiwibW92ZWRUb1VucmVsYXRlZE5vZGUiLCJoYXNBdHRyaWJ1dGUiLCJfbm9kZSRjb250ZXh0MyIsIl9ub2RlJGNvbnRleHQ0IiwiX3BvcnRhbENvbnRleHQkcG9ydGFsIiwicG9ydGFsTm9kZXMiLCJmcm9tIiwiZ2V0RGlzbWlzc0J1dHRvbnMiLCJpbnNpZGVOb2RlcyIsImNsZWFudXAiLCJ0YWJJbmRleFZhbHVlcyIsImZsb2F0aW5nVGFiYmFibGUiLCJyZXR1cm5Gb2N1c1ZhbHVlIiwicHJldmVudFJldHVybkZvY3VzU2Nyb2xsIiwicHJldmlvdXNseUZvY3VzZWRFbGVtZW50IiwiY29udGV4dERhdGEiLCJmb2N1c2FibGVFbGVtZW50cyIsImVsVG9Gb2N1cyIsInBheWxvYWQiLCJfcHJldmlvdXNseUZvY3VzZWRFbGUiLCJfX3N5bmNSZXR1cm5Gb2N1cyIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlciIsIm9ic2VydmUiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwiZGlzY29ubmVjdCIsInJlbmRlckRpc21pc3NCdXR0b24iLCJsb2NhdGlvbiIsIm9uQ2xpY2siLCJGcmFnbWVudCIsIl9wb3J0YWxDb250ZXh0JGJlZm9yZSIsImNsb25lRWxlbWVudCIsIl9wb3J0YWxDb250ZXh0JGFmdGVyTyIsImlkZW50aWZpZXIiLCJGbG9hdGluZ092ZXJsYXkiLCJsb2NrU2Nyb2xsIiwicmVzdCIsIl93aW5kb3ckdmlzdWFsVmlld3BvciIsIl93aW5kb3ckdmlzdWFsVmlld3BvcjIiLCJhbHJlYWR5TG9ja2VkIiwic2Nyb2xsYmFyWCIsIk1hdGgiLCJyb3VuZCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInNjcm9sbExlZnQiLCJwYWRkaW5nUHJvcCIsInNjcm9sbGJhcldpZHRoIiwiaW5uZXJXaWR0aCIsImNsaWVudFdpZHRoIiwib2Zmc2V0TGVmdCIsInZpc3VhbFZpZXdwb3J0Iiwib2Zmc2V0VG9wIiwic2Nyb2xsWCIsInBhZ2VYT2Zmc2V0Iiwic2Nyb2xsWSIsInBhZ2VZT2Zmc2V0IiwiZmxvb3IiLCJyaWdodCIsInNjcm9sbFRvIiwiYm90dG9tIiwiaXNCdXR0b25UYXJnZXQiLCJ0YWdOYW1lIiwiaXNTcGFjZUlnbm9yZWQiLCJ1c2VDbGljayIsImV2ZW50T3B0aW9uIiwidG9nZ2xlIiwiaWdub3JlTW91c2UiLCJrZXlib2FyZEhhbmRsZXJzIiwib25Nb3VzZURvd24iLCJidXR0b24iLCJuYXRpdmVFdmVudCIsIm9uS2V5VXAiLCJpc0V2ZW50VGFyZ2V0V2l0aGluIiwiZSIsImJ1YmJsZUhhbmRsZXJLZXlzIiwicG9pbnRlcmRvd24iLCJtb3VzZWRvd24iLCJjbGljayIsImNhcHR1cmVIYW5kbGVyS2V5cyIsIm5vcm1hbGl6ZUJ1YmJsZXNQcm9wIiwiYnViYmxlcyIsIl9idWJibGVzJGVzY2FwZUtleSIsIl9idWJibGVzJG91dHNpZGVQcmVzcyIsImVzY2FwZUtleUJ1YmJsZXMiLCJlc2NhcGVLZXkiLCJvdXRzaWRlUHJlc3NCdWJibGVzIiwib3V0c2lkZVByZXNzIiwidXNlRGlzbWlzcyIsInVuc3RhYmxlX291dHNpZGVQcmVzcyIsIm91dHNpZGVQcmVzc0V2ZW50IiwicmVmZXJlbmNlUHJlc3MiLCJyZWZlcmVuY2VQcmVzc0V2ZW50IiwiYW5jZXN0b3JTY3JvbGwiLCJuZXN0ZWQiLCJvdXRzaWRlUHJlc3NGbiIsImluc2lkZVJlYWN0VHJlZVJlZiIsIl9fZXNjYXBlS2V5QnViYmxlcyIsIl9fb3V0c2lkZVByZXNzQnViYmxlcyIsInNob3VsZERpc21pc3MiLCJfY2hpbGQkY29udGV4dCIsIm9uT3V0c2lkZVByZXNzIiwiaW5zaWRlUmVhY3RUcmVlIiwid2luIiwiY2FuU2Nyb2xsWCIsInNjcm9sbFdpZHRoIiwiY2FuU2Nyb2xsWSIsInNjcm9sbEhlaWdodCIsImNsaWVudEhlaWdodCIsInhDb25kIiwib2Zmc2V0WCIsImlzUlRMIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIm9mZnNldFdpZHRoIiwib2Zmc2V0WSIsInRhcmdldElzSW5zaWRlQ2hpbGRyZW4iLCJfY2hpbGQkY29udGV4dDIiLCJvblNjcm9sbCIsImFuY2VzdG9ycyIsImNvbnRleHRFbGVtZW50IiwiYW5jZXN0b3IiLCJfZG9jJGRlZmF1bHRWaWV3IiwicGFzc2l2ZSIsInVzZUZvY3VzIiwia2V5Ym9hcmRPbmx5IiwiYmxvY2tGb2N1c1JlZiIsIm9uQmx1ciIsIm1vdmVkVG9Gb2N1c0d1YXJkIiwiaXNQcmV2ZW50U2Nyb2xsU3VwcG9ydGVkIiwiQVJST1dfVVAiLCJBUlJPV19ET1dOIiwiQVJST1dfTEVGVCIsIkFSUk9XX1JJR0hUIiwiaXNEaWZmZXJlbnRSb3ciLCJjb2xzIiwicHJldlJvdyIsImlzSW5kZXhPdXRPZkJvdW5kcyIsImxpc3RSZWYiLCJmaW5kTm9uRGlzYWJsZWRJbmRleCIsInN0YXJ0aW5nSW5kZXgiLCJkZWNyZW1lbnQiLCJkaXNhYmxlZEluZGljZXMiLCJhbW91bnQiLCJsaXN0IiwiX2xpc3QkaW5kZXgiLCJfbGlzdCRpbmRleDIiLCJkb1N3aXRjaCIsIm9yaWVudGF0aW9uIiwidmVydGljYWwiLCJob3Jpem9udGFsIiwiaXNNYWluT3JpZW50YXRpb25LZXkiLCJpc01haW5PcmllbnRhdGlvblRvRW5kS2V5IiwicnRsIiwiaXNDcm9zc09yaWVudGF0aW9uT3BlbktleSIsImlzQ3Jvc3NPcmllbnRhdGlvbkNsb3NlS2V5IiwiZ2V0TWluSW5kZXgiLCJnZXRNYXhJbmRleCIsInVzZUxpc3ROYXZpZ2F0aW9uIiwiX3RlbXAyIiwib25OYXZpZ2F0ZSIsInVuc3RhYmxlX29uTmF2aWdhdGUiLCJzZWxlY3RlZEluZGV4IiwiYWxsb3dFc2NhcGUiLCJsb29wIiwidmlydHVhbCIsImZvY3VzSXRlbU9uT3BlbiIsImZvY3VzSXRlbU9uSG92ZXIiLCJvcGVuT25BcnJvd0tleURvd24iLCJzY3JvbGxJdGVtSW50b1ZpZXciLCJjb25zb2xlIiwid2FybiIsImZvY3VzSXRlbU9uT3BlblJlZiIsImluZGV4UmVmIiwia2V5UmVmIiwiaXNQb2ludGVyTW9kYWxpdHlSZWYiLCJwcmV2aW91c09uTmF2aWdhdGVSZWYiLCJwcmV2aW91c09wZW5SZWYiLCJmb3JjZVN5bmNGb2N1cyIsImZvcmNlU2Nyb2xsSW50b1ZpZXdSZWYiLCJkaXNhYmxlZEluZGljZXNSZWYiLCJsYXRlc3RPcGVuUmVmIiwic2Nyb2xsSXRlbUludG9WaWV3UmVmIiwiYWN0aXZlSWQiLCJzZXRBY3RpdmVJZCIsImZvY3VzSXRlbSIsImZvcmNlU2Nyb2xsSW50b1ZpZXciLCJpdGVtIiwic2Nyb2xsSW50b1ZpZXdPcHRpb25zIiwic2hvdWxkU2Nyb2xsSW50b1ZpZXciLCJzY3JvbGxJbnRvVmlldyIsImJsb2NrIiwiaGFzQWN0aXZlSW5kZXgiLCJzeW5jQ3VycmVudFRhcmdldCIsIl9yZWY0Iiwib25Qb2ludGVyTGVhdmUiLCJfcmVmcyRmbG9hdGluZyRjdXJyZW4iLCJjdXJyZW50SW5kZXgiLCJtaW5JbmRleCIsIm1heEluZGV4IiwicHJldkluZGV4IiwiY29sIiwibWF4Q29sIiwibGFzdFJvdyIsIm1pbiIsIm1heCIsImNoZWNrVmlydHVhbE1vdXNlIiwiY2hlY2tWaXJ0dWFsUG9pbnRlciIsImFyaWFBY3RpdmVEZXNjZW5kYW50UHJvcCIsImlzQXJyb3dLZXkiLCJpc05hdmlnYXRpb25LZXkiLCJvblBvaW50ZXJNb3ZlIiwidXNlTWVyZ2VSZWZzIiwiZXZlcnkiLCJ1c2VSb2xlIiwicm9vdElkIiwicmVmZXJlbmNlSWQiLCJmbG9hdGluZ1Byb3BzIiwiY2FtZWxDYXNlVG9LZWJhYkNhc2UiLCJzdHIiLCJyZXBsYWNlIiwiJCIsIm9mcyIsInVzZURlbGF5VW5tb3VudCIsImR1cmF0aW9uTXMiLCJpc01vdW50ZWQiLCJzZXRJc01vdW50ZWQiLCJ1c2VUcmFuc2l0aW9uU3RhdHVzIiwiZHVyYXRpb24iLCJpc051bWJlckR1cmF0aW9uIiwiY2xvc2VEdXJhdGlvbiIsImluaXRpYXRlZCIsInNldEluaXRpYXRlZCIsInN0YXR1cyIsInNldFN0YXR1cyIsImZyYW1lIiwidXNlVHJhbnNpdGlvblN0eWxlcyIsImluaXRpYWwiLCJ1bnN0YWJsZV9pbml0aWFsIiwib3BhY2l0eSIsInVuc3RhYmxlX29wZW4iLCJ1bnN0YWJsZV9jbG9zZSIsImNvbW1vbiIsInVuc3RhYmxlX2NvbW1vbiIsInBsYWNlbWVudCIsInNpZGUiLCJzcGxpdCIsInN0eWxlcyIsInNldFN0eWxlcyIsImluaXRpYWxSZWYiLCJvcGVuUmVmIiwiY2xvc2VSZWYiLCJjb21tb25SZWYiLCJvcGVuRHVyYXRpb24iLCJmbkFyZ3MiLCJpbml0aWFsU3R5bGVzIiwiY2xvc2VTdHlsZXMiLCJjb21tb25TdHlsZXMiLCJvcGVuU3R5bGVzIiwia2V5cyIsInJlZHVjZSIsImFjYyIsInRyYW5zaXRpb25Qcm9wZXJ0eSIsInRyYW5zaXRpb25EdXJhdGlvbiIsInVzZVR5cGVhaGVhZCIsIm9uTWF0Y2giLCJ1bnN0YWJsZV9vbk1hdGNoIiwiZmluZE1hdGNoIiwicmVzZXRNcyIsImlnbm9yZUtleXMiLCJ0aW1lb3V0SWRSZWYiLCJzdHJpbmdSZWYiLCJwcmV2SW5kZXhSZWYiLCJtYXRjaEluZGV4UmVmIiwiZmluZE1hdGNoUmVmIiwiaWdub3JlS2V5c1JlZiIsImNsb3Nlc3QiLCJ0eXBpbmciLCJsaXN0Q29udGVudCIsImN0cmxLZXkiLCJtZXRhS2V5IiwiYWx0S2V5IiwiYWxsb3dSYXBpZFN1Y2Nlc3Npb25PZkZpcnN0TGV0dGVyIiwidGV4dCIsIl90ZXh0JCIsIl90ZXh0JDIiLCJ0b0xvY2FsZUxvd2VyQ2FzZSIsIm9yZGVyZWRMaXN0IiwiZ2V0QXJnc1dpdGhDdXN0b21GbG9hdGluZ0hlaWdodCIsInJlY3RzIiwiaW5uZXIiLCJuYW1lIiwibWlkZGxld2FyZUFyZ3VtZW50cyIsIm92ZXJmbG93UmVmIiwib25GYWxsYmFja0NoYW5nZSIsImlubmVyT2Zmc2V0IiwibWluSXRlbXNWaXNpYmxlIiwicmVmZXJlbmNlT3ZlcmZsb3dUaHJlc2hvbGQiLCJzY3JvbGxSZWYiLCJkZXRlY3RPdmVyZmxvd09wdGlvbnMiLCJuZXh0QXJncyIsIm9mZnNldEhlaWdodCIsInJlZk92ZXJmbG93IiwiZWxlbWVudENvbnRleHQiLCJkaWZmWSIsIm5leHRZIiwibWF4SGVpZ2h0Iiwic2Nyb2xsVG9wIiwidXNlSW5uZXJPZmZzZXQiLCJvbkNoYW5nZSIsInVuc3RhYmxlX29uQ2hhbmdlIiwiY29udHJvbGxlZFNjcm9sbGluZ1JlZiIsInByZXZTY3JvbGxUb3BSZWYiLCJpbml0aWFsT3ZlcmZsb3dSZWYiLCJvbldoZWVsIiwiZFkiLCJkZWx0YVkiLCJpc0F0VG9wIiwiaXNBdEJvdHRvbSIsInJlbWFpbmluZ1Njcm9sbCIsInNpZ24iLCJtZXRob2QiLCJkIiwic2Nyb2xsRGlmZiIsImlzUG9pbnRJblBvbHlnb24iLCJwb2ludCIsInBvbHlnb24iLCJpc0luc2lkZSIsImoiLCJ4aSIsInlpIiwieGoiLCJ5aiIsImludGVyc2VjdCIsInJlY3QiLCJzYWZlUG9seWdvbiIsImJ1ZmZlciIsImlzSW5zaWRlUmVjdCIsImhhc0xhbmRlZCIsImNsaWVudFBvaW50IiwiaXNMZWF2ZSIsImlzT3ZlckZsb2F0aW5nRWwiLCJpc092ZXJSZWZlcmVuY2VFbCIsInJlZlJlY3QiLCJjdXJzb3JMZWF2ZUZyb21SaWdodCIsImN1cnNvckxlYXZlRnJvbUJvdHRvbSIsImlzT3ZlclJlZmVyZW5jZVJlY3QiLCJyZWN0UG9seSIsImdldFBvbHlnb24iLCJpc0Zsb2F0aW5nV2lkZXIiLCJpc0Zsb2F0aW5nVGFsbGVyIiwiY3Vyc29yUG9pbnRPbmUiLCJjdXJzb3JQb2ludFR3byIsImNvbW1vblBvaW50cyIsInBvbHkiLCJ1bnN0YWJsZV9vbk9wZW5DaGFuZ2UiLCJkb21SZWZlcmVuY2VSZWYiLCJzZXREb21SZWZlcmVuY2UiLCJzZXRQb3NpdGlvblJlZmVyZW5jZSIsInBvc2l0aW9uUmVmZXJlbmNlIiwic2V0UmVmZXJlbmNlIiwibWVyZ2VQcm9wcyIsInVzZXJQcm9wcyIsInByb3BzTGlzdCIsImVsZW1lbnRLZXkiLCJlbnRyaWVzIiwiaGFzIiwiX21hcCRnZXQyIiwidXNlSW50ZXJhY3Rpb25zIiwiZGVwcyIsImdldFJlZmVyZW5jZVByb3BzIiwiZ2V0RmxvYXRpbmdQcm9wcyIsImdldEl0ZW1Qcm9wcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@floating-ui/core/dist/floating-ui.core.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),\n/* harmony export */   computePosition: () => (/* binding */ computePosition),\n/* harmony export */   detectOverflow: () => (/* binding */ detectOverflow),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   inline: () => (/* binding */ inline),\n/* harmony export */   limitShift: () => (/* binding */ limitShift),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   rectToClientRect: () => (/* reexport safe */ _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   size: () => (/* binding */ size)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n    let { reference, floating } = _ref;\n    const sideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);\n    const alignmentAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);\n    const alignLength = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(alignmentAxis);\n    const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n    const isVertical = sideAxis === \"y\";\n    const commonX = reference.x + reference.width / 2 - floating.width / 2;\n    const commonY = reference.y + reference.height / 2 - floating.height / 2;\n    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n    let coords;\n    switch(side){\n        case \"top\":\n            coords = {\n                x: commonX,\n                y: reference.y - floating.height\n            };\n            break;\n        case \"bottom\":\n            coords = {\n                x: commonX,\n                y: reference.y + reference.height\n            };\n            break;\n        case \"right\":\n            coords = {\n                x: reference.x + reference.width,\n                y: commonY\n            };\n            break;\n        case \"left\":\n            coords = {\n                x: reference.x - floating.width,\n                y: commonY\n            };\n            break;\n        default:\n            coords = {\n                x: reference.x,\n                y: reference.y\n            };\n    }\n    switch((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement)){\n        case \"start\":\n            coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n            break;\n        case \"end\":\n            coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n            break;\n    }\n    return coords;\n}\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */ const computePosition = async (reference, floating, config)=>{\n    const { placement = \"bottom\", strategy = \"absolute\", middleware = [], platform } = config;\n    const validMiddleware = middleware.filter(Boolean);\n    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n    let rects = await platform.getElementRects({\n        reference,\n        floating,\n        strategy\n    });\n    let { x, y } = computeCoordsFromPlacement(rects, placement, rtl);\n    let statefulPlacement = placement;\n    let middlewareData = {};\n    let resetCount = 0;\n    for(let i = 0; i < validMiddleware.length; i++){\n        const { name, fn } = validMiddleware[i];\n        const { x: nextX, y: nextY, data, reset } = await fn({\n            x,\n            y,\n            initialPlacement: placement,\n            placement: statefulPlacement,\n            strategy,\n            middlewareData,\n            rects,\n            platform,\n            elements: {\n                reference,\n                floating\n            }\n        });\n        x = nextX != null ? nextX : x;\n        y = nextY != null ? nextY : y;\n        middlewareData = {\n            ...middlewareData,\n            [name]: {\n                ...middlewareData[name],\n                ...data\n            }\n        };\n        if (reset && resetCount <= 50) {\n            resetCount++;\n            if (typeof reset === \"object\") {\n                if (reset.placement) {\n                    statefulPlacement = reset.placement;\n                }\n                if (reset.rects) {\n                    rects = reset.rects === true ? await platform.getElementRects({\n                        reference,\n                        floating,\n                        strategy\n                    }) : reset.rects;\n                }\n                ({ x, y } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n            }\n            i = -1;\n        }\n    }\n    return {\n        x,\n        y,\n        placement: statefulPlacement,\n        strategy,\n        middlewareData\n    };\n};\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */ async function detectOverflow(state, options) {\n    var _await$platform$isEle;\n    if (options === void 0) {\n        options = {};\n    }\n    const { x, y, platform, rects, elements, strategy } = state;\n    const { boundary = \"clippingAncestors\", rootBoundary = \"viewport\", elementContext = \"floating\", altBoundary = false, padding = 0 } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n    const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n    const altContext = elementContext === \"floating\" ? \"reference\" : \"floating\";\n    const element = elements[altBoundary ? altContext : elementContext];\n    const clippingClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(await platform.getClippingRect({\n        element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating)),\n        boundary,\n        rootBoundary,\n        strategy\n    }));\n    const rect = elementContext === \"floating\" ? {\n        x,\n        y,\n        width: rects.floating.width,\n        height: rects.floating.height\n    } : rects.reference;\n    const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n    const offsetScale = await (platform.isElement == null ? void 0 : platform.isElement(offsetParent)) ? await (platform.getScale == null ? void 0 : platform.getScale(offsetParent)) || {\n        x: 1,\n        y: 1\n    } : {\n        x: 1,\n        y: 1\n    };\n    const elementClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n        elements,\n        rect,\n        offsetParent,\n        strategy\n    }) : rect);\n    return {\n        top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n        bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n        left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n        right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n    };\n}\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */ const arrow = (options)=>({\n        name: \"arrow\",\n        options,\n        async fn (state) {\n            const { x, y, placement, rects, platform, elements, middlewareData } = state;\n            // Since `element` is required, we don't Partial<> the type.\n            const { element, padding = 0 } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state) || {};\n            if (element == null) {\n                return {};\n            }\n            const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n            const coords = {\n                x,\n                y\n            };\n            const axis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);\n            const length = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(axis);\n            const arrowDimensions = await platform.getDimensions(element);\n            const isYAxis = axis === \"y\";\n            const minProp = isYAxis ? \"top\" : \"left\";\n            const maxProp = isYAxis ? \"bottom\" : \"right\";\n            const clientProp = isYAxis ? \"clientHeight\" : \"clientWidth\";\n            const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n            const startDiff = coords[axis] - rects.reference[axis];\n            const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n            let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n            // DOM platform can return `window` as the `offsetParent`.\n            if (!clientSize || !await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent))) {\n                clientSize = elements.floating[clientProp] || rects.floating[length];\n            }\n            const centerToReference = endDiff / 2 - startDiff / 2;\n            // If the padding is large enough that it causes the arrow to no longer be\n            // centered, modify the padding so that it is centered.\n            const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n            const minPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[minProp], largestPossiblePadding);\n            const maxPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[maxProp], largestPossiblePadding);\n            // Make sure the arrow doesn't overflow the floating element if the center\n            // point is outside the floating element's bounds.\n            const min$1 = minPadding;\n            const max = clientSize - arrowDimensions[length] - maxPadding;\n            const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n            const offset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min$1, center, max);\n            // If the reference is small enough that the arrow's padding causes it to\n            // to point to nothing for an aligned placement, adjust the offset of the\n            // floating element itself. To ensure `shift()` continues to take action,\n            // a single reset is performed when this is true.\n            const shouldAddOffset = !middlewareData.arrow && (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n            const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n            return {\n                [axis]: coords[axis] + alignmentOffset,\n                data: {\n                    [axis]: offset,\n                    centerOffset: center - offset - alignmentOffset,\n                    ...shouldAddOffset && {\n                        alignmentOffset\n                    }\n                },\n                reset: shouldAddOffset\n            };\n        }\n    });\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n    const allowedPlacementsSortedByAlignment = alignment ? [\n        ...allowedPlacements.filter((placement)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment),\n        ...allowedPlacements.filter((placement)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) !== alignment)\n    ] : allowedPlacements.filter((placement)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === placement);\n    return allowedPlacementsSortedByAlignment.filter((placement)=>{\n        if (alignment) {\n            return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment || (autoAlignment ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAlignmentPlacement)(placement) !== placement : false);\n        }\n        return true;\n    });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */ const autoPlacement = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"autoPlacement\",\n        options,\n        async fn (state) {\n            var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n            const { rects, middlewareData, placement, platform, elements } = state;\n            const { crossAxis = false, alignment, allowedPlacements = _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements, autoAlignment = true, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const placements$1 = alignment !== undefined || allowedPlacements === _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n            const currentPlacement = placements$1[currentIndex];\n            if (currentPlacement == null) {\n                return {};\n            }\n            const alignmentSides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n            // Make `computeCoords` start from the right place.\n            if (placement !== currentPlacement) {\n                return {\n                    reset: {\n                        placement: placements$1[0]\n                    }\n                };\n            }\n            const currentOverflows = [\n                overflow[(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(currentPlacement)],\n                overflow[alignmentSides[0]],\n                overflow[alignmentSides[1]]\n            ];\n            const allOverflows = [\n                ...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [],\n                {\n                    placement: currentPlacement,\n                    overflows: currentOverflows\n                }\n            ];\n            const nextPlacement = placements$1[currentIndex + 1];\n            // There are more placements to check.\n            if (nextPlacement) {\n                return {\n                    data: {\n                        index: currentIndex + 1,\n                        overflows: allOverflows\n                    },\n                    reset: {\n                        placement: nextPlacement\n                    }\n                };\n            }\n            const placementsSortedByMostSpace = allOverflows.map((d)=>{\n                const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d.placement);\n                return [\n                    d.placement,\n                    alignment && crossAxis ? // Check along the mainAxis and main crossAxis side.\n                    d.overflows.slice(0, 2).reduce((acc, v)=>acc + v, 0) : // Check only the mainAxis.\n                    d.overflows[0],\n                    d.overflows\n                ];\n            }).sort((a, b)=>a[1] - b[1]);\n            const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d)=>d[2].slice(0, // Aligned placements should not check their opposite crossAxis\n                // side.\n                (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d[0]) ? 2 : 3).every((v)=>v <= 0));\n            const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n            if (resetPlacement !== placement) {\n                return {\n                    data: {\n                        index: currentIndex + 1,\n                        overflows: allOverflows\n                    },\n                    reset: {\n                        placement: resetPlacement\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */ const flip = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"flip\",\n        options,\n        async fn (state) {\n            var _middlewareData$arrow, _middlewareData$flip;\n            const { placement, middlewareData, rects, initialPlacement, platform, elements } = state;\n            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true, fallbackPlacements: specifiedFallbackPlacements, fallbackStrategy = \"bestFit\", fallbackAxisSideDirection = \"none\", flipAlignment = true, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            // If a reset by the arrow was caused due to an alignment offset being\n            // added, we should skip any logic now since `flip()` has already done its\n            // work.\n            // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n            if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n                return {};\n            }\n            const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n            const initialSideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(initialPlacement);\n            const isBasePlacement = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(initialPlacement) === initialPlacement;\n            const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n            const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [\n                (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositePlacement)(initialPlacement)\n            ] : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getExpandedPlacements)(initialPlacement));\n            const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== \"none\";\n            if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n                fallbackPlacements.push(...(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxisPlacements)(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n            }\n            const placements = [\n                initialPlacement,\n                ...fallbackPlacements\n            ];\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const overflows = [];\n            let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n            if (checkMainAxis) {\n                overflows.push(overflow[side]);\n            }\n            if (checkCrossAxis) {\n                const sides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(placement, rects, rtl);\n                overflows.push(overflow[sides[0]], overflow[sides[1]]);\n            }\n            overflowsData = [\n                ...overflowsData,\n                {\n                    placement,\n                    overflows\n                }\n            ];\n            // One or more sides is overflowing.\n            if (!overflows.every((side)=>side <= 0)) {\n                var _middlewareData$flip2, _overflowsData$filter;\n                const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n                const nextPlacement = placements[nextIndex];\n                if (nextPlacement) {\n                    // Try next placement and re-run the lifecycle.\n                    return {\n                        data: {\n                            index: nextIndex,\n                            overflows: overflowsData\n                        },\n                        reset: {\n                            placement: nextPlacement\n                        }\n                    };\n                }\n                // First, find the candidates that fit on the mainAxis side of overflow,\n                // then find the placement that fits the best on the main crossAxis side.\n                let resetPlacement = (_overflowsData$filter = overflowsData.filter((d)=>d.overflows[0] <= 0).sort((a, b)=>a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n                // Otherwise fallback.\n                if (!resetPlacement) {\n                    switch(fallbackStrategy){\n                        case \"bestFit\":\n                            {\n                                var _overflowsData$filter2;\n                                const placement = (_overflowsData$filter2 = overflowsData.filter((d)=>{\n                                    if (hasFallbackAxisSideDirection) {\n                                        const currentSideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(d.placement);\n                                        return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal\n                                        // reading directions favoring greater width.\n                                        currentSideAxis === \"y\";\n                                    }\n                                    return true;\n                                }).map((d)=>[\n                                        d.placement,\n                                        d.overflows.filter((overflow)=>overflow > 0).reduce((acc, overflow)=>acc + overflow, 0)\n                                    ]).sort((a, b)=>a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                                if (placement) {\n                                    resetPlacement = placement;\n                                }\n                                break;\n                            }\n                        case \"initialPlacement\":\n                            resetPlacement = initialPlacement;\n                            break;\n                    }\n                }\n                if (placement !== resetPlacement) {\n                    return {\n                        reset: {\n                            placement: resetPlacement\n                        }\n                    };\n                }\n            }\n            return {};\n        }\n    };\n};\nfunction getSideOffsets(overflow, rect) {\n    return {\n        top: overflow.top - rect.height,\n        right: overflow.right - rect.width,\n        bottom: overflow.bottom - rect.height,\n        left: overflow.left - rect.width\n    };\n}\nfunction isAnySideFullyClipped(overflow) {\n    return _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.sides.some((side)=>overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */ const hide = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"hide\",\n        options,\n        async fn (state) {\n            const { rects } = state;\n            const { strategy = \"referenceHidden\", ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            switch(strategy){\n                case \"referenceHidden\":\n                    {\n                        const overflow = await detectOverflow(state, {\n                            ...detectOverflowOptions,\n                            elementContext: \"reference\"\n                        });\n                        const offsets = getSideOffsets(overflow, rects.reference);\n                        return {\n                            data: {\n                                referenceHiddenOffsets: offsets,\n                                referenceHidden: isAnySideFullyClipped(offsets)\n                            }\n                        };\n                    }\n                case \"escaped\":\n                    {\n                        const overflow = await detectOverflow(state, {\n                            ...detectOverflowOptions,\n                            altBoundary: true\n                        });\n                        const offsets = getSideOffsets(overflow, rects.floating);\n                        return {\n                            data: {\n                                escapedOffsets: offsets,\n                                escaped: isAnySideFullyClipped(offsets)\n                            }\n                        };\n                    }\n                default:\n                    {\n                        return {};\n                    }\n            }\n        }\n    };\n};\nfunction getBoundingRect(rects) {\n    const minX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map((rect)=>rect.left));\n    const minY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map((rect)=>rect.top));\n    const maxX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map((rect)=>rect.right));\n    const maxY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map((rect)=>rect.bottom));\n    return {\n        x: minX,\n        y: minY,\n        width: maxX - minX,\n        height: maxY - minY\n    };\n}\nfunction getRectsByLine(rects) {\n    const sortedRects = rects.slice().sort((a, b)=>a.y - b.y);\n    const groups = [];\n    let prevRect = null;\n    for(let i = 0; i < sortedRects.length; i++){\n        const rect = sortedRects[i];\n        if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n            groups.push([\n                rect\n            ]);\n        } else {\n            groups[groups.length - 1].push(rect);\n        }\n        prevRect = rect;\n    }\n    return groups.map((rect)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */ const inline = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"inline\",\n        options,\n        async fn (state) {\n            const { placement, elements, rects, platform, strategy } = state;\n            // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n            // ClientRect's bounds, despite the event listener being triggered. A\n            // padding of 2 seems to handle this issue.\n            const { padding = 2, x, y } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const nativeClientRects = Array.from(await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference)) || []);\n            const clientRects = getRectsByLine(nativeClientRects);\n            const fallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(nativeClientRects));\n            const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n            function getBoundingClientRect() {\n                // There are two rects and they are disjoined.\n                if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n                    // Find the first rect in which the point is fully inside.\n                    return clientRects.find((rect)=>x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n                }\n                // There are 2 or more connected rects.\n                if (clientRects.length >= 2) {\n                    if ((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === \"y\") {\n                        const firstRect = clientRects[0];\n                        const lastRect = clientRects[clientRects.length - 1];\n                        const isTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === \"top\";\n                        const top = firstRect.top;\n                        const bottom = lastRect.bottom;\n                        const left = isTop ? firstRect.left : lastRect.left;\n                        const right = isTop ? firstRect.right : lastRect.right;\n                        const width = right - left;\n                        const height = bottom - top;\n                        return {\n                            top,\n                            bottom,\n                            left,\n                            right,\n                            width,\n                            height,\n                            x: left,\n                            y: top\n                        };\n                    }\n                    const isLeftSide = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === \"left\";\n                    const maxRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...clientRects.map((rect)=>rect.right));\n                    const minLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...clientRects.map((rect)=>rect.left));\n                    const measureRects = clientRects.filter((rect)=>isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n                    const top = measureRects[0].top;\n                    const bottom = measureRects[measureRects.length - 1].bottom;\n                    const left = minLeft;\n                    const right = maxRight;\n                    const width = right - left;\n                    const height = bottom - top;\n                    return {\n                        top,\n                        bottom,\n                        left,\n                        right,\n                        width,\n                        height,\n                        x: left,\n                        y: top\n                    };\n                }\n                return fallback;\n            }\n            const resetRects = await platform.getElementRects({\n                reference: {\n                    getBoundingClientRect\n                },\n                floating: elements.floating,\n                strategy\n            });\n            if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n                return {\n                    reset: {\n                        rects: resetRects\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\nasync function convertValueToCoords(state, options) {\n    const { placement, platform, elements } = state;\n    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n    const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n    const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);\n    const isVertical = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === \"y\";\n    const mainAxisMulti = [\n        \"left\",\n        \"top\"\n    ].includes(side) ? -1 : 1;\n    const crossAxisMulti = rtl && isVertical ? -1 : 1;\n    const rawValue = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n    // eslint-disable-next-line prefer-const\n    let { mainAxis, crossAxis, alignmentAxis } = typeof rawValue === \"number\" ? {\n        mainAxis: rawValue,\n        crossAxis: 0,\n        alignmentAxis: null\n    } : {\n        mainAxis: rawValue.mainAxis || 0,\n        crossAxis: rawValue.crossAxis || 0,\n        alignmentAxis: rawValue.alignmentAxis\n    };\n    if (alignment && typeof alignmentAxis === \"number\") {\n        crossAxis = alignment === \"end\" ? alignmentAxis * -1 : alignmentAxis;\n    }\n    return isVertical ? {\n        x: crossAxis * crossAxisMulti,\n        y: mainAxis * mainAxisMulti\n    } : {\n        x: mainAxis * mainAxisMulti,\n        y: crossAxis * crossAxisMulti\n    };\n}\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */ const offset = function(options) {\n    if (options === void 0) {\n        options = 0;\n    }\n    return {\n        name: \"offset\",\n        options,\n        async fn (state) {\n            var _middlewareData$offse, _middlewareData$arrow;\n            const { x, y, placement, middlewareData } = state;\n            const diffCoords = await convertValueToCoords(state, options);\n            // If the placement is the same and the arrow caused an alignment offset\n            // then we don't need to change the positioning coordinates.\n            if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n                return {};\n            }\n            return {\n                x: x + diffCoords.x,\n                y: y + diffCoords.y,\n                data: {\n                    ...diffCoords,\n                    placement\n                }\n            };\n        }\n    };\n};\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */ const shift = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"shift\",\n        options,\n        async fn (state) {\n            const { x, y, placement } = state;\n            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = false, limiter = {\n                fn: (_ref)=>{\n                    let { x, y } = _ref;\n                    return {\n                        x,\n                        y\n                    };\n                }\n            }, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const coords = {\n                x,\n                y\n            };\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));\n            const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);\n            let mainAxisCoord = coords[mainAxis];\n            let crossAxisCoord = coords[crossAxis];\n            if (checkMainAxis) {\n                const minSide = mainAxis === \"y\" ? \"top\" : \"left\";\n                const maxSide = mainAxis === \"y\" ? \"bottom\" : \"right\";\n                const min = mainAxisCoord + overflow[minSide];\n                const max = mainAxisCoord - overflow[maxSide];\n                mainAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, mainAxisCoord, max);\n            }\n            if (checkCrossAxis) {\n                const minSide = crossAxis === \"y\" ? \"top\" : \"left\";\n                const maxSide = crossAxis === \"y\" ? \"bottom\" : \"right\";\n                const min = crossAxisCoord + overflow[minSide];\n                const max = crossAxisCoord - overflow[maxSide];\n                crossAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, crossAxisCoord, max);\n            }\n            const limitedCoords = limiter.fn({\n                ...state,\n                [mainAxis]: mainAxisCoord,\n                [crossAxis]: crossAxisCoord\n            });\n            return {\n                ...limitedCoords,\n                data: {\n                    x: limitedCoords.x - x,\n                    y: limitedCoords.y - y,\n                    enabled: {\n                        [mainAxis]: checkMainAxis,\n                        [crossAxis]: checkCrossAxis\n                    }\n                }\n            };\n        }\n    };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */ const limitShift = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        options,\n        fn (state) {\n            const { x, y, placement, rects, middlewareData } = state;\n            const { offset = 0, mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const coords = {\n                x,\n                y\n            };\n            const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);\n            const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);\n            let mainAxisCoord = coords[mainAxis];\n            let crossAxisCoord = coords[crossAxis];\n            const rawOffset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(offset, state);\n            const computedOffset = typeof rawOffset === \"number\" ? {\n                mainAxis: rawOffset,\n                crossAxis: 0\n            } : {\n                mainAxis: 0,\n                crossAxis: 0,\n                ...rawOffset\n            };\n            if (checkMainAxis) {\n                const len = mainAxis === \"y\" ? \"height\" : \"width\";\n                const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n                const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n                if (mainAxisCoord < limitMin) {\n                    mainAxisCoord = limitMin;\n                } else if (mainAxisCoord > limitMax) {\n                    mainAxisCoord = limitMax;\n                }\n            }\n            if (checkCrossAxis) {\n                var _middlewareData$offse, _middlewareData$offse2;\n                const len = mainAxis === \"y\" ? \"width\" : \"height\";\n                const isOriginSide = [\n                    \"top\",\n                    \"left\"\n                ].includes((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));\n                const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n                const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n                if (crossAxisCoord < limitMin) {\n                    crossAxisCoord = limitMin;\n                } else if (crossAxisCoord > limitMax) {\n                    crossAxisCoord = limitMax;\n                }\n            }\n            return {\n                [mainAxis]: mainAxisCoord,\n                [crossAxis]: crossAxisCoord\n            };\n        }\n    };\n};\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */ const size = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"size\",\n        options,\n        async fn (state) {\n            var _state$middlewareData, _state$middlewareData2;\n            const { placement, rects, platform, elements } = state;\n            const { apply = ()=>{}, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n            const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);\n            const isYAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === \"y\";\n            const { width, height } = rects.floating;\n            let heightSide;\n            let widthSide;\n            if (side === \"top\" || side === \"bottom\") {\n                heightSide = side;\n                widthSide = alignment === (await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)) ? \"start\" : \"end\") ? \"left\" : \"right\";\n            } else {\n                widthSide = side;\n                heightSide = alignment === \"end\" ? \"top\" : \"bottom\";\n            }\n            const maximumClippingHeight = height - overflow.top - overflow.bottom;\n            const maximumClippingWidth = width - overflow.left - overflow.right;\n            const overflowAvailableHeight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(height - overflow[heightSide], maximumClippingHeight);\n            const overflowAvailableWidth = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(width - overflow[widthSide], maximumClippingWidth);\n            const noShift = !state.middlewareData.shift;\n            let availableHeight = overflowAvailableHeight;\n            let availableWidth = overflowAvailableWidth;\n            if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n                availableWidth = maximumClippingWidth;\n            }\n            if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n                availableHeight = maximumClippingHeight;\n            }\n            if (noShift && !alignment) {\n                const xMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, 0);\n                const xMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.right, 0);\n                const yMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, 0);\n                const yMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.bottom, 0);\n                if (isYAxis) {\n                    availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, overflow.right));\n                } else {\n                    availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, overflow.bottom));\n                }\n            }\n            await apply({\n                ...state,\n                availableWidth,\n                availableHeight\n            });\n            const nextDimensions = await platform.getDimensions(elements.floating);\n            if (width !== nextDimensions.width || height !== nextDimensions.height) {\n                return {\n                    reset: {\n                        rects: true\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2NvcmUvZGlzdC9mbG9hdGluZy11aS5jb3JlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXNVO0FBQ2hSO0FBRXRELFNBQVNtQiwyQkFBMkJDLElBQUksRUFBRUMsU0FBUyxFQUFFQyxHQUFHO0lBQ3RELElBQUksRUFDRkMsU0FBUyxFQUNUQyxRQUFRLEVBQ1QsR0FBR0o7SUFDSixNQUFNSyxXQUFXekIsK0RBQVdBLENBQUNxQjtJQUM3QixNQUFNSyxnQkFBZ0J6QixvRUFBZ0JBLENBQUNvQjtJQUN2QyxNQUFNTSxjQUFjekIsaUVBQWFBLENBQUN3QjtJQUNsQyxNQUFNRSxPQUFPekIsMkRBQU9BLENBQUNrQjtJQUNyQixNQUFNUSxhQUFhSixhQUFhO0lBQ2hDLE1BQU1LLFVBQVVQLFVBQVVRLENBQUMsR0FBR1IsVUFBVVMsS0FBSyxHQUFHLElBQUlSLFNBQVNRLEtBQUssR0FBRztJQUNyRSxNQUFNQyxVQUFVVixVQUFVVyxDQUFDLEdBQUdYLFVBQVVZLE1BQU0sR0FBRyxJQUFJWCxTQUFTVyxNQUFNLEdBQUc7SUFDdkUsTUFBTUMsY0FBY2IsU0FBUyxDQUFDSSxZQUFZLEdBQUcsSUFBSUgsUUFBUSxDQUFDRyxZQUFZLEdBQUc7SUFDekUsSUFBSVU7SUFDSixPQUFRVDtRQUNOLEtBQUs7WUFDSFMsU0FBUztnQkFDUE4sR0FBR0Q7Z0JBQ0hJLEdBQUdYLFVBQVVXLENBQUMsR0FBR1YsU0FBU1csTUFBTTtZQUNsQztZQUNBO1FBQ0YsS0FBSztZQUNIRSxTQUFTO2dCQUNQTixHQUFHRDtnQkFDSEksR0FBR1gsVUFBVVcsQ0FBQyxHQUFHWCxVQUFVWSxNQUFNO1lBQ25DO1lBQ0E7UUFDRixLQUFLO1lBQ0hFLFNBQVM7Z0JBQ1BOLEdBQUdSLFVBQVVRLENBQUMsR0FBR1IsVUFBVVMsS0FBSztnQkFDaENFLEdBQUdEO1lBQ0w7WUFDQTtRQUNGLEtBQUs7WUFDSEksU0FBUztnQkFDUE4sR0FB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Q0FBQztRQUNWO0lBQ0Y7QUFDRjtBQUVzSCIsInNvdXJjZXMiOlsid2VicGFjazovL2FkbWlzc2lvbi11cGxpZnQvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2NvcmUvZGlzdC9mbG9hdGluZy11aS5jb3JlLm1qcz81NmJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldFNpZGVBeGlzLCBnZXRBbGlnbm1lbnRBeGlzLCBnZXRBeGlzTGVuZ3RoLCBnZXRTaWRlLCBnZXRBbGlnbm1lbnQsIGV2YWx1YXRlLCBnZXRQYWRkaW5nT2JqZWN0LCByZWN0VG9DbGllbnRSZWN0LCBtaW4sIGNsYW1wLCBwbGFjZW1lbnRzLCBnZXRBbGlnbm1lbnRTaWRlcywgZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQsIGdldE9wcG9zaXRlUGxhY2VtZW50LCBnZXRFeHBhbmRlZFBsYWNlbWVudHMsIGdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMsIHNpZGVzLCBtYXgsIGdldE9wcG9zaXRlQXhpcyB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5leHBvcnQgeyByZWN0VG9DbGllbnRSZWN0IH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzJztcblxuZnVuY3Rpb24gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQoX3JlZiwgcGxhY2VtZW50LCBydGwpIHtcbiAgbGV0IHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmdcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHNpZGVBeGlzID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25tZW50QXhpcyA9IGdldEFsaWdubWVudEF4aXMocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25MZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGFsaWdubWVudEF4aXMpO1xuICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICBjb25zdCBpc1ZlcnRpY2FsID0gc2lkZUF4aXMgPT09ICd5JztcbiAgY29uc3QgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGZsb2F0aW5nLndpZHRoIC8gMjtcbiAgY29uc3QgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBmbG9hdGluZy5oZWlnaHQgLyAyO1xuICBjb25zdCBjb21tb25BbGlnbiA9IHJlZmVyZW5jZVthbGlnbkxlbmd0aF0gLyAyIC0gZmxvYXRpbmdbYWxpZ25MZW5ndGhdIC8gMjtcbiAgbGV0IGNvb3JkcztcbiAgc3dpdGNoIChzaWRlKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBmbG9hdGluZy5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54IC0gZmxvYXRpbmcud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnlcbiAgICAgIH07XG4gIH1cbiAgc3dpdGNoIChnZXRBbGlnbm1lbnQocGxhY2VtZW50KSkge1xuICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgIGNvb3Jkc1thbGlnbm1lbnRBeGlzXSAtPSBjb21tb25BbGlnbiAqIChydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdlbmQnOlxuICAgICAgY29vcmRzW2FsaWdubWVudEF4aXNdICs9IGNvbW1vbkFsaWduICogKHJ0bCAmJiBpc1ZlcnRpY2FsID8gLTEgOiAxKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBjb29yZHM7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIHRoYXQgd2lsbCBwbGFjZSB0aGUgZmxvYXRpbmcgZWxlbWVudFxuICogbmV4dCB0byBhIGdpdmVuIHJlZmVyZW5jZSBlbGVtZW50LlxuICpcbiAqIFRoaXMgZXhwb3J0IGRvZXMgbm90IGhhdmUgYW55IGBwbGF0Zm9ybWAgaW50ZXJmYWNlIGxvZ2ljLiBZb3Ugd2lsbCBuZWVkIHRvXG4gKiB3cml0ZSBvbmUgZm9yIHRoZSBwbGF0Zm9ybSB5b3UgYXJlIHVzaW5nIEZsb2F0aW5nIFVJIHdpdGguXG4gKi9cbmNvbnN0IGNvbXB1dGVQb3NpdGlvbiA9IGFzeW5jIChyZWZlcmVuY2UsIGZsb2F0aW5nLCBjb25maWcpID0+IHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCA9ICdib3R0b20nLFxuICAgIHN0cmF0ZWd5ID0gJ2Fic29sdXRlJyxcbiAgICBtaWRkbGV3YXJlID0gW10sXG4gICAgcGxhdGZvcm1cbiAgfSA9IGNvbmZpZztcbiAgY29uc3QgdmFsaWRNaWRkbGV3YXJlID0gbWlkZGxld2FyZS5maWx0ZXIoQm9vbGVhbik7XG4gIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZmxvYXRpbmcpKTtcbiAgbGV0IHJlY3RzID0gYXdhaXQgcGxhdGZvcm0uZ2V0RWxlbWVudFJlY3RzKHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmcsXG4gICAgc3RyYXRlZ3lcbiAgfSk7XG4gIGxldCB7XG4gICAgeCxcbiAgICB5XG4gIH0gPSBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChyZWN0cywgcGxhY2VtZW50LCBydGwpO1xuICBsZXQgc3RhdGVmdWxQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gIGxldCBtaWRkbGV3YXJlRGF0YSA9IHt9O1xuICBsZXQgcmVzZXRDb3VudCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsaWRNaWRkbGV3YXJlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIGZuXG4gICAgfSA9IHZhbGlkTWlkZGxld2FyZVtpXTtcbiAgICBjb25zdCB7XG4gICAgICB4OiBuZXh0WCxcbiAgICAgIHk6IG5leHRZLFxuICAgICAgZGF0YSxcbiAgICAgIHJlc2V0XG4gICAgfSA9IGF3YWl0IGZuKHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgaW5pdGlhbFBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50OiBzdGF0ZWZ1bFBsYWNlbWVudCxcbiAgICAgIHN0cmF0ZWd5LFxuICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICByZWN0cyxcbiAgICAgIHBsYXRmb3JtLFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICBmbG9hdGluZ1xuICAgICAgfVxuICAgIH0pO1xuICAgIHggPSBuZXh0WCAhPSBudWxsID8gbmV4dFggOiB4O1xuICAgIHkgPSBuZXh0WSAhPSBudWxsID8gbmV4dFkgOiB5O1xuICAgIG1pZGRsZXdhcmVEYXRhID0ge1xuICAgICAgLi4ubWlkZGxld2FyZURhdGEsXG4gICAgICBbbmFtZV06IHtcbiAgICAgICAgLi4ubWlkZGxld2FyZURhdGFbbmFtZV0sXG4gICAgICAgIC4uLmRhdGFcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChyZXNldCAmJiByZXNldENvdW50IDw9IDUwKSB7XG4gICAgICByZXNldENvdW50Kys7XG4gICAgICBpZiAodHlwZW9mIHJlc2V0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAocmVzZXQucGxhY2VtZW50KSB7XG4gICAgICAgICAgc3RhdGVmdWxQbGFjZW1lbnQgPSByZXNldC5wbGFjZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc2V0LnJlY3RzKSB7XG4gICAgICAgICAgcmVjdHMgPSByZXNldC5yZWN0cyA9PT0gdHJ1ZSA/IGF3YWl0IHBsYXRmb3JtLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgICAgICAgICByZWZlcmVuY2UsXG4gICAgICAgICAgICBmbG9hdGluZyxcbiAgICAgICAgICAgIHN0cmF0ZWd5XG4gICAgICAgICAgfSkgOiByZXNldC5yZWN0cztcbiAgICAgICAgfVxuICAgICAgICAoe1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeVxuICAgICAgICB9ID0gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQocmVjdHMsIHN0YXRlZnVsUGxhY2VtZW50LCBydGwpKTtcbiAgICAgIH1cbiAgICAgIGkgPSAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHksXG4gICAgcGxhY2VtZW50OiBzdGF0ZWZ1bFBsYWNlbWVudCxcbiAgICBzdHJhdGVneSxcbiAgICBtaWRkbGV3YXJlRGF0YVxuICB9O1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyB3aXRoIGFuIG9iamVjdCBvZiBvdmVyZmxvdyBzaWRlIG9mZnNldHMgdGhhdCBkZXRlcm1pbmUgaG93IG11Y2ggdGhlXG4gKiBlbGVtZW50IGlzIG92ZXJmbG93aW5nIGEgZ2l2ZW4gY2xpcHBpbmcgYm91bmRhcnkgb24gZWFjaCBzaWRlLlxuICogLSBwb3NpdGl2ZSA9IG92ZXJmbG93aW5nIHRoZSBib3VuZGFyeSBieSB0aGF0IG51bWJlciBvZiBwaXhlbHNcbiAqIC0gbmVnYXRpdmUgPSBob3cgbWFueSBwaXhlbHMgbGVmdCBiZWZvcmUgaXQgd2lsbCBvdmVyZmxvd1xuICogLSAwID0gbGllcyBmbHVzaCB3aXRoIHRoZSBib3VuZGFyeVxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2RldGVjdE92ZXJmbG93XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KHN0YXRlLCBvcHRpb25zKSB7XG4gIHZhciBfYXdhaXQkcGxhdGZvcm0kaXNFbGU7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIHgsXG4gICAgeSxcbiAgICBwbGF0Zm9ybSxcbiAgICByZWN0cyxcbiAgICBlbGVtZW50cyxcbiAgICBzdHJhdGVneVxuICB9ID0gc3RhdGU7XG4gIGNvbnN0IHtcbiAgICBib3VuZGFyeSA9ICdjbGlwcGluZ0FuY2VzdG9ycycsXG4gICAgcm9vdEJvdW5kYXJ5ID0gJ3ZpZXdwb3J0JyxcbiAgICBlbGVtZW50Q29udGV4dCA9ICdmbG9hdGluZycsXG4gICAgYWx0Qm91bmRhcnkgPSBmYWxzZSxcbiAgICBwYWRkaW5nID0gMFxuICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0UGFkZGluZ09iamVjdChwYWRkaW5nKTtcbiAgY29uc3QgYWx0Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0ID09PSAnZmxvYXRpbmcnID8gJ3JlZmVyZW5jZScgOiAnZmxvYXRpbmcnO1xuICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbYWx0Qm91bmRhcnkgPyBhbHRDb250ZXh0IDogZWxlbWVudENvbnRleHRdO1xuICBjb25zdCBjbGlwcGluZ0NsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KGF3YWl0IHBsYXRmb3JtLmdldENsaXBwaW5nUmVjdCh7XG4gICAgZWxlbWVudDogKChfYXdhaXQkcGxhdGZvcm0kaXNFbGUgPSBhd2FpdCAocGxhdGZvcm0uaXNFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc0VsZW1lbnQoZWxlbWVudCkpKSAhPSBudWxsID8gX2F3YWl0JHBsYXRmb3JtJGlzRWxlIDogdHJ1ZSkgPyBlbGVtZW50IDogZWxlbWVudC5jb250ZXh0RWxlbWVudCB8fCAoYXdhaXQgKHBsYXRmb3JtLmdldERvY3VtZW50RWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnRzLmZsb2F0aW5nKSkpLFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBzdHJhdGVneVxuICB9KSk7XG4gIGNvbnN0IHJlY3QgPSBlbGVtZW50Q29udGV4dCA9PT0gJ2Zsb2F0aW5nJyA/IHtcbiAgICB4LFxuICAgIHksXG4gICAgd2lkdGg6IHJlY3RzLmZsb2F0aW5nLndpZHRoLFxuICAgIGhlaWdodDogcmVjdHMuZmxvYXRpbmcuaGVpZ2h0XG4gIH0gOiByZWN0cy5yZWZlcmVuY2U7XG4gIGNvbnN0IG9mZnNldFBhcmVudCA9IGF3YWl0IChwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldE9mZnNldFBhcmVudChlbGVtZW50cy5mbG9hdGluZykpO1xuICBjb25zdCBvZmZzZXRTY2FsZSA9IChhd2FpdCAocGxhdGZvcm0uaXNFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc0VsZW1lbnQob2Zmc2V0UGFyZW50KSkpID8gKGF3YWl0IChwbGF0Zm9ybS5nZXRTY2FsZSA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0U2NhbGUob2Zmc2V0UGFyZW50KSkpIHx8IHtcbiAgICB4OiAxLFxuICAgIHk6IDFcbiAgfSA6IHtcbiAgICB4OiAxLFxuICAgIHk6IDFcbiAgfTtcbiAgY29uc3QgZWxlbWVudENsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KHBsYXRmb3JtLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0ID8gYXdhaXQgcGxhdGZvcm0uY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3Qoe1xuICAgIGVsZW1lbnRzLFxuICAgIHJlY3QsXG4gICAgb2Zmc2V0UGFyZW50LFxuICAgIHN0cmF0ZWd5XG4gIH0pIDogcmVjdCk7XG4gIHJldHVybiB7XG4gICAgdG9wOiAoY2xpcHBpbmdDbGllbnRSZWN0LnRvcCAtIGVsZW1lbnRDbGllbnRSZWN0LnRvcCArIHBhZGRpbmdPYmplY3QudG9wKSAvIG9mZnNldFNjYWxlLnksXG4gICAgYm90dG9tOiAoZWxlbWVudENsaWVudFJlY3QuYm90dG9tIC0gY2xpcHBpbmdDbGllbnRSZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tKSAvIG9mZnNldFNjYWxlLnksXG4gICAgbGVmdDogKGNsaXBwaW5nQ2xpZW50UmVjdC5sZWZ0IC0gZWxlbWVudENsaWVudFJlY3QubGVmdCArIHBhZGRpbmdPYmplY3QubGVmdCkgLyBvZmZzZXRTY2FsZS54LFxuICAgIHJpZ2h0OiAoZWxlbWVudENsaWVudFJlY3QucmlnaHQgLSBjbGlwcGluZ0NsaWVudFJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0KSAvIG9mZnNldFNjYWxlLnhcbiAgfTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGFuIGlubmVyIGVsZW1lbnQgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgc28gdGhhdCBpdFxuICogYXBwZWFycyBjZW50ZXJlZCB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXJyb3dcbiAqL1xuY29uc3QgYXJyb3cgPSBvcHRpb25zID0+ICh7XG4gIG5hbWU6ICdhcnJvdycsXG4gIG9wdGlvbnMsXG4gIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBwbGFjZW1lbnQsXG4gICAgICByZWN0cyxcbiAgICAgIHBsYXRmb3JtLFxuICAgICAgZWxlbWVudHMsXG4gICAgICBtaWRkbGV3YXJlRGF0YVxuICAgIH0gPSBzdGF0ZTtcbiAgICAvLyBTaW5jZSBgZWxlbWVudGAgaXMgcmVxdWlyZWQsIHdlIGRvbid0IFBhcnRpYWw8PiB0aGUgdHlwZS5cbiAgICBjb25zdCB7XG4gICAgICBlbGVtZW50LFxuICAgICAgcGFkZGluZyA9IDBcbiAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpIHx8IHt9O1xuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGluZ09iamVjdCA9IGdldFBhZGRpbmdPYmplY3QocGFkZGluZyk7XG4gICAgY29uc3QgY29vcmRzID0ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICAgIGNvbnN0IGF4aXMgPSBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCk7XG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0QXhpc0xlbmd0aChheGlzKTtcbiAgICBjb25zdCBhcnJvd0RpbWVuc2lvbnMgPSBhd2FpdCBwbGF0Zm9ybS5nZXREaW1lbnNpb25zKGVsZW1lbnQpO1xuICAgIGNvbnN0IGlzWUF4aXMgPSBheGlzID09PSAneSc7XG4gICAgY29uc3QgbWluUHJvcCA9IGlzWUF4aXMgPyAndG9wJyA6ICdsZWZ0JztcbiAgICBjb25zdCBtYXhQcm9wID0gaXNZQXhpcyA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgICBjb25zdCBjbGllbnRQcm9wID0gaXNZQXhpcyA/ICdjbGllbnRIZWlnaHQnIDogJ2NsaWVudFdpZHRoJztcbiAgICBjb25zdCBlbmREaWZmID0gcmVjdHMucmVmZXJlbmNlW2xlbmd0aF0gKyByZWN0cy5yZWZlcmVuY2VbYXhpc10gLSBjb29yZHNbYXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5ndGhdO1xuICAgIGNvbnN0IHN0YXJ0RGlmZiA9IGNvb3Jkc1theGlzXSAtIHJlY3RzLnJlZmVyZW5jZVtheGlzXTtcbiAgICBjb25zdCBhcnJvd09mZnNldFBhcmVudCA9IGF3YWl0IChwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldE9mZnNldFBhcmVudChlbGVtZW50KSk7XG4gICAgbGV0IGNsaWVudFNpemUgPSBhcnJvd09mZnNldFBhcmVudCA/IGFycm93T2Zmc2V0UGFyZW50W2NsaWVudFByb3BdIDogMDtcblxuICAgIC8vIERPTSBwbGF0Zm9ybSBjYW4gcmV0dXJuIGB3aW5kb3dgIGFzIHRoZSBgb2Zmc2V0UGFyZW50YC5cbiAgICBpZiAoIWNsaWVudFNpemUgfHwgIShhd2FpdCAocGxhdGZvcm0uaXNFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc0VsZW1lbnQoYXJyb3dPZmZzZXRQYXJlbnQpKSkpIHtcbiAgICAgIGNsaWVudFNpemUgPSBlbGVtZW50cy5mbG9hdGluZ1tjbGllbnRQcm9wXSB8fCByZWN0cy5mbG9hdGluZ1tsZW5ndGhdO1xuICAgIH1cbiAgICBjb25zdCBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjtcblxuICAgIC8vIElmIHRoZSBwYWRkaW5nIGlzIGxhcmdlIGVub3VnaCB0aGF0IGl0IGNhdXNlcyB0aGUgYXJyb3cgdG8gbm8gbG9uZ2VyIGJlXG4gICAgLy8gY2VudGVyZWQsIG1vZGlmeSB0aGUgcGFkZGluZyBzbyB0aGF0IGl0IGlzIGNlbnRlcmVkLlxuICAgIGNvbnN0IGxhcmdlc3RQb3NzaWJsZVBhZGRpbmcgPSBjbGllbnRTaXplIC8gMiAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC8gMiAtIDE7XG4gICAgY29uc3QgbWluUGFkZGluZyA9IG1pbihwYWRkaW5nT2JqZWN0W21pblByb3BdLCBsYXJnZXN0UG9zc2libGVQYWRkaW5nKTtcbiAgICBjb25zdCBtYXhQYWRkaW5nID0gbWluKHBhZGRpbmdPYmplY3RbbWF4UHJvcF0sIGxhcmdlc3RQb3NzaWJsZVBhZGRpbmcpO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBhcnJvdyBkb2Vzbid0IG92ZXJmbG93IHRoZSBmbG9hdGluZyBlbGVtZW50IGlmIHRoZSBjZW50ZXJcbiAgICAvLyBwb2ludCBpcyBvdXRzaWRlIHRoZSBmbG9hdGluZyBlbGVtZW50J3MgYm91bmRzLlxuICAgIGNvbnN0IG1pbiQxID0gbWluUGFkZGluZztcbiAgICBjb25zdCBtYXggPSBjbGllbnRTaXplIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLSBtYXhQYWRkaW5nO1xuICAgIGNvbnN0IGNlbnRlciA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLyAyICsgY2VudGVyVG9SZWZlcmVuY2U7XG4gICAgY29uc3Qgb2Zmc2V0ID0gY2xhbXAobWluJDEsIGNlbnRlciwgbWF4KTtcblxuICAgIC8vIElmIHRoZSByZWZlcmVuY2UgaXMgc21hbGwgZW5vdWdoIHRoYXQgdGhlIGFycm93J3MgcGFkZGluZyBjYXVzZXMgaXQgdG9cbiAgICAvLyB0byBwb2ludCB0byBub3RoaW5nIGZvciBhbiBhbGlnbmVkIHBsYWNlbWVudCwgYWRqdXN0IHRoZSBvZmZzZXQgb2YgdGhlXG4gICAgLy8gZmxvYXRpbmcgZWxlbWVudCBpdHNlbGYuIFRvIGVuc3VyZSBgc2hpZnQoKWAgY29udGludWVzIHRvIHRha2UgYWN0aW9uLFxuICAgIC8vIGEgc2luZ2xlIHJlc2V0IGlzIHBlcmZvcm1lZCB3aGVuIHRoaXMgaXMgdHJ1ZS5cbiAgICBjb25zdCBzaG91bGRBZGRPZmZzZXQgPSAhbWlkZGxld2FyZURhdGEuYXJyb3cgJiYgZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgIT0gbnVsbCAmJiBjZW50ZXIgIT09IG9mZnNldCAmJiByZWN0cy5yZWZlcmVuY2VbbGVuZ3RoXSAvIDIgLSAoY2VudGVyIDwgbWluJDEgPyBtaW5QYWRkaW5nIDogbWF4UGFkZGluZykgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAvIDIgPCAwO1xuICAgIGNvbnN0IGFsaWdubWVudE9mZnNldCA9IHNob3VsZEFkZE9mZnNldCA/IGNlbnRlciA8IG1pbiQxID8gY2VudGVyIC0gbWluJDEgOiBjZW50ZXIgLSBtYXggOiAwO1xuICAgIHJldHVybiB7XG4gICAgICBbYXhpc106IGNvb3Jkc1theGlzXSArIGFsaWdubWVudE9mZnNldCxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgW2F4aXNdOiBvZmZzZXQsXG4gICAgICAgIGNlbnRlck9mZnNldDogY2VudGVyIC0gb2Zmc2V0IC0gYWxpZ25tZW50T2Zmc2V0LFxuICAgICAgICAuLi4oc2hvdWxkQWRkT2Zmc2V0ICYmIHtcbiAgICAgICAgICBhbGlnbm1lbnRPZmZzZXRcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICByZXNldDogc2hvdWxkQWRkT2Zmc2V0XG4gICAgfTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGdldFBsYWNlbWVudExpc3QoYWxpZ25tZW50LCBhdXRvQWxpZ25tZW50LCBhbGxvd2VkUGxhY2VtZW50cykge1xuICBjb25zdCBhbGxvd2VkUGxhY2VtZW50c1NvcnRlZEJ5QWxpZ25tZW50ID0gYWxpZ25tZW50ID8gWy4uLmFsbG93ZWRQbGFjZW1lbnRzLmZpbHRlcihwbGFjZW1lbnQgPT4gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgPT09IGFsaWdubWVudCksIC4uLmFsbG93ZWRQbGFjZW1lbnRzLmZpbHRlcihwbGFjZW1lbnQgPT4gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgIT09IGFsaWdubWVudCldIDogYWxsb3dlZFBsYWNlbWVudHMuZmlsdGVyKHBsYWNlbWVudCA9PiBnZXRTaWRlKHBsYWNlbWVudCkgPT09IHBsYWNlbWVudCk7XG4gIHJldHVybiBhbGxvd2VkUGxhY2VtZW50c1NvcnRlZEJ5QWxpZ25tZW50LmZpbHRlcihwbGFjZW1lbnQgPT4ge1xuICAgIGlmIChhbGlnbm1lbnQpIHtcbiAgICAgIHJldHVybiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSA9PT0gYWxpZ25tZW50IHx8IChhdXRvQWxpZ25tZW50ID8gZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQocGxhY2VtZW50KSAhPT0gcGxhY2VtZW50IDogZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBjaG9vc2luZyB0aGUgcGxhY2VtZW50XG4gKiB0aGF0IGhhcyB0aGUgbW9zdCBzcGFjZSBhdmFpbGFibGUgYXV0b21hdGljYWxseSwgd2l0aG91dCBuZWVkaW5nIHRvIHNwZWNpZnkgYVxuICogcHJlZmVycmVkIHBsYWNlbWVudC4gQWx0ZXJuYXRpdmUgdG8gYGZsaXBgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2F1dG9QbGFjZW1lbnRcbiAqL1xuY29uc3QgYXV0b1BsYWNlbWVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnYXV0b1BsYWNlbWVudCcsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRhdXRvUCwgX21pZGRsZXdhcmVEYXRhJGF1dG9QMiwgX3BsYWNlbWVudHNUaGF0Rml0T25FO1xuICAgICAgY29uc3Qge1xuICAgICAgICByZWN0cyxcbiAgICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIGVsZW1lbnRzXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNyb3NzQXhpcyA9IGZhbHNlLFxuICAgICAgICBhbGlnbm1lbnQsXG4gICAgICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cyxcbiAgICAgICAgYXV0b0FsaWdubWVudCA9IHRydWUsXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IHBsYWNlbWVudHMkMSA9IGFsaWdubWVudCAhPT0gdW5kZWZpbmVkIHx8IGFsbG93ZWRQbGFjZW1lbnRzID09PSBwbGFjZW1lbnRzID8gZ2V0UGxhY2VtZW50TGlzdChhbGlnbm1lbnQgfHwgbnVsbCwgYXV0b0FsaWdubWVudCwgYWxsb3dlZFBsYWNlbWVudHMpIDogYWxsb3dlZFBsYWNlbWVudHM7XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gKChfbWlkZGxld2FyZURhdGEkYXV0b1AgPSBtaWRkbGV3YXJlRGF0YS5hdXRvUGxhY2VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGF1dG9QLmluZGV4KSB8fCAwO1xuICAgICAgY29uc3QgY3VycmVudFBsYWNlbWVudCA9IHBsYWNlbWVudHMkMVtjdXJyZW50SW5kZXhdO1xuICAgICAgaWYgKGN1cnJlbnRQbGFjZW1lbnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICBjb25zdCBhbGlnbm1lbnRTaWRlcyA9IGdldEFsaWdubWVudFNpZGVzKGN1cnJlbnRQbGFjZW1lbnQsIHJlY3RzLCBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSkpO1xuXG4gICAgICAvLyBNYWtlIGBjb21wdXRlQ29vcmRzYCBzdGFydCBmcm9tIHRoZSByaWdodCBwbGFjZS5cbiAgICAgIGlmIChwbGFjZW1lbnQgIT09IGN1cnJlbnRQbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnRzJDFbMF1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW50T3ZlcmZsb3dzID0gW292ZXJmbG93W2dldFNpZGUoY3VycmVudFBsYWNlbWVudCldLCBvdmVyZmxvd1thbGlnbm1lbnRTaWRlc1swXV0sIG92ZXJmbG93W2FsaWdubWVudFNpZGVzWzFdXV07XG4gICAgICBjb25zdCBhbGxPdmVyZmxvd3MgPSBbLi4uKCgoX21pZGRsZXdhcmVEYXRhJGF1dG9QMiA9IG1pZGRsZXdhcmVEYXRhLmF1dG9QbGFjZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkYXV0b1AyLm92ZXJmbG93cykgfHwgW10pLCB7XG4gICAgICAgIHBsYWNlbWVudDogY3VycmVudFBsYWNlbWVudCxcbiAgICAgICAgb3ZlcmZsb3dzOiBjdXJyZW50T3ZlcmZsb3dzXG4gICAgICB9XTtcbiAgICAgIGNvbnN0IG5leHRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzJDFbY3VycmVudEluZGV4ICsgMV07XG5cbiAgICAgIC8vIFRoZXJlIGFyZSBtb3JlIHBsYWNlbWVudHMgdG8gY2hlY2suXG4gICAgICBpZiAobmV4dFBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGluZGV4OiBjdXJyZW50SW5kZXggKyAxLFxuICAgICAgICAgICAgb3ZlcmZsb3dzOiBhbGxPdmVyZmxvd3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IG5leHRQbGFjZW1lbnRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2UgPSBhbGxPdmVyZmxvd3MubWFwKGQgPT4ge1xuICAgICAgICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQoZC5wbGFjZW1lbnQpO1xuICAgICAgICByZXR1cm4gW2QucGxhY2VtZW50LCBhbGlnbm1lbnQgJiYgY3Jvc3NBeGlzID9cbiAgICAgICAgLy8gQ2hlY2sgYWxvbmcgdGhlIG1haW5BeGlzIGFuZCBtYWluIGNyb3NzQXhpcyBzaWRlLlxuICAgICAgICBkLm92ZXJmbG93cy5zbGljZSgwLCAyKS5yZWR1Y2UoKGFjYywgdikgPT4gYWNjICsgdiwgMCkgOlxuICAgICAgICAvLyBDaGVjayBvbmx5IHRoZSBtYWluQXhpcy5cbiAgICAgICAgZC5vdmVyZmxvd3NbMF0sIGQub3ZlcmZsb3dzXTtcbiAgICAgIH0pLnNvcnQoKGEsIGIpID0+IGFbMV0gLSBiWzFdKTtcbiAgICAgIGNvbnN0IHBsYWNlbWVudHNUaGF0Rml0T25FYWNoU2lkZSA9IHBsYWNlbWVudHNTb3J0ZWRCeU1vc3RTcGFjZS5maWx0ZXIoZCA9PiBkWzJdLnNsaWNlKDAsXG4gICAgICAvLyBBbGlnbmVkIHBsYWNlbWVudHMgc2hvdWxkIG5vdCBjaGVjayB0aGVpciBvcHBvc2l0ZSBjcm9zc0F4aXNcbiAgICAgIC8vIHNpZGUuXG4gICAgICBnZXRBbGlnbm1lbnQoZFswXSkgPyAyIDogMykuZXZlcnkodiA9PiB2IDw9IDApKTtcbiAgICAgIGNvbnN0IHJlc2V0UGxhY2VtZW50ID0gKChfcGxhY2VtZW50c1RoYXRGaXRPbkUgPSBwbGFjZW1lbnRzVGhhdEZpdE9uRWFjaFNpZGVbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfcGxhY2VtZW50c1RoYXRGaXRPbkVbMF0pIHx8IHBsYWNlbWVudHNTb3J0ZWRCeU1vc3RTcGFjZVswXVswXTtcbiAgICAgIGlmIChyZXNldFBsYWNlbWVudCAhPT0gcGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgaW5kZXg6IGN1cnJlbnRJbmRleCArIDEsXG4gICAgICAgICAgICBvdmVyZmxvd3M6IGFsbE92ZXJmbG93c1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogcmVzZXRQbGFjZW1lbnRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgZmxpcHBpbmcgdGhlIGBwbGFjZW1lbnRgXG4gKiBpbiBvcmRlciB0byBrZWVwIGl0IGluIHZpZXcgd2hlbiB0aGUgcHJlZmVycmVkIHBsYWNlbWVudChzKSB3aWxsIG92ZXJmbG93IHRoZVxuICogY2xpcHBpbmcgYm91bmRhcnkuIEFsdGVybmF0aXZlIHRvIGBhdXRvUGxhY2VtZW50YC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9mbGlwXG4gKi9cbmNvbnN0IGZsaXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2ZsaXAnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkYXJyb3csIF9taWRkbGV3YXJlRGF0YSRmbGlwO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgICByZWN0cyxcbiAgICAgICAgaW5pdGlhbFBsYWNlbWVudCxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIGVsZW1lbnRzXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gdHJ1ZSxcbiAgICAgICAgY3Jvc3NBeGlzOiBjaGVja0Nyb3NzQXhpcyA9IHRydWUsXG4gICAgICAgIGZhbGxiYWNrUGxhY2VtZW50czogc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgICAgICBmYWxsYmFja1N0cmF0ZWd5ID0gJ2Jlc3RGaXQnLFxuICAgICAgICBmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uID0gJ25vbmUnLFxuICAgICAgICBmbGlwQWxpZ25tZW50ID0gdHJ1ZSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuXG4gICAgICAvLyBJZiBhIHJlc2V0IGJ5IHRoZSBhcnJvdyB3YXMgY2F1c2VkIGR1ZSB0byBhbiBhbGlnbm1lbnQgb2Zmc2V0IGJlaW5nXG4gICAgICAvLyBhZGRlZCwgd2Ugc2hvdWxkIHNraXAgYW55IGxvZ2ljIG5vdyBzaW5jZSBgZmxpcCgpYCBoYXMgYWxyZWFkeSBkb25lIGl0c1xuICAgICAgLy8gd29yay5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMjU0OSNpc3N1ZWNvbW1lbnQtMTcxOTYwMTY0M1xuICAgICAgaWYgKChfbWlkZGxld2FyZURhdGEkYXJyb3cgPSBtaWRkbGV3YXJlRGF0YS5hcnJvdykgIT0gbnVsbCAmJiBfbWlkZGxld2FyZURhdGEkYXJyb3cuYWxpZ25tZW50T2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBpbml0aWFsU2lkZUF4aXMgPSBnZXRTaWRlQXhpcyhpbml0aWFsUGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGlzQmFzZVBsYWNlbWVudCA9IGdldFNpZGUoaW5pdGlhbFBsYWNlbWVudCkgPT09IGluaXRpYWxQbGFjZW1lbnQ7XG4gICAgICBjb25zdCBydGwgPSBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSk7XG4gICAgICBjb25zdCBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcEFsaWdubWVudCA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChpbml0aWFsUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZFBsYWNlbWVudHMoaW5pdGlhbFBsYWNlbWVudCkpO1xuICAgICAgY29uc3QgaGFzRmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiA9IGZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24gIT09ICdub25lJztcbiAgICAgIGlmICghc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzICYmIGhhc0ZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24pIHtcbiAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzLnB1c2goLi4uZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyhpbml0aWFsUGxhY2VtZW50LCBmbGlwQWxpZ25tZW50LCBmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uLCBydGwpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBsYWNlbWVudHMgPSBbaW5pdGlhbFBsYWNlbWVudCwgLi4uZmFsbGJhY2tQbGFjZW1lbnRzXTtcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBvdmVyZmxvd3MgPSBbXTtcbiAgICAgIGxldCBvdmVyZmxvd3NEYXRhID0gKChfbWlkZGxld2FyZURhdGEkZmxpcCA9IG1pZGRsZXdhcmVEYXRhLmZsaXApID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkZmxpcC5vdmVyZmxvd3MpIHx8IFtdO1xuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgb3ZlcmZsb3dzLnB1c2gob3ZlcmZsb3dbc2lkZV0pO1xuICAgICAgfVxuICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgIGNvbnN0IHNpZGVzID0gZ2V0QWxpZ25tZW50U2lkZXMocGxhY2VtZW50LCByZWN0cywgcnRsKTtcbiAgICAgICAgb3ZlcmZsb3dzLnB1c2gob3ZlcmZsb3dbc2lkZXNbMF1dLCBvdmVyZmxvd1tzaWRlc1sxXV0pO1xuICAgICAgfVxuICAgICAgb3ZlcmZsb3dzRGF0YSA9IFsuLi5vdmVyZmxvd3NEYXRhLCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgb3ZlcmZsb3dzXG4gICAgICB9XTtcblxuICAgICAgLy8gT25lIG9yIG1vcmUgc2lkZXMgaXMgb3ZlcmZsb3dpbmcuXG4gICAgICBpZiAoIW92ZXJmbG93cy5ldmVyeShzaWRlID0+IHNpZGUgPD0gMCkpIHtcbiAgICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRmbGlwMiwgX292ZXJmbG93c0RhdGEkZmlsdGVyO1xuICAgICAgICBjb25zdCBuZXh0SW5kZXggPSAoKChfbWlkZGxld2FyZURhdGEkZmxpcDIgPSBtaWRkbGV3YXJlRGF0YS5mbGlwKSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGZsaXAyLmluZGV4KSB8fCAwKSArIDE7XG4gICAgICAgIGNvbnN0IG5leHRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzW25leHRJbmRleF07XG4gICAgICAgIGlmIChuZXh0UGxhY2VtZW50KSB7XG4gICAgICAgICAgLy8gVHJ5IG5leHQgcGxhY2VtZW50IGFuZCByZS1ydW4gdGhlIGxpZmVjeWNsZS5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBpbmRleDogbmV4dEluZGV4LFxuICAgICAgICAgICAgICBvdmVyZmxvd3M6IG92ZXJmbG93c0RhdGFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgICBwbGFjZW1lbnQ6IG5leHRQbGFjZW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyc3QsIGZpbmQgdGhlIGNhbmRpZGF0ZXMgdGhhdCBmaXQgb24gdGhlIG1haW5BeGlzIHNpZGUgb2Ygb3ZlcmZsb3csXG4gICAgICAgIC8vIHRoZW4gZmluZCB0aGUgcGxhY2VtZW50IHRoYXQgZml0cyB0aGUgYmVzdCBvbiB0aGUgbWFpbiBjcm9zc0F4aXMgc2lkZS5cbiAgICAgICAgbGV0IHJlc2V0UGxhY2VtZW50ID0gKF9vdmVyZmxvd3NEYXRhJGZpbHRlciA9IG92ZXJmbG93c0RhdGEuZmlsdGVyKGQgPT4gZC5vdmVyZmxvd3NbMF0gPD0gMCkuc29ydCgoYSwgYikgPT4gYS5vdmVyZmxvd3NbMV0gLSBiLm92ZXJmbG93c1sxXSlbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIucGxhY2VtZW50O1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSBmYWxsYmFjay5cbiAgICAgICAgaWYgKCFyZXNldFBsYWNlbWVudCkge1xuICAgICAgICAgIHN3aXRjaCAoZmFsbGJhY2tTdHJhdGVneSkge1xuICAgICAgICAgICAgY2FzZSAnYmVzdEZpdCc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgX292ZXJmbG93c0RhdGEkZmlsdGVyMjtcbiAgICAgICAgICAgICAgICBjb25zdCBwbGFjZW1lbnQgPSAoX292ZXJmbG93c0RhdGEkZmlsdGVyMiA9IG92ZXJmbG93c0RhdGEuZmlsdGVyKGQgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKGhhc0ZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFNpZGVBeGlzID0gZ2V0U2lkZUF4aXMoZC5wbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFNpZGVBeGlzID09PSBpbml0aWFsU2lkZUF4aXMgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgYmlhcyB0byB0aGUgYHlgIHNpZGUgYXhpcyBkdWUgdG8gaG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgICAgICAvLyByZWFkaW5nIGRpcmVjdGlvbnMgZmF2b3JpbmcgZ3JlYXRlciB3aWR0aC5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNpZGVBeGlzID09PSAneSc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KS5tYXAoZCA9PiBbZC5wbGFjZW1lbnQsIGQub3ZlcmZsb3dzLmZpbHRlcihvdmVyZmxvdyA9PiBvdmVyZmxvdyA+IDApLnJlZHVjZSgoYWNjLCBvdmVyZmxvdykgPT4gYWNjICsgb3ZlcmZsb3csIDApXSkuc29ydCgoYSwgYikgPT4gYVsxXSAtIGJbMV0pWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX292ZXJmbG93c0RhdGEkZmlsdGVyMlswXTtcbiAgICAgICAgICAgICAgICBpZiAocGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICByZXNldFBsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2luaXRpYWxQbGFjZW1lbnQnOlxuICAgICAgICAgICAgICByZXNldFBsYWNlbWVudCA9IGluaXRpYWxQbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGxhY2VtZW50ICE9PSByZXNldFBsYWNlbWVudCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgICBwbGFjZW1lbnQ6IHJlc2V0UGxhY2VtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0KSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCxcbiAgICByaWdodDogb3ZlcmZsb3cucmlnaHQgLSByZWN0LndpZHRoLFxuICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQsXG4gICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGhcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvdmVyZmxvdykge1xuICByZXR1cm4gc2lkZXMuc29tZShzaWRlID0+IG92ZXJmbG93W3NpZGVdID49IDApO1xufVxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIGhpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW4gYXBwbGljYWJsZSBzaXR1YXRpb25zLCBzdWNoIGFzXG4gKiB3aGVuIGl0IGlzIG5vdCBpbiB0aGUgc2FtZSBjbGlwcGluZyBjb250ZXh0IGFzIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9oaWRlXG4gKi9cbmNvbnN0IGhpZGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2hpZGUnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVjdHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RyYXRlZ3kgPSAncmVmZXJlbmNlSGlkZGVuJyxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgc3dpdGNoIChzdHJhdGVneSkge1xuICAgICAgICBjYXNlICdyZWZlcmVuY2VIaWRkZW4nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgICAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zLFxuICAgICAgICAgICAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0cy5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUhpZGRlbk9mZnNldHM6IG9mZnNldHMsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlSGlkZGVuOiBpc0FueVNpZGVGdWxseUNsaXBwZWQob2Zmc2V0cylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2VzY2FwZWQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgICAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zLFxuICAgICAgICAgICAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3RzLmZsb2F0aW5nKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBlc2NhcGVkT2Zmc2V0czogb2Zmc2V0cyxcbiAgICAgICAgICAgICAgICBlc2NhcGVkOiBpc0FueVNpZGVGdWxseUNsaXBwZWQob2Zmc2V0cylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ1JlY3QocmVjdHMpIHtcbiAgY29uc3QgbWluWCA9IG1pbiguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LmxlZnQpKTtcbiAgY29uc3QgbWluWSA9IG1pbiguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LnRvcCkpO1xuICBjb25zdCBtYXhYID0gbWF4KC4uLnJlY3RzLm1hcChyZWN0ID0+IHJlY3QucmlnaHQpKTtcbiAgY29uc3QgbWF4WSA9IG1heCguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LmJvdHRvbSkpO1xuICByZXR1cm4ge1xuICAgIHg6IG1pblgsXG4gICAgeTogbWluWSxcbiAgICB3aWR0aDogbWF4WCAtIG1pblgsXG4gICAgaGVpZ2h0OiBtYXhZIC0gbWluWVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0UmVjdHNCeUxpbmUocmVjdHMpIHtcbiAgY29uc3Qgc29ydGVkUmVjdHMgPSByZWN0cy5zbGljZSgpLnNvcnQoKGEsIGIpID0+IGEueSAtIGIueSk7XG4gIGNvbnN0IGdyb3VwcyA9IFtdO1xuICBsZXQgcHJldlJlY3QgPSBudWxsO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNvcnRlZFJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcmVjdCA9IHNvcnRlZFJlY3RzW2ldO1xuICAgIGlmICghcHJldlJlY3QgfHwgcmVjdC55IC0gcHJldlJlY3QueSA+IHByZXZSZWN0LmhlaWdodCAvIDIpIHtcbiAgICAgIGdyb3Vwcy5wdXNoKFtyZWN0XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3Vwc1tncm91cHMubGVuZ3RoIC0gMV0ucHVzaChyZWN0KTtcbiAgICB9XG4gICAgcHJldlJlY3QgPSByZWN0O1xuICB9XG4gIHJldHVybiBncm91cHMubWFwKHJlY3QgPT4gcmVjdFRvQ2xpZW50UmVjdChnZXRCb3VuZGluZ1JlY3QocmVjdCkpKTtcbn1cbi8qKlxuICogUHJvdmlkZXMgaW1wcm92ZWQgcG9zaXRpb25pbmcgZm9yIGlubGluZSByZWZlcmVuY2UgZWxlbWVudHMgdGhhdCBjYW4gc3BhblxuICogb3ZlciBtdWx0aXBsZSBsaW5lcywgc3VjaCBhcyBoeXBlcmxpbmtzIG9yIHJhbmdlIHNlbGVjdGlvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaW5saW5lXG4gKi9cbmNvbnN0IGlubGluZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnaW5saW5lJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgZWxlbWVudHMsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIC8vIEEgTW91c2VFdmVudCdzIGNsaWVudHtYLFl9IGNvb3JkcyBjYW4gYmUgdXAgdG8gMiBwaXhlbHMgb2ZmIGFcbiAgICAgIC8vIENsaWVudFJlY3QncyBib3VuZHMsIGRlc3BpdGUgdGhlIGV2ZW50IGxpc3RlbmVyIGJlaW5nIHRyaWdnZXJlZC4gQVxuICAgICAgLy8gcGFkZGluZyBvZiAyIHNlZW1zIHRvIGhhbmRsZSB0aGlzIGlzc3VlLlxuICAgICAgY29uc3Qge1xuICAgICAgICBwYWRkaW5nID0gMixcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IG5hdGl2ZUNsaWVudFJlY3RzID0gQXJyYXkuZnJvbSgoYXdhaXQgKHBsYXRmb3JtLmdldENsaWVudFJlY3RzID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRDbGllbnRSZWN0cyhlbGVtZW50cy5yZWZlcmVuY2UpKSkgfHwgW10pO1xuICAgICAgY29uc3QgY2xpZW50UmVjdHMgPSBnZXRSZWN0c0J5TGluZShuYXRpdmVDbGllbnRSZWN0cyk7XG4gICAgICBjb25zdCBmYWxsYmFjayA9IHJlY3RUb0NsaWVudFJlY3QoZ2V0Qm91bmRpbmdSZWN0KG5hdGl2ZUNsaWVudFJlY3RzKSk7XG4gICAgICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0UGFkZGluZ09iamVjdChwYWRkaW5nKTtcbiAgICAgIGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIHR3byByZWN0cyBhbmQgdGhleSBhcmUgZGlzam9pbmVkLlxuICAgICAgICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoID09PSAyICYmIGNsaWVudFJlY3RzWzBdLmxlZnQgPiBjbGllbnRSZWN0c1sxXS5yaWdodCAmJiB4ICE9IG51bGwgJiYgeSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgcmVjdCBpbiB3aGljaCB0aGUgcG9pbnQgaXMgZnVsbHkgaW5zaWRlLlxuICAgICAgICAgIHJldHVybiBjbGllbnRSZWN0cy5maW5kKHJlY3QgPT4geCA+IHJlY3QubGVmdCAtIHBhZGRpbmdPYmplY3QubGVmdCAmJiB4IDwgcmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHQgJiYgeSA+IHJlY3QudG9wIC0gcGFkZGluZ09iamVjdC50b3AgJiYgeSA8IHJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20pIHx8IGZhbGxiYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlcmUgYXJlIDIgb3IgbW9yZSBjb25uZWN0ZWQgcmVjdHMuXG4gICAgICAgIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgIGlmIChnZXRTaWRlQXhpcyhwbGFjZW1lbnQpID09PSAneScpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UmVjdCA9IGNsaWVudFJlY3RzWzBdO1xuICAgICAgICAgICAgY29uc3QgbGFzdFJlY3QgPSBjbGllbnRSZWN0c1tjbGllbnRSZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IGlzVG9wID0gZ2V0U2lkZShwbGFjZW1lbnQpID09PSAndG9wJztcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IGZpcnN0UmVjdC50b3A7XG4gICAgICAgICAgICBjb25zdCBib3R0b20gPSBsYXN0UmVjdC5ib3R0b207XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gaXNUb3AgPyBmaXJzdFJlY3QubGVmdCA6IGxhc3RSZWN0LmxlZnQ7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IGlzVG9wID8gZmlyc3RSZWN0LnJpZ2h0IDogbGFzdFJlY3QucmlnaHQ7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgeDogbGVmdCxcbiAgICAgICAgICAgICAgeTogdG9wXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpc0xlZnRTaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpID09PSAnbGVmdCc7XG4gICAgICAgICAgY29uc3QgbWF4UmlnaHQgPSBtYXgoLi4uY2xpZW50UmVjdHMubWFwKHJlY3QgPT4gcmVjdC5yaWdodCkpO1xuICAgICAgICAgIGNvbnN0IG1pbkxlZnQgPSBtaW4oLi4uY2xpZW50UmVjdHMubWFwKHJlY3QgPT4gcmVjdC5sZWZ0KSk7XG4gICAgICAgICAgY29uc3QgbWVhc3VyZVJlY3RzID0gY2xpZW50UmVjdHMuZmlsdGVyKHJlY3QgPT4gaXNMZWZ0U2lkZSA/IHJlY3QubGVmdCA9PT0gbWluTGVmdCA6IHJlY3QucmlnaHQgPT09IG1heFJpZ2h0KTtcbiAgICAgICAgICBjb25zdCB0b3AgPSBtZWFzdXJlUmVjdHNbMF0udG9wO1xuICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IG1lYXN1cmVSZWN0c1ttZWFzdXJlUmVjdHMubGVuZ3RoIC0gMV0uYm90dG9tO1xuICAgICAgICAgIGNvbnN0IGxlZnQgPSBtaW5MZWZ0O1xuICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gbWF4UmlnaHQ7XG4gICAgICAgICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIHg6IGxlZnQsXG4gICAgICAgICAgICB5OiB0b3BcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc2V0UmVjdHMgPSBhd2FpdCBwbGF0Zm9ybS5nZXRFbGVtZW50UmVjdHMoe1xuICAgICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAgICAgICAgfSxcbiAgICAgICAgZmxvYXRpbmc6IGVsZW1lbnRzLmZsb2F0aW5nLFxuICAgICAgICBzdHJhdGVneVxuICAgICAgfSk7XG4gICAgICBpZiAocmVjdHMucmVmZXJlbmNlLnggIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLnggfHwgcmVjdHMucmVmZXJlbmNlLnkgIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLnkgfHwgcmVjdHMucmVmZXJlbmNlLndpZHRoICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS53aWR0aCB8fCByZWN0cy5yZWZlcmVuY2UuaGVpZ2h0ICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcmVjdHM6IHJlc2V0UmVjdHNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuLy8gRm9yIHR5cGUgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksIHRoZSBgT2Zmc2V0T3B0aW9uc2AgdHlwZSB3YXMgYWxzb1xuLy8gRGVyaXZhYmxlLlxuXG5hc3luYyBmdW5jdGlvbiBjb252ZXJ0VmFsdWVUb0Nvb3JkcyhzdGF0ZSwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgcGxhY2VtZW50LFxuICAgIHBsYXRmb3JtLFxuICAgIGVsZW1lbnRzXG4gIH0gPSBzdGF0ZTtcbiAgY29uc3QgcnRsID0gYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpO1xuICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KTtcbiAgY29uc3QgaXNWZXJ0aWNhbCA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCkgPT09ICd5JztcbiAgY29uc3QgbWFpbkF4aXNNdWx0aSA9IFsnbGVmdCcsICd0b3AnXS5pbmNsdWRlcyhzaWRlKSA/IC0xIDogMTtcbiAgY29uc3QgY3Jvc3NBeGlzTXVsdGkgPSBydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMTtcbiAgY29uc3QgcmF3VmFsdWUgPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICBsZXQge1xuICAgIG1haW5BeGlzLFxuICAgIGNyb3NzQXhpcyxcbiAgICBhbGlnbm1lbnRBeGlzXG4gIH0gPSB0eXBlb2YgcmF3VmFsdWUgPT09ICdudW1iZXInID8ge1xuICAgIG1haW5BeGlzOiByYXdWYWx1ZSxcbiAgICBjcm9zc0F4aXM6IDAsXG4gICAgYWxpZ25tZW50QXhpczogbnVsbFxuICB9IDoge1xuICAgIG1haW5BeGlzOiByYXdWYWx1ZS5tYWluQXhpcyB8fCAwLFxuICAgIGNyb3NzQXhpczogcmF3VmFsdWUuY3Jvc3NBeGlzIHx8IDAsXG4gICAgYWxpZ25tZW50QXhpczogcmF3VmFsdWUuYWxpZ25tZW50QXhpc1xuICB9O1xuICBpZiAoYWxpZ25tZW50ICYmIHR5cGVvZiBhbGlnbm1lbnRBeGlzID09PSAnbnVtYmVyJykge1xuICAgIGNyb3NzQXhpcyA9IGFsaWdubWVudCA9PT0gJ2VuZCcgPyBhbGlnbm1lbnRBeGlzICogLTEgOiBhbGlnbm1lbnRBeGlzO1xuICB9XG4gIHJldHVybiBpc1ZlcnRpY2FsID8ge1xuICAgIHg6IGNyb3NzQXhpcyAqIGNyb3NzQXhpc011bHRpLFxuICAgIHk6IG1haW5BeGlzICogbWFpbkF4aXNNdWx0aVxuICB9IDoge1xuICAgIHg6IG1haW5BeGlzICogbWFpbkF4aXNNdWx0aSxcbiAgICB5OiBjcm9zc0F4aXMgKiBjcm9zc0F4aXNNdWx0aVxuICB9O1xufVxuXG4vKipcbiAqIE1vZGlmaWVzIHRoZSBwbGFjZW1lbnQgYnkgdHJhbnNsYXRpbmcgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYWxvbmcgdGhlXG4gKiBzcGVjaWZpZWQgYXhlcy5cbiAqIEEgbnVtYmVyIChzaG9ydGhhbmQgZm9yIGBtYWluQXhpc2Agb3IgZGlzdGFuY2UpLCBvciBhbiBheGVzIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdCBtYXkgYmUgcGFzc2VkLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL29mZnNldFxuICovXG5jb25zdCBvZmZzZXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJG9mZnNlLCBfbWlkZGxld2FyZURhdGEkYXJyb3c7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgbWlkZGxld2FyZURhdGFcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IGRpZmZDb29yZHMgPSBhd2FpdCBjb252ZXJ0VmFsdWVUb0Nvb3JkcyhzdGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIElmIHRoZSBwbGFjZW1lbnQgaXMgdGhlIHNhbWUgYW5kIHRoZSBhcnJvdyBjYXVzZWQgYW4gYWxpZ25tZW50IG9mZnNldFxuICAgICAgLy8gdGhlbiB3ZSBkb24ndCBuZWVkIHRvIGNoYW5nZSB0aGUgcG9zaXRpb25pbmcgY29vcmRpbmF0ZXMuXG4gICAgICBpZiAocGxhY2VtZW50ID09PSAoKF9taWRkbGV3YXJlRGF0YSRvZmZzZSA9IG1pZGRsZXdhcmVEYXRhLm9mZnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRvZmZzZS5wbGFjZW1lbnQpICYmIChfbWlkZGxld2FyZURhdGEkYXJyb3cgPSBtaWRkbGV3YXJlRGF0YS5hcnJvdykgIT0gbnVsbCAmJiBfbWlkZGxld2FyZURhdGEkYXJyb3cuYWxpZ25tZW50T2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggKyBkaWZmQ29vcmRzLngsXG4gICAgICAgIHk6IHkgKyBkaWZmQ29vcmRzLnksXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAuLi5kaWZmQ29vcmRzLFxuICAgICAgICAgIHBsYWNlbWVudFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IHNoaWZ0aW5nIGl0IGluIG9yZGVyIHRvXG4gKiBrZWVwIGl0IGluIHZpZXcgd2hlbiBpdCB3aWxsIG92ZXJmbG93IHRoZSBjbGlwcGluZyBib3VuZGFyeS5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaGlmdFxuICovXG5jb25zdCBzaGlmdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnc2hpZnQnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcGxhY2VtZW50XG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gdHJ1ZSxcbiAgICAgICAgY3Jvc3NBeGlzOiBjaGVja0Nyb3NzQXhpcyA9IGZhbHNlLFxuICAgICAgICBsaW1pdGVyID0ge1xuICAgICAgICAgIGZuOiBfcmVmID0+IHtcbiAgICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgIHlcbiAgICAgICAgICAgIH0gPSBfcmVmO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBjcm9zc0F4aXMgPSBnZXRTaWRlQXhpcyhnZXRTaWRlKHBsYWNlbWVudCkpO1xuICAgICAgY29uc3QgbWFpbkF4aXMgPSBnZXRPcHBvc2l0ZUF4aXMoY3Jvc3NBeGlzKTtcbiAgICAgIGxldCBtYWluQXhpc0Nvb3JkID0gY29vcmRzW21haW5BeGlzXTtcbiAgICAgIGxldCBjcm9zc0F4aXNDb29yZCA9IGNvb3Jkc1tjcm9zc0F4aXNdO1xuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgY29uc3QgbWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyAndG9wJyA6ICdsZWZ0JztcbiAgICAgICAgY29uc3QgbWF4U2lkZSA9IG1haW5BeGlzID09PSAneScgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgICAgIGNvbnN0IG1pbiA9IG1haW5BeGlzQ29vcmQgKyBvdmVyZmxvd1ttaW5TaWRlXTtcbiAgICAgICAgY29uc3QgbWF4ID0gbWFpbkF4aXNDb29yZCAtIG92ZXJmbG93W21heFNpZGVdO1xuICAgICAgICBtYWluQXhpc0Nvb3JkID0gY2xhbXAobWluLCBtYWluQXhpc0Nvb3JkLCBtYXgpO1xuICAgICAgfVxuICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgIGNvbnN0IG1pblNpZGUgPSBjcm9zc0F4aXMgPT09ICd5JyA/ICd0b3AnIDogJ2xlZnQnO1xuICAgICAgICBjb25zdCBtYXhTaWRlID0gY3Jvc3NBeGlzID09PSAneScgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgICAgIGNvbnN0IG1pbiA9IGNyb3NzQXhpc0Nvb3JkICsgb3ZlcmZsb3dbbWluU2lkZV07XG4gICAgICAgIGNvbnN0IG1heCA9IGNyb3NzQXhpc0Nvb3JkIC0gb3ZlcmZsb3dbbWF4U2lkZV07XG4gICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gY2xhbXAobWluLCBjcm9zc0F4aXNDb29yZCwgbWF4KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpbWl0ZWRDb29yZHMgPSBsaW1pdGVyLmZuKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIFttYWluQXhpc106IG1haW5BeGlzQ29vcmQsXG4gICAgICAgIFtjcm9zc0F4aXNdOiBjcm9zc0F4aXNDb29yZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5saW1pdGVkQ29vcmRzLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgeDogbGltaXRlZENvb3Jkcy54IC0geCxcbiAgICAgICAgICB5OiBsaW1pdGVkQ29vcmRzLnkgLSB5LFxuICAgICAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgICAgIFttYWluQXhpc106IGNoZWNrTWFpbkF4aXMsXG4gICAgICAgICAgICBbY3Jvc3NBeGlzXTogY2hlY2tDcm9zc0F4aXNcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcbi8qKlxuICogQnVpbHQtaW4gYGxpbWl0ZXJgIHRoYXQgd2lsbCBzdG9wIGBzaGlmdCgpYCBhdCBhIGNlcnRhaW4gcG9pbnQuXG4gKi9cbmNvbnN0IGxpbWl0U2hpZnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgb3B0aW9ucyxcbiAgICBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBtaWRkbGV3YXJlRGF0YVxuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvZmZzZXQgPSAwLFxuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSB0cnVlXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3QgY29vcmRzID0ge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9O1xuICAgICAgY29uc3QgY3Jvc3NBeGlzID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IG1haW5BeGlzID0gZ2V0T3Bwb3NpdGVBeGlzKGNyb3NzQXhpcyk7XG4gICAgICBsZXQgbWFpbkF4aXNDb29yZCA9IGNvb3Jkc1ttYWluQXhpc107XG4gICAgICBsZXQgY3Jvc3NBeGlzQ29vcmQgPSBjb29yZHNbY3Jvc3NBeGlzXTtcbiAgICAgIGNvbnN0IHJhd09mZnNldCA9IGV2YWx1YXRlKG9mZnNldCwgc3RhdGUpO1xuICAgICAgY29uc3QgY29tcHV0ZWRPZmZzZXQgPSB0eXBlb2YgcmF3T2Zmc2V0ID09PSAnbnVtYmVyJyA/IHtcbiAgICAgICAgbWFpbkF4aXM6IHJhd09mZnNldCxcbiAgICAgICAgY3Jvc3NBeGlzOiAwXG4gICAgICB9IDoge1xuICAgICAgICBtYWluQXhpczogMCxcbiAgICAgICAgY3Jvc3NBeGlzOiAwLFxuICAgICAgICAuLi5yYXdPZmZzZXRcbiAgICAgIH07XG4gICAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgICBjb25zdCBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgICAgICBjb25zdCBsaW1pdE1pbiA9IHJlY3RzLnJlZmVyZW5jZVttYWluQXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5dICsgY29tcHV0ZWRPZmZzZXQubWFpbkF4aXM7XG4gICAgICAgIGNvbnN0IGxpbWl0TWF4ID0gcmVjdHMucmVmZXJlbmNlW21haW5BeGlzXSArIHJlY3RzLnJlZmVyZW5jZVtsZW5dIC0gY29tcHV0ZWRPZmZzZXQubWFpbkF4aXM7XG4gICAgICAgIGlmIChtYWluQXhpc0Nvb3JkIDwgbGltaXRNaW4pIHtcbiAgICAgICAgICBtYWluQXhpc0Nvb3JkID0gbGltaXRNaW47XG4gICAgICAgIH0gZWxzZSBpZiAobWFpbkF4aXNDb29yZCA+IGxpbWl0TWF4KSB7XG4gICAgICAgICAgbWFpbkF4aXNDb29yZCA9IGxpbWl0TWF4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2hlY2tDcm9zc0F4aXMpIHtcbiAgICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRvZmZzZSwgX21pZGRsZXdhcmVEYXRhJG9mZnNlMjtcbiAgICAgICAgY29uc3QgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICAgICAgY29uc3QgaXNPcmlnaW5TaWRlID0gWyd0b3AnLCAnbGVmdCddLmluY2x1ZGVzKGdldFNpZGUocGxhY2VtZW50KSk7XG4gICAgICAgIGNvbnN0IGxpbWl0TWluID0gcmVjdHMucmVmZXJlbmNlW2Nyb3NzQXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5dICsgKGlzT3JpZ2luU2lkZSA/ICgoX21pZGRsZXdhcmVEYXRhJG9mZnNlID0gbWlkZGxld2FyZURhdGEub2Zmc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJG9mZnNlW2Nyb3NzQXhpc10pIHx8IDAgOiAwKSArIChpc09yaWdpblNpZGUgPyAwIDogY29tcHV0ZWRPZmZzZXQuY3Jvc3NBeGlzKTtcbiAgICAgICAgY29uc3QgbGltaXRNYXggPSByZWN0cy5yZWZlcmVuY2VbY3Jvc3NBeGlzXSArIHJlY3RzLnJlZmVyZW5jZVtsZW5dICsgKGlzT3JpZ2luU2lkZSA/IDAgOiAoKF9taWRkbGV3YXJlRGF0YSRvZmZzZTIgPSBtaWRkbGV3YXJlRGF0YS5vZmZzZXQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkb2Zmc2UyW2Nyb3NzQXhpc10pIHx8IDApIC0gKGlzT3JpZ2luU2lkZSA/IGNvbXB1dGVkT2Zmc2V0LmNyb3NzQXhpcyA6IDApO1xuICAgICAgICBpZiAoY3Jvc3NBeGlzQ29vcmQgPCBsaW1pdE1pbikge1xuICAgICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gbGltaXRNaW47XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBeGlzQ29vcmQgPiBsaW1pdE1heCkge1xuICAgICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gbGltaXRNYXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIFttYWluQXhpc106IG1haW5BeGlzQ29vcmQsXG4gICAgICAgIFtjcm9zc0F4aXNdOiBjcm9zc0F4aXNDb29yZFxuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdGhhdCBhbGxvd3MgeW91IHRvIGNoYW5nZSB0aGUgc2l6ZSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCDigJRcbiAqIGZvciBpbnN0YW5jZSwgcHJldmVudCBpdCBmcm9tIG92ZXJmbG93aW5nIHRoZSBjbGlwcGluZyBib3VuZGFyeSBvciBtYXRjaCB0aGVcbiAqIHdpZHRoIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaXplXG4gKi9cbmNvbnN0IHNpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ3NpemUnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIHZhciBfc3RhdGUkbWlkZGxld2FyZURhdGEsIF9zdGF0ZSRtaWRkbGV3YXJlRGF0YTI7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhcHBseSA9ICgpID0+IHt9LFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgaXNZQXhpcyA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCkgPT09ICd5JztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IHJlY3RzLmZsb2F0aW5nO1xuICAgICAgbGV0IGhlaWdodFNpZGU7XG4gICAgICBsZXQgd2lkdGhTaWRlO1xuICAgICAgaWYgKHNpZGUgPT09ICd0b3AnIHx8IHNpZGUgPT09ICdib3R0b20nKSB7XG4gICAgICAgIGhlaWdodFNpZGUgPSBzaWRlO1xuICAgICAgICB3aWR0aFNpZGUgPSBhbGlnbm1lbnQgPT09ICgoYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpKSA/ICdzdGFydCcgOiAnZW5kJykgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGhTaWRlID0gc2lkZTtcbiAgICAgICAgaGVpZ2h0U2lkZSA9IGFsaWdubWVudCA9PT0gJ2VuZCcgPyAndG9wJyA6ICdib3R0b20nO1xuICAgICAgfVxuICAgICAgY29uc3QgbWF4aW11bUNsaXBwaW5nSGVpZ2h0ID0gaGVpZ2h0IC0gb3ZlcmZsb3cudG9wIC0gb3ZlcmZsb3cuYm90dG9tO1xuICAgICAgY29uc3QgbWF4aW11bUNsaXBwaW5nV2lkdGggPSB3aWR0aCAtIG92ZXJmbG93LmxlZnQgLSBvdmVyZmxvdy5yaWdodDtcbiAgICAgIGNvbnN0IG92ZXJmbG93QXZhaWxhYmxlSGVpZ2h0ID0gbWluKGhlaWdodCAtIG92ZXJmbG93W2hlaWdodFNpZGVdLCBtYXhpbXVtQ2xpcHBpbmdIZWlnaHQpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3dBdmFpbGFibGVXaWR0aCA9IG1pbih3aWR0aCAtIG92ZXJmbG93W3dpZHRoU2lkZV0sIG1heGltdW1DbGlwcGluZ1dpZHRoKTtcbiAgICAgIGNvbnN0IG5vU2hpZnQgPSAhc3RhdGUubWlkZGxld2FyZURhdGEuc2hpZnQ7XG4gICAgICBsZXQgYXZhaWxhYmxlSGVpZ2h0ID0gb3ZlcmZsb3dBdmFpbGFibGVIZWlnaHQ7XG4gICAgICBsZXQgYXZhaWxhYmxlV2lkdGggPSBvdmVyZmxvd0F2YWlsYWJsZVdpZHRoO1xuICAgICAgaWYgKChfc3RhdGUkbWlkZGxld2FyZURhdGEgPSBzdGF0ZS5taWRkbGV3YXJlRGF0YS5zaGlmdCkgIT0gbnVsbCAmJiBfc3RhdGUkbWlkZGxld2FyZURhdGEuZW5hYmxlZC54KSB7XG4gICAgICAgIGF2YWlsYWJsZVdpZHRoID0gbWF4aW11bUNsaXBwaW5nV2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAoKF9zdGF0ZSRtaWRkbGV3YXJlRGF0YTIgPSBzdGF0ZS5taWRkbGV3YXJlRGF0YS5zaGlmdCkgIT0gbnVsbCAmJiBfc3RhdGUkbWlkZGxld2FyZURhdGEyLmVuYWJsZWQueSkge1xuICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBtYXhpbXVtQ2xpcHBpbmdIZWlnaHQ7XG4gICAgICB9XG4gICAgICBpZiAobm9TaGlmdCAmJiAhYWxpZ25tZW50KSB7XG4gICAgICAgIGNvbnN0IHhNaW4gPSBtYXgob3ZlcmZsb3cubGVmdCwgMCk7XG4gICAgICAgIGNvbnN0IHhNYXggPSBtYXgob3ZlcmZsb3cucmlnaHQsIDApO1xuICAgICAgICBjb25zdCB5TWluID0gbWF4KG92ZXJmbG93LnRvcCwgMCk7XG4gICAgICAgIGNvbnN0IHlNYXggPSBtYXgob3ZlcmZsb3cuYm90dG9tLCAwKTtcbiAgICAgICAgaWYgKGlzWUF4aXMpIHtcbiAgICAgICAgICBhdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gMiAqICh4TWluICE9PSAwIHx8IHhNYXggIT09IDAgPyB4TWluICsgeE1heCA6IG1heChvdmVyZmxvdy5sZWZ0LCBvdmVyZmxvdy5yaWdodCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIDIgKiAoeU1pbiAhPT0gMCB8fCB5TWF4ICE9PSAwID8geU1pbiArIHlNYXggOiBtYXgob3ZlcmZsb3cudG9wLCBvdmVyZmxvdy5ib3R0b20pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXdhaXQgYXBwbHkoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgYXZhaWxhYmxlV2lkdGgsXG4gICAgICAgIGF2YWlsYWJsZUhlaWdodFxuICAgICAgfSk7XG4gICAgICBjb25zdCBuZXh0RGltZW5zaW9ucyA9IGF3YWl0IHBsYXRmb3JtLmdldERpbWVuc2lvbnMoZWxlbWVudHMuZmxvYXRpbmcpO1xuICAgICAgaWYgKHdpZHRoICE9PSBuZXh0RGltZW5zaW9ucy53aWR0aCB8fCBoZWlnaHQgIT09IG5leHREaW1lbnNpb25zLmhlaWdodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICByZWN0czogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnQgeyBhcnJvdywgYXV0b1BsYWNlbWVudCwgY29tcHV0ZVBvc2l0aW9uLCBkZXRlY3RPdmVyZmxvdywgZmxpcCwgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHNoaWZ0LCBzaXplIH07XG4iXSwibmFtZXMiOlsiZ2V0U2lkZUF4aXMiLCJnZXRBbGlnbm1lbnRBeGlzIiwiZ2V0QXhpc0xlbmd0aCIsImdldFNpZGUiLCJnZXRBbGlnbm1lbnQiLCJldmFsdWF0ZSIsImdldFBhZGRpbmdPYmplY3QiLCJyZWN0VG9DbGllbnRSZWN0IiwibWluIiwiY2xhbXAiLCJwbGFjZW1lbnRzIiwiZ2V0QWxpZ25tZW50U2lkZXMiLCJnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudCIsImdldE9wcG9zaXRlUGxhY2VtZW50IiwiZ2V0RXhwYW5kZWRQbGFjZW1lbnRzIiwiZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyIsInNpZGVzIiwibWF4IiwiZ2V0T3Bwb3NpdGVBeGlzIiwiY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQiLCJfcmVmIiwicGxhY2VtZW50IiwicnRsIiwicmVmZXJlbmNlIiwiZmxvYXRpbmciLCJzaWRlQXhpcyIsImFsaWdubWVudEF4aXMiLCJhbGlnbkxlbmd0aCIsInNpZGUiLCJpc1ZlcnRpY2FsIiwiY29tbW9uWCIsIngiLCJ3aWR0aCIsImNvbW1vblkiLCJ5IiwiaGVpZ2h0IiwiY29tbW9uQWxpZ24iLCJjb29yZHMiLCJjb21wdXRlUG9zaXRpb24iLCJjb25maWciLCJzdHJhdGVneSIsIm1pZGRsZXdhcmUiLCJwbGF0Zm9ybSIsInZhbGlkTWlkZGxld2FyZSIsImZpbHRlciIsIkJvb2xlYW4iLCJpc1JUTCIsInJlY3RzIiwiZ2V0RWxlbWVudFJlY3RzIiwic3RhdGVmdWxQbGFjZW1lbnQiLCJtaWRkbGV3YXJlRGF0YSIsInJlc2V0Q291bnQiLCJpIiwibGVuZ3RoIiwibmFtZSIsImZuIiwibmV4dFgiLCJuZXh0WSIsImRhdGEiLCJyZXNldCIsImluaXRpYWxQbGFjZW1lbnQiLCJlbGVtZW50cyIsImRldGVjdE92ZXJmbG93Iiwic3RhdGUiLCJvcHRpb25zIiwiX2F3YWl0JHBsYXRmb3JtJGlzRWxlIiwiYm91bmRhcnkiLCJyb290Qm91bmRhcnkiLCJlbGVtZW50Q29udGV4dCIsImFsdEJvdW5kYXJ5IiwicGFkZGluZyIsInBhZGRpbmdPYmplY3QiLCJhbHRDb250ZXh0IiwiZWxlbWVudCIsImNsaXBwaW5nQ2xpZW50UmVjdCIsImdldENsaXBwaW5nUmVjdCIsImlzRWxlbWVudCIsImNvbnRleHRFbGVtZW50IiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwicmVjdCIsIm9mZnNldFBhcmVudCIsImdldE9mZnNldFBhcmVudCIsIm9mZnNldFNjYWxlIiwiZ2V0U2NhbGUiLCJlbGVtZW50Q2xpZW50UmVjdCIsImNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0IiwidG9wIiwiYm90dG9tIiwibGVmdCIsInJpZ2h0IiwiYXJyb3ciLCJheGlzIiwiYXJyb3dEaW1lbnNpb25zIiwiZ2V0RGltZW5zaW9ucyIsImlzWUF4aXMiLCJtaW5Qcm9wIiwibWF4UHJvcCIsImNsaWVudFByb3AiLCJlbmREaWZmIiwic3RhcnREaWZmIiwiYXJyb3dPZmZzZXRQYXJlbnQiLCJjbGllbnRTaXplIiwiY2VudGVyVG9SZWZlcmVuY2UiLCJsYXJnZXN0UG9zc2libGVQYWRkaW5nIiwibWluUGFkZGluZyIsIm1heFBhZGRpbmciLCJtaW4kMSIsImNlbnRlciIsIm9mZnNldCIsInNob3VsZEFkZE9mZnNldCIsImFsaWdubWVudE9mZnNldCIsImNlbnRlck9mZnNldCIsImdldFBsYWNlbWVudExpc3QiLCJhbGlnbm1lbnQiLCJhdXRvQWxpZ25tZW50IiwiYWxsb3dlZFBsYWNlbWVudHMiLCJhbGxvd2VkUGxhY2VtZW50c1NvcnRlZEJ5QWxpZ25tZW50IiwiYXV0b1BsYWNlbWVudCIsIl9taWRkbGV3YXJlRGF0YSRhdXRvUCIsIl9taWRkbGV3YXJlRGF0YSRhdXRvUDIiLCJfcGxhY2VtZW50c1RoYXRGaXRPbkUiLCJjcm9zc0F4aXMiLCJkZXRlY3RPdmVyZmxvd09wdGlvbnMiLCJwbGFjZW1lbnRzJDEiLCJ1bmRlZmluZWQiLCJvdmVyZmxvdyIsImN1cnJlbnRJbmRleCIsImluZGV4IiwiY3VycmVudFBsYWNlbWVudCIsImFsaWdubWVudFNpZGVzIiwiY3VycmVudE92ZXJmbG93cyIsImFsbE92ZXJmbG93cyIsIm92ZXJmbG93cyIsIm5leHRQbGFjZW1lbnQiLCJwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2UiLCJtYXAiLCJkIiwic2xpY2UiLCJyZWR1Y2UiLCJhY2MiLCJ2Iiwic29ydCIsImEiLCJiIiwicGxhY2VtZW50c1RoYXRGaXRPbkVhY2hTaWRlIiwiZXZlcnkiLCJyZXNldFBsYWNlbWVudCIsImZsaXAiLCJfbWlkZGxld2FyZURhdGEkYXJyb3ciLCJfbWlkZGxld2FyZURhdGEkZmxpcCIsIm1haW5BeGlzIiwiY2hlY2tNYWluQXhpcyIsImNoZWNrQ3Jvc3NBeGlzIiwiZmFsbGJhY2tQbGFjZW1lbnRzIiwic3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIiwiZmFsbGJhY2tTdHJhdGVneSIsImZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24iLCJmbGlwQWxpZ25tZW50IiwiaW5pdGlhbFNpZGVBeGlzIiwiaXNCYXNlUGxhY2VtZW50IiwiaGFzRmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiIsInB1c2giLCJvdmVyZmxvd3NEYXRhIiwiX21pZGRsZXdhcmVEYXRhJGZsaXAyIiwiX292ZXJmbG93c0RhdGEkZmlsdGVyIiwibmV4dEluZGV4IiwiX292ZXJmbG93c0RhdGEkZmlsdGVyMiIsImN1cnJlbnRTaWRlQXhpcyIsImdldFNpZGVPZmZzZXRzIiwiaXNBbnlTaWRlRnVsbHlDbGlwcGVkIiwic29tZSIsImhpZGUiLCJvZmZzZXRzIiwicmVmZXJlbmNlSGlkZGVuT2Zmc2V0cyIsInJlZmVyZW5jZUhpZGRlbiIsImVzY2FwZWRPZmZzZXRzIiwiZXNjYXBlZCIsImdldEJvdW5kaW5nUmVjdCIsIm1pblgiLCJtaW5ZIiwibWF4WCIsIm1heFkiLCJnZXRSZWN0c0J5TGluZSIsInNvcnRlZFJlY3RzIiwiZ3JvdXBzIiwicHJldlJlY3QiLCJpbmxpbmUiLCJuYXRpdmVDbGllbnRSZWN0cyIsIkFycmF5IiwiZnJvbSIsImdldENsaWVudFJlY3RzIiwiY2xpZW50UmVjdHMiLCJmYWxsYmFjayIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImZpbmQiLCJmaXJzdFJlY3QiLCJsYXN0UmVjdCIsImlzVG9wIiwiaXNMZWZ0U2lkZSIsIm1heFJpZ2h0IiwibWluTGVmdCIsIm1lYXN1cmVSZWN0cyIsInJlc2V0UmVjdHMiLCJjb252ZXJ0VmFsdWVUb0Nvb3JkcyIsIm1haW5BeGlzTXVsdGkiLCJpbmNsdWRlcyIsImNyb3NzQXhpc011bHRpIiwicmF3VmFsdWUiLCJfbWlkZGxld2FyZURhdGEkb2Zmc2UiLCJkaWZmQ29vcmRzIiwic2hpZnQiLCJsaW1pdGVyIiwibWFpbkF4aXNDb29yZCIsImNyb3NzQXhpc0Nvb3JkIiwibWluU2lkZSIsIm1heFNpZGUiLCJsaW1pdGVkQ29vcmRzIiwiZW5hYmxlZCIsImxpbWl0U2hpZnQiLCJyYXdPZmZzZXQiLCJjb21wdXRlZE9mZnNldCIsImxlbiIsImxpbWl0TWluIiwibGltaXRNYXgiLCJfbWlkZGxld2FyZURhdGEkb2Zmc2UyIiwiaXNPcmlnaW5TaWRlIiwic2l6ZSIsIl9zdGF0ZSRtaWRkbGV3YXJlRGF0YSIsIl9zdGF0ZSRtaWRkbGV3YXJlRGF0YTIiLCJhcHBseSIsImhlaWdodFNpZGUiLCJ3aWR0aFNpZGUiLCJtYXhpbXVtQ2xpcHBpbmdIZWlnaHQiLCJtYXhpbXVtQ2xpcHBpbmdXaWR0aCIsIm92ZXJmbG93QXZhaWxhYmxlSGVpZ2h0Iiwib3ZlcmZsb3dBdmFpbGFibGVXaWR0aCIsIm5vU2hpZnQiLCJhdmFpbGFibGVIZWlnaHQiLCJhdmFpbGFibGVXaWR0aCIsInhNaW4iLCJ4TWF4IiwieU1pbiIsInlNYXgiLCJuZXh0RGltZW5zaW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),\n/* harmony export */   autoUpdate: () => (/* binding */ autoUpdate),\n/* harmony export */   computePosition: () => (/* binding */ computePosition),\n/* harmony export */   detectOverflow: () => (/* binding */ detectOverflow),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   inline: () => (/* binding */ inline),\n/* harmony export */   limitShift: () => (/* binding */ limitShift),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   platform: () => (/* binding */ platform),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   size: () => (/* binding */ size)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n/* harmony import */ var _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/core */ \"(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n\n\n\n\nfunction getCssDimensions(element) {\n    const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element);\n    // In testing environments, the `width` and `height` properties are empty\n    // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n    let width = parseFloat(css.width) || 0;\n    let height = parseFloat(css.height) || 0;\n    const hasOffset = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element);\n    const offsetWidth = hasOffset ? element.offsetWidth : width;\n    const offsetHeight = hasOffset ? element.offsetHeight : height;\n    const shouldFallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(width) !== offsetWidth || (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(height) !== offsetHeight;\n    if (shouldFallback) {\n        width = offsetWidth;\n        height = offsetHeight;\n    }\n    return {\n        width,\n        height,\n        $: shouldFallback\n    };\n}\nfunction unwrapElement(element) {\n    return !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? element.contextElement : element;\n}\nfunction getScale(element) {\n    const domElement = unwrapElement(element);\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(domElement)) {\n        return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n    }\n    const rect = domElement.getBoundingClientRect();\n    const { width, height, $ } = getCssDimensions(domElement);\n    let x = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(rect.width) : rect.width) / width;\n    let y = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(rect.height) : rect.height) / height;\n    // 0, NaN, or Infinity should always fallback to 1.\n    if (!x || !Number.isFinite(x)) {\n        x = 1;\n    }\n    if (!y || !Number.isFinite(y)) {\n        y = 1;\n    }\n    return {\n        x,\n        y\n    };\n}\nconst noOffsets = /*#__PURE__*/ (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\nfunction getVisualOffsets(element) {\n    const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element);\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isWebKit)() || !win.visualViewport) {\n        return noOffsets;\n    }\n    return {\n        x: win.visualViewport.offsetLeft,\n        y: win.visualViewport.offsetTop\n    };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n    if (isFixed === void 0) {\n        isFixed = false;\n    }\n    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element)) {\n        return false;\n    }\n    return isFixed;\n}\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n    if (includeScale === void 0) {\n        includeScale = false;\n    }\n    if (isFixedStrategy === void 0) {\n        isFixedStrategy = false;\n    }\n    const clientRect = element.getBoundingClientRect();\n    const domElement = unwrapElement(element);\n    let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n    if (includeScale) {\n        if (offsetParent) {\n            if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(offsetParent)) {\n                scale = getScale(offsetParent);\n            }\n        } else {\n            scale = getScale(element);\n        }\n    }\n    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n    let x = (clientRect.left + visualOffsets.x) / scale.x;\n    let y = (clientRect.top + visualOffsets.y) / scale.y;\n    let width = clientRect.width / scale.x;\n    let height = clientRect.height / scale.y;\n    if (domElement) {\n        const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(domElement);\n        const offsetWin = offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(offsetParent) ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(offsetParent) : offsetParent;\n        let currentWin = win;\n        let currentIFrame = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getFrameElement)(currentWin);\n        while(currentIFrame && offsetParent && offsetWin !== currentWin){\n            const iframeScale = getScale(currentIFrame);\n            const iframeRect = currentIFrame.getBoundingClientRect();\n            const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(currentIFrame);\n            const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n            const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n            x *= iframeScale.x;\n            y *= iframeScale.y;\n            width *= iframeScale.x;\n            height *= iframeScale.y;\n            x += left;\n            y += top;\n            currentWin = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(currentIFrame);\n            currentIFrame = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getFrameElement)(currentWin);\n        }\n    }\n    return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.rectToClientRect)({\n        width,\n        height,\n        x,\n        y\n    });\n}\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n    const leftScroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(element).scrollLeft;\n    if (!rect) {\n        return getBoundingClientRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element)).left + leftScroll;\n    }\n    return rect.left + leftScroll;\n}\nfunction getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {\n    if (ignoreScrollbarX === void 0) {\n        ignoreScrollbarX = false;\n    }\n    const htmlRect = documentElement.getBoundingClientRect();\n    const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : // RTL <body> scrollbar.\n    getWindowScrollBarX(documentElement, htmlRect));\n    const y = htmlRect.top + scroll.scrollTop;\n    return {\n        x,\n        y\n    };\n}\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n    let { elements, rect, offsetParent, strategy } = _ref;\n    const isFixed = strategy === \"fixed\";\n    const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(offsetParent);\n    const topLayer = elements ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTopLayer)(elements.floating) : false;\n    if (offsetParent === documentElement || topLayer && isFixed) {\n        return rect;\n    }\n    let scroll = {\n        scrollLeft: 0,\n        scrollTop: 0\n    };\n    let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n    const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n    const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(offsetParent);\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n        if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeName)(offsetParent) !== \"body\" || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isOverflowElement)(documentElement)) {\n            scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(offsetParent);\n        }\n        if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(offsetParent)) {\n            const offsetRect = getBoundingClientRect(offsetParent);\n            scale = getScale(offsetParent);\n            offsets.x = offsetRect.x + offsetParent.clientLeft;\n            offsets.y = offsetRect.y + offsetParent.clientTop;\n        }\n    }\n    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n    return {\n        width: rect.width * scale.x,\n        height: rect.height * scale.y,\n        x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n        y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n    };\n}\nfunction getClientRects(element) {\n    return Array.from(element.getClientRects());\n}\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n    const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element);\n    const scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(element);\n    const body = element.ownerDocument.body;\n    const width = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n    const height = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n    let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n    const y = -scroll.scrollTop;\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(body).direction === \"rtl\") {\n        x += (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(html.clientWidth, body.clientWidth) - width;\n    }\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\nfunction getViewportRect(element, strategy) {\n    const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element);\n    const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element);\n    const visualViewport = win.visualViewport;\n    let width = html.clientWidth;\n    let height = html.clientHeight;\n    let x = 0;\n    let y = 0;\n    if (visualViewport) {\n        width = visualViewport.width;\n        height = visualViewport.height;\n        const visualViewportBased = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isWebKit)();\n        if (!visualViewportBased || visualViewportBased && strategy === \"fixed\") {\n            x = visualViewport.offsetLeft;\n            y = visualViewport.offsetTop;\n        }\n    }\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n    const clientRect = getBoundingClientRect(element, true, strategy === \"fixed\");\n    const top = clientRect.top + element.clientTop;\n    const left = clientRect.left + element.clientLeft;\n    const scale = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) ? getScale(element) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n    const width = element.clientWidth * scale.x;\n    const height = element.clientHeight * scale.y;\n    const x = left * scale.x;\n    const y = top * scale.y;\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n    let rect;\n    if (clippingAncestor === \"viewport\") {\n        rect = getViewportRect(element, strategy);\n    } else if (clippingAncestor === \"document\") {\n        rect = getDocumentRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element));\n    } else if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(clippingAncestor)) {\n        rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n    } else {\n        const visualOffsets = getVisualOffsets(element);\n        rect = {\n            x: clippingAncestor.x - visualOffsets.x,\n            y: clippingAncestor.y - visualOffsets.y,\n            width: clippingAncestor.width,\n            height: clippingAncestor.height\n        };\n    }\n    return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.rectToClientRect)(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n    const parentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(element);\n    if (parentNode === stopNode || !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(parentNode) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(parentNode)) {\n        return false;\n    }\n    return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(parentNode).position === \"fixed\" || hasFixedPositionAncestor(parentNode, stopNode);\n}\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n    const cachedResult = cache.get(element);\n    if (cachedResult) {\n        return cachedResult;\n    }\n    let result = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors)(element, [], false).filter((el)=>(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(el) && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeName)(el) !== \"body\");\n    let currentContainingBlockComputedStyle = null;\n    const elementIsFixed = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).position === \"fixed\";\n    let currentNode = elementIsFixed ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(element) : element;\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    while((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(currentNode) && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(currentNode)){\n        const computedStyle = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(currentNode);\n        const currentNodeIsContaining = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isContainingBlock)(currentNode);\n        if (!currentNodeIsContaining && computedStyle.position === \"fixed\") {\n            currentContainingBlockComputedStyle = null;\n        }\n        const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === \"static\" && !!currentContainingBlockComputedStyle && [\n            \"absolute\",\n            \"fixed\"\n        ].includes(currentContainingBlockComputedStyle.position) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isOverflowElement)(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n        if (shouldDropCurrentNode) {\n            // Drop non-containing blocks.\n            result = result.filter((ancestor)=>ancestor !== currentNode);\n        } else {\n            // Record last containing block for next iteration.\n            currentContainingBlockComputedStyle = computedStyle;\n        }\n        currentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(currentNode);\n    }\n    cache.set(element, result);\n    return result;\n}\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n    let { element, boundary, rootBoundary, strategy } = _ref;\n    const elementClippingAncestors = boundary === \"clippingAncestors\" ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTopLayer)(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n    const clippingAncestors = [\n        ...elementClippingAncestors,\n        rootBoundary\n    ];\n    const firstClippingAncestor = clippingAncestors[0];\n    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor)=>{\n        const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n        accRect.top = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(rect.top, accRect.top);\n        accRect.right = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.min)(rect.right, accRect.right);\n        accRect.bottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.min)(rect.bottom, accRect.bottom);\n        accRect.left = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(rect.left, accRect.left);\n        return accRect;\n    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n    return {\n        width: clippingRect.right - clippingRect.left,\n        height: clippingRect.bottom - clippingRect.top,\n        x: clippingRect.left,\n        y: clippingRect.top\n    };\n}\nfunction getDimensions(element) {\n    const { width, height } = getCssDimensions(element);\n    return {\n        width,\n        height\n    };\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n    const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(offsetParent);\n    const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(offsetParent);\n    const isFixed = strategy === \"fixed\";\n    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n    let scroll = {\n        scrollLeft: 0,\n        scrollTop: 0\n    };\n    const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n        if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeName)(offsetParent) !== \"body\" || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isOverflowElement)(documentElement)) {\n            scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(offsetParent);\n        }\n        if (isOffsetParentAnElement) {\n            const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n            offsets.x = offsetRect.x + offsetParent.clientLeft;\n            offsets.y = offsetRect.y + offsetParent.clientTop;\n        } else if (documentElement) {\n            // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n            // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n            offsets.x = getWindowScrollBarX(documentElement);\n        }\n    }\n    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n    const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n    const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n    return {\n        x,\n        y,\n        width: rect.width,\n        height: rect.height\n    };\n}\nfunction isStaticPositioned(element) {\n    return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).position === \"static\";\n}\nfunction getTrueOffsetParent(element, polyfill) {\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).position === \"fixed\") {\n        return null;\n    }\n    if (polyfill) {\n        return polyfill(element);\n    }\n    let rawOffsetParent = element.offsetParent;\n    // Firefox returns the <html> element as the offsetParent if it's non-static,\n    // while Chrome and Safari return the <body> element. The <body> element must\n    // be used to perform the correct calculations even if the <html> element is\n    // non-static.\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element) === rawOffsetParent) {\n        rawOffsetParent = rawOffsetParent.ownerDocument.body;\n    }\n    return rawOffsetParent;\n}\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n    const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element);\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTopLayer)(element)) {\n        return win;\n    }\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {\n        let svgOffsetParent = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(element);\n        while(svgOffsetParent && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(svgOffsetParent)){\n            if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n                return svgOffsetParent;\n            }\n            svgOffsetParent = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(svgOffsetParent);\n        }\n        return win;\n    }\n    let offsetParent = getTrueOffsetParent(element, polyfill);\n    while(offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTableElement)(offsetParent) && isStaticPositioned(offsetParent)){\n        offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n    }\n    if (offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(offsetParent) && isStaticPositioned(offsetParent) && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isContainingBlock)(offsetParent)) {\n        return win;\n    }\n    return offsetParent || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getContainingBlock)(element) || win;\n}\nconst getElementRects = async function(data) {\n    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n    const getDimensionsFn = this.getDimensions;\n    const floatingDimensions = await getDimensionsFn(data.floating);\n    return {\n        reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n        floating: {\n            x: 0,\n            y: 0,\n            width: floatingDimensions.width,\n            height: floatingDimensions.height\n        }\n    };\n};\nfunction isRTL(element) {\n    return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).direction === \"rtl\";\n}\nconst platform = {\n    convertOffsetParentRelativeRectToViewportRelativeRect,\n    getDocumentElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement,\n    getClippingRect,\n    getOffsetParent,\n    getElementRects,\n    getClientRects,\n    getDimensions,\n    getScale,\n    isElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement,\n    isRTL\n};\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n    let io = null;\n    let timeoutId;\n    const root = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element);\n    function cleanup() {\n        var _io;\n        clearTimeout(timeoutId);\n        (_io = io) == null || _io.disconnect();\n        io = null;\n    }\n    function refresh(skip, threshold) {\n        if (skip === void 0) {\n            skip = false;\n        }\n        if (threshold === void 0) {\n            threshold = 1;\n        }\n        cleanup();\n        const { left, top, width, height } = element.getBoundingClientRect();\n        if (!skip) {\n            onMove();\n        }\n        if (!width || !height) {\n            return;\n        }\n        const insetTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(top);\n        const insetRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(root.clientWidth - (left + width));\n        const insetBottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(root.clientHeight - (top + height));\n        const insetLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(left);\n        const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n        const options = {\n            rootMargin,\n            threshold: (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(0, (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.min)(1, threshold)) || 1\n        };\n        let isFirstUpdate = true;\n        function handleObserve(entries) {\n            const ratio = entries[0].intersectionRatio;\n            if (ratio !== threshold) {\n                if (!isFirstUpdate) {\n                    return refresh();\n                }\n                if (!ratio) {\n                    // If the reference is clipped, the ratio is 0. Throttle the refresh\n                    // to prevent an infinite loop of updates.\n                    timeoutId = setTimeout(()=>{\n                        refresh(false, 1e-7);\n                    }, 1000);\n                } else {\n                    refresh(false, ratio);\n                }\n            }\n            isFirstUpdate = false;\n        }\n        // Older browsers don't support a `document` as the root and will throw an\n        // error.\n        try {\n            io = new IntersectionObserver(handleObserve, {\n                ...options,\n                // Handle <iframe>s\n                root: root.ownerDocument\n            });\n        } catch (e) {\n            io = new IntersectionObserver(handleObserve, options);\n        }\n        io.observe(element);\n    }\n    refresh(true);\n    return cleanup;\n}\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */ function autoUpdate(reference, floating, update, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { ancestorScroll = true, ancestorResize = true, elementResize = typeof ResizeObserver === \"function\", layoutShift = typeof IntersectionObserver === \"function\", animationFrame = false } = options;\n    const referenceEl = unwrapElement(reference);\n    const ancestors = ancestorScroll || ancestorResize ? [\n        ...referenceEl ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors)(referenceEl) : [],\n        ...(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors)(floating)\n    ] : [];\n    ancestors.forEach((ancestor)=>{\n        ancestorScroll && ancestor.addEventListener(\"scroll\", update, {\n            passive: true\n        });\n        ancestorResize && ancestor.addEventListener(\"resize\", update);\n    });\n    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n    let reobserveFrame = -1;\n    let resizeObserver = null;\n    if (elementResize) {\n        resizeObserver = new ResizeObserver((_ref)=>{\n            let [firstEntry] = _ref;\n            if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n                // Prevent update loops when using the `size` middleware.\n                // https://github.com/floating-ui/floating-ui/issues/1740\n                resizeObserver.unobserve(floating);\n                cancelAnimationFrame(reobserveFrame);\n                reobserveFrame = requestAnimationFrame(()=>{\n                    var _resizeObserver;\n                    (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n                });\n            }\n            update();\n        });\n        if (referenceEl && !animationFrame) {\n            resizeObserver.observe(referenceEl);\n        }\n        resizeObserver.observe(floating);\n    }\n    let frameId;\n    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n    if (animationFrame) {\n        frameLoop();\n    }\n    function frameLoop() {\n        const nextRefRect = getBoundingClientRect(reference);\n        if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n            update();\n        }\n        prevRefRect = nextRefRect;\n        frameId = requestAnimationFrame(frameLoop);\n    }\n    update();\n    return ()=>{\n        var _resizeObserver2;\n        ancestors.forEach((ancestor)=>{\n            ancestorScroll && ancestor.removeEventListener(\"scroll\", update);\n            ancestorResize && ancestor.removeEventListener(\"resize\", update);\n        });\n        cleanupIo == null || cleanupIo();\n        (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n        resizeObserver = null;\n        if (animationFrame) {\n            cancelAnimationFrame(frameId);\n        }\n    };\n}\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */ const detectOverflow = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.detectOverflow;\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */ const offset = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.offset;\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */ const autoPlacement = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.autoPlacement;\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */ const shift = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.shift;\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */ const flip = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.flip;\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */ const size = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.size;\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */ const hide = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.hide;\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */ const arrow = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.arrow;\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */ const inline = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.inline;\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */ const limitShift = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.limitShift;\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */ const computePosition = (reference, floating, options)=>{\n    // This caches the expensive `getClippingElementAncestors` function so that\n    // multiple lifecycle resets re-use the same result. It only lives for a\n    // single call. If other functions become expensive, we can add them as well.\n    const cache = new Map();\n    const mergedOptions = {\n        platform,\n        ...options\n    };\n    const platformWithCache = {\n        ...mergedOptions.platform,\n        _c: cache\n    };\n    return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.computePosition)(reference, floating, {\n        ...mergedOptions,\n        platform: platformWithCache\n    });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLmRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBeVQ7QUFDL087QUFDa1A7QUFDOVA7QUFFOUQsU0FBUzZDLGlCQUFpQkMsT0FBTztJQUMvQixNQUFNQyxNQUFNbkIsd0VBQWdCQSxDQUFDa0I7SUFDN0IseUVBQXlFO0lBQ3pFLHlFQUF5RTtJQUN6RSxJQUFJRSxRQUFRQyxXQUFXRixJQUFJQyxLQUFLLEtBQUs7SUFDckMsSUFBSUUsU0FBU0QsV0FBV0YsSUFBSUcsTUFBTSxLQUFLO0lBQ3ZDLE1BQU1DLFlBQVl0QixxRUFBYUEsQ0FBQ2lCO0lBQ2hDLE1BQU1NLGNBQWNELFlBQVlMLFFBQVFNLFdBQVcsR0FBR0o7SUFDdEQsTUFBTUssZUFBZUYsWUFBWUwsUUFBUU8sWUFBWSxHQUFHSDtJQUN4RCxNQUFNSSxpQkFBaUIvQix5REFBS0EsQ0FBQ3lCLFdBQVdJLGVBQWU3Qix5REFBS0EsQ0FBQzJCLFlBQVlHO0lBQ3pFLElBQUlDLGdCQUFnQjtRQUNsQk4sUUFBUUk7UUFDUkYsU0FBU0c7SUFDWDtJQUNBLE9BQU87UUFDTEw7UUFDQUU7UUFDQUssR0FBR0Q7SUFDTDtBQUNGO0FBRUEsU0FBU0UsY0FBY1YsT0FBTztJQUM1QixPQUFPLENBQUNoQixpRUFBU0EsQ0FBQ2dCLFdBQVdBLFFBQVFXLGNBQWMsR0FBR1g7QUFDeEQ7QUFFQSxTQUFTWSxTQUFTWixPQUFPO0lBQ3ZCLE1BQU1hLGFBQWFILGNBQWNWO0lBQ2pDLElBQUksQ0FBQ2pCLHFFQUFhQSxDQUFDOEIsYUFBYTtRQUM5QixPQUFPbkMsZ0VBQVlBLENBQUM7SUFDdEI7SUFDQSxNQUFNb0MsT0FBT0QsV0FBV0UscUJBQXFCO0lBQzdDLE1BQU0sRUFDSmIsS0FBSyxFQUNMRSxNQUFNLEVBQ05LLENBQUMsRUFDRixHQUFHVixpQkFBaUJjO0lBQ3JCLElBQUlHLElBQUksQ0FBQ1AsSUFBSWhDLHlEQUFLQSxDQUFDcUMsS0FBS1osS0FBSyxJQUFJWSxLQUFLWixLQUFLLElBQUlBO0lBQy9DLElBQUllLElBQUksQ0FBQ1IsSUFBSWhDLHlEQUFLQSxDQUFDcUMsS0FBS1YsTUFBTSxJQUFJVSxLQUFLVixNQUFNLElBQUlBO0lBRWpELG1EQUFtRDtJQUVuRCxJQUFJLENBQUNZLEtBQUssQ0FBQ0UsT0FBT0MsUUFBUSxDQUFDSCxJQUFJO1FBQzdCQSxJQUFJO0lBQ047SUFDQSxJQUFJLENBQUNDLEtBQUssQ0FBQ0MsT0FBT0MsUUFBUSxDQUFDRixJQUFJO1FBQzdCQSxJQUFJO0lBQ047SUFDQSxPQUFPO1FBQ0xEO1FBQ0FDO0lBQ0Y7QUFDRjtBQUVBLE1BQU1HLFlBQVksV0FBVyxHQUFFMUMsZ0VBQVlBLENBQUM7QUFDNUMsU0FBUzJDLGlCQUFpQnJCLE9BQU87SUFDL0IsTUFBTXNCLE1BQU1yQyxpRUFBU0EsQ0FBQ2U7SUFDdEIsSUFBSSxDQUFDZCxnRUFBUUEsTUFBTSxDQUFDb0MsSUFBSUMsY0FBYyxFQUFFO1FBQ3RDLE9BQU9IO0lBQ1Q7SUFDQSxPQUFPO1FBQ0xKLEdBQUdNLElBQUlDLGNBQWMsQ0FBQ0MsVUFBVTtRQUNoQ1AsR0FBR0ssSUFBSUMsY0FBYyxDQUFDRSxTQUFTO0lBQ2pDO0FBQ0Y7QUFDQSxTQUFTQyx1QkFBdUIxQixPQUFPLEVBQUUyQixPQUFPLEVBQUVDLG9CQUFvQjtJQUNwRSxJQUFJRCxZQUFZLEtBQUssR0FBRztRQUN0QkEsVUFBVTtJQUNaO0lBQ0EsSUFBSSxDQUFDQyx3QkFBd0JELFdBQVdDLHlCQUF5QjNDLGlFQUFTQSxDQUFDZSxVQUFVO1FBQ25GLE9BQU87SUFDVDtJQUNBLE9BQU8yQjtBQUNUO0FBRUEsU0FBU1osc0JBQXNCZixPQUFPLEVBQUU2QixZQUFZLEVBQUVDLGVBQWUsRUFBRUMsWUFBWTtJQUNqRixJQUFJRixpQkFBaUIsS0FBSyxHQUFHO1FBQzNCQSxlQUFlO0lBQ2pCO0lBQ0EsSUFBSUMsb0JBQW9CLEtBQUssR0FBRztRQUM5QkEsa0JBQWtCO0lBQ3BCO0lBQ0EsTUFBTUUsYUFBYWhDLFFBQVFlLHFCQUFxQjtJQUNoRCxNQUFNRixhQUFhSCxjQUFjVjtJQUNqQyxJQUFJaUMsUUFBUXZELGdFQUFZQSxDQUFDO0lBQ3pCLElBQUltRCxjQUFjO1FBQ2hCLElBQUlFLGNBQWM7WUFDaEIsSUFBSS9DLGlFQUFTQSxDQUFDK0MsZUFBZTtnQkFDM0JFLFFBQVFyQixTQUFTbUI7WUFDbkI7UUFDRixPQUFPO1lBQ0xFLFFBQVFyQixTQUFTWjtRQUNuQjtJQUNGO0lBQ0EsTUFBTWtDLGdCQUFnQlIsdUJBQXVCYixZQUFZaUIsaUJBQWlCQyxnQkFBZ0JWLGlCQUFpQlIsY0FBY25DLGdFQUFZQSxDQUFDO0lBQ3RJLElBQUlzQyxJQUFJLENBQUNnQixXQUFXRyxJQUFJLEdBQUdELGNBQWNsQixDQUFDLElBQUlpQixNQUFNakIsQ0FBQztJQUNyRCxJQUFJQyxJQUFJLENBQUNlLFdBQVdJLEdBQUcsR0FBR0YsY0FBY2pCLENBQUMsSUFBSWdCLE1BQU1oQixDQUFDO0lBQ3BELElBQUlmLFFBQVE4QixXQUFXOUIsS0FBSyxHQUFHK0IsTUFBTWpCLENBQUM7SUFDdEMsSUFBSVosU0FBUzRCLFdBQVc1QixNQUFNLEdBQUc2QixNQUFNaEIsQ0FBQztJQUN4QyxJQUFJSixZQUFZO1FBQ2QsTUFBTVMsTUFBTXJDLGlFQUFTQSxDQUFDNEI7UUFDdEIsTUFBTXdCLFlBQVlOLGdCQUFnQi9DLGlFQUFTQSxDQUFDK0MsZ0JBQWdCOUMsaUVBQVNBLENBQUM4QyxnQkFBZ0JBO1FBQ3RGLElBQUlPLGFBQWFoQjtRQUNqQixJQUFJaUIsZ0JBQWdCcEQsdUVBQWVBLENBQUNtRDtRQUNwQyxNQUFPQyxpQkFBaUJSLGdCQUFnQk0sY0FBY0MsV0FBWTtZQUNoRSxNQUFNRSxjQUFjNUIsU0FBUzJCO1lBQzdCLE1BQU1FLGFBQWFGLGNBQWN4QixxQkFBcUI7WUFDdEQsTUFBTWQsTUFBTW5CLHdFQUFnQkEsQ0FBQ3lEO1lBQzdCLE1BQU1KLE9BQU9NLFdBQVdOLElBQUksR0FBRyxDQUFDSSxjQUFjRyxVQUFVLEdBQUd2QyxXQUFXRixJQUFJMEMsV0FBVyxLQUFLSCxZQUFZeEIsQ0FBQztZQUN2RyxNQUFNb0IsTUFBTUssV0FBV0wsR0FBRyxHQUFHLENBQUNHLGNBQWNLLFNBQVMsR0FBR3pDLFdBQVdGLElBQUk0QyxVQUFVLEtBQUtMLFlBQVl2QixDQUFDO1lBQ25HRCxLQUFLd0IsWUFBWXhCLENBQUM7WUFDbEJDLEtBQUt1QixZQUFZdkIsQ0FBQztZQUNsQmYsU0FBU3NDLFlBQVl4QixDQUFDO1lBQ3RCWixVQUFVb0MsWUFBWXZCLENBQUM7WUFDdkJELEtBQUttQjtZQUNMbEIsS0FBS21CO1lBQ0xFLGFBQWFyRCxpRUFBU0EsQ0FBQ3NEO1lBQ3ZCQSxnQkFBZ0JwRCx1RUFBZUEsQ0FBQ21EO1FBQ2xDO0lBQ0Y7SUFDQSxPQUFPcEYsb0VBQWdCQSxDQUFDO1FBQ3RCZ0Q7UUFDQUU7UUFDQVk7UUFDQUM7SUFDRjtBQUNGO0FBRUEseUVBQXlFO0FBQ3pFLHFCQUFxQjtBQUNyQixTQUFTNkIsb0JBQW9COUMsT0FBTyxFQUFFYyxJQUFJO0lBQ3hDLE1BQU1pQyxhQUFhM0QscUVBQWFBLENBQUNZLFNBQVNnRCxVQUFVO0lBQ3BELElBQUksQ0FBQ2xDLE1BQU07UUFDVCxPQUFPQyxzQkFBc0IxQiwwRUFBa0JBLENBQUNXLFVBQVVtQyxJQUFJLEdBQUdZO0lBQ25FO0lBQ0EsT0FBT2pDLEtBQUtxQixJQUFJLEdBQUdZO0FBQ3JCO0FBRUEsU0FBU0UsY0FBY0MsZUFBZSxFQUFFQyxNQUFNLEVBQUVDLGdCQUFnQjtJQUM5RCxJQUFJQSxxQkFBcUIsS0FBSyxHQUFHO1FBQy9CQSxtQkFBbUI7SUFDckI7SUFDQSxNQUFNQyxXQUFXSCxnQkFBZ0JuQyxxQkFBcUI7SUFDdEQsTUFBTUMsSUFBSXFDLFNBQVNsQixJQUFJLEdBQUdnQixPQUFPSCxVQUFVLEdBQUlJLENBQUFBLG1CQUFtQixJQUNsRSx3QkFBd0I7SUFDeEJOLG9CQUFvQkksaUJBQWlCRyxTQUFRO0lBQzdDLE1BQU1wQyxJQUFJb0MsU0FBU2pCLEdBQUcsR0FBR2UsT0FBT0csU0FBUztJQUN6QyxPQUFPO1FBQ0x0QztRQUNBQztJQUNGO0FBQ0Y7QUFFQSxTQUFTc0Msc0RBQXNEQyxJQUFJO0lBQ2pFLElBQUksRUFDRkMsUUFBUSxFQUNSM0MsSUFBSSxFQUNKaUIsWUFBWSxFQUNaMkIsUUFBUSxFQUNULEdBQUdGO0lBQ0osTUFBTTdCLFVBQVUrQixhQUFhO0lBQzdCLE1BQU1SLGtCQUFrQjdELDBFQUFrQkEsQ0FBQzBDO0lBQzNDLE1BQU00QixXQUFXRixXQUFXbkUsa0VBQVVBLENBQUNtRSxTQUFTRyxRQUFRLElBQUk7SUFDNUQsSUFBSTdCLGlCQUFpQm1CLG1CQUFtQlMsWUFBWWhDLFNBQVM7UUFDM0QsT0FBT2I7SUFDVDtJQUNBLElBQUlxQyxTQUFTO1FBQ1hILFlBQVk7UUFDWk0sV0FBVztJQUNiO0lBQ0EsSUFBSXJCLFFBQVF2RCxnRUFBWUEsQ0FBQztJQUN6QixNQUFNbUYsVUFBVW5GLGdFQUFZQSxDQUFDO0lBQzdCLE1BQU1vRiwwQkFBMEIvRSxxRUFBYUEsQ0FBQ2dEO0lBQzlDLElBQUkrQiwyQkFBMkIsQ0FBQ0EsMkJBQTJCLENBQUNuQyxTQUFTO1FBQ25FLElBQUlwQyxtRUFBV0EsQ0FBQ3dDLGtCQUFrQixVQUFVdkMseUVBQWlCQSxDQUFDMEQsa0JBQWtCO1lBQzlFQyxTQUFTL0QscUVBQWFBLENBQUMyQztRQUN6QjtRQUNBLElBQUloRCxxRUFBYUEsQ0FBQ2dELGVBQWU7WUFDL0IsTUFBTWdDLGFBQWFoRCxzQkFBc0JnQjtZQUN6Q0UsUUFBUXJCLFNBQVNtQjtZQUNqQjhCLFFBQVE3QyxDQUFDLEdBQUcrQyxXQUFXL0MsQ0FBQyxHQUFHZSxhQUFhVyxVQUFVO1lBQ2xEbUIsUUFBUTVDLENBQUMsR0FBRzhDLFdBQVc5QyxDQUFDLEdBQUdjLGFBQWFhLFNBQVM7UUFDbkQ7SUFDRjtJQUNBLE1BQU1vQixhQUFhZCxtQkFBbUIsQ0FBQ1ksMkJBQTJCLENBQUNuQyxVQUFVc0IsY0FBY0MsaUJBQWlCQyxRQUFRLFFBQVF6RSxnRUFBWUEsQ0FBQztJQUN6SSxPQUFPO1FBQ0x3QixPQUFPWSxLQUFLWixLQUFLLEdBQUcrQixNQUFNakIsQ0FBQztRQUMzQlosUUFBUVUsS0FBS1YsTUFBTSxHQUFHNkIsTUFBTWhCLENBQUM7UUFDN0JELEdBQUdGLEtBQUtFLENBQUMsR0FBR2lCLE1BQU1qQixDQUFDLEdBQUdtQyxPQUFPSCxVQUFVLEdBQUdmLE1BQU1qQixDQUFDLEdBQUc2QyxRQUFRN0MsQ0FBQyxHQUFHZ0QsV0FBV2hELENBQUM7UUFDNUVDLEdBQUdILEtBQUtHLENBQUMsR0FBR2dCLE1BQU1oQixDQUFDLEdBQUdrQyxPQUFPRyxTQUFTLEdBQUdyQixNQUFNaEIsQ0FBQyxHQUFHNEMsUUFBUTVDLENBQUMsR0FBRytDLFdBQVcvQyxDQUFDO0lBQzdFO0FBQ0Y7QUFFQSxTQUFTZ0QsZUFBZWpFLE9BQU87SUFDN0IsT0FBT2tFLE1BQU1DLElBQUksQ0FBQ25FLFFBQVFpRSxjQUFjO0FBQzFDO0FBRUEsK0VBQStFO0FBQy9FLHVFQUF1RTtBQUN2RSxTQUFTRyxnQkFBZ0JwRSxPQUFPO0lBQzlCLE1BQU1xRSxPQUFPaEYsMEVBQWtCQSxDQUFDVztJQUNoQyxNQUFNbUQsU0FBUy9ELHFFQUFhQSxDQUFDWTtJQUM3QixNQUFNc0UsT0FBT3RFLFFBQVF1RSxhQUFhLENBQUNELElBQUk7SUFDdkMsTUFBTXBFLFFBQVF2Qix1REFBR0EsQ0FBQzBGLEtBQUtHLFdBQVcsRUFBRUgsS0FBS0ksV0FBVyxFQUFFSCxLQUFLRSxXQUFXLEVBQUVGLEtBQUtHLFdBQVc7SUFDeEYsTUFBTXJFLFNBQVN6Qix1REFBR0EsQ0FBQzBGLEtBQUtLLFlBQVksRUFBRUwsS0FBS00sWUFBWSxFQUFFTCxLQUFLSSxZQUFZLEVBQUVKLEtBQUtLLFlBQVk7SUFDN0YsSUFBSTNELElBQUksQ0FBQ21DLE9BQU9ILFVBQVUsR0FBR0Ysb0JBQW9COUM7SUFDakQsTUFBTWlCLElBQUksQ0FBQ2tDLE9BQU9HLFNBQVM7SUFDM0IsSUFBSXhFLHdFQUFnQkEsQ0FBQ3dGLE1BQU1NLFNBQVMsS0FBSyxPQUFPO1FBQzlDNUQsS0FBS3JDLHVEQUFHQSxDQUFDMEYsS0FBS0ksV0FBVyxFQUFFSCxLQUFLRyxXQUFXLElBQUl2RTtJQUNqRDtJQUNBLE9BQU87UUFDTEE7UUFDQUU7UUFDQVk7UUFDQUM7SUFDRjtBQUNGO0FBRUEsU0FBUzRELGdCQUFnQjdFLE9BQU8sRUFBRTBELFFBQVE7SUFDeEMsTUFBTXBDLE1BQU1yQyxpRUFBU0EsQ0FBQ2U7SUFDdEIsTUFBTXFFLE9BQU9oRiwwRUFBa0JBLENBQUNXO0lBQ2hDLE1BQU11QixpQkFBaUJELElBQUlDLGNBQWM7SUFDekMsSUFBSXJCLFFBQVFtRSxLQUFLSSxXQUFXO0lBQzVCLElBQUlyRSxTQUFTaUUsS0FBS00sWUFBWTtJQUM5QixJQUFJM0QsSUFBSTtJQUNSLElBQUlDLElBQUk7SUFDUixJQUFJTSxnQkFBZ0I7UUFDbEJyQixRQUFRcUIsZUFBZXJCLEtBQUs7UUFDNUJFLFNBQVNtQixlQUFlbkIsTUFBTTtRQUM5QixNQUFNMEUsc0JBQXNCNUYsZ0VBQVFBO1FBQ3BDLElBQUksQ0FBQzRGLHVCQUF1QkEsdUJBQXVCcEIsYUFBYSxTQUFTO1lBQ3ZFMUMsSUFBSU8sZUFBZUMsVUFBVTtZQUM3QlAsSUFBSU0sZUFBZUUsU0FBUztRQUM5QjtJQUNGO0lBQ0EsT0FBTztRQUNMdkI7UUFDQUU7UUFDQVk7UUFDQUM7SUFDRjtBQUNGO0FBRUEsb0VBQW9FO0FBQ3BFLFNBQVM4RCwyQkFBMkIvRSxPQUFPLEVBQUUwRCxRQUFRO0lBQ25ELE1BQU0xQixhQUFhakIsc0JBQXNCZixTQUFTLE1BQU0wRCxhQUFhO0lBQ3JFLE1BQU10QixNQUFNSixXQUFXSSxHQUFHLEdBQUdwQyxRQUFRNEMsU0FBUztJQUM5QyxNQUFNVCxPQUFPSCxXQUFXRyxJQUFJLEdBQUduQyxRQUFRMEMsVUFBVTtJQUNqRCxNQUFNVCxRQUFRbEQscUVBQWFBLENBQUNpQixXQUFXWSxTQUFTWixXQUFXdEIsZ0VBQVlBLENBQUM7SUFDeEUsTUFBTXdCLFFBQVFGLFFBQVF5RSxXQUFXLEdBQUd4QyxNQUFNakIsQ0FBQztJQUMzQyxNQUFNWixTQUFTSixRQUFRMkUsWUFBWSxHQUFHMUMsTUFBTWhCLENBQUM7SUFDN0MsTUFBTUQsSUFBSW1CLE9BQU9GLE1BQU1qQixDQUFDO0lBQ3hCLE1BQU1DLElBQUltQixNQUFNSCxNQUFNaEIsQ0FBQztJQUN2QixPQUFPO1FBQ0xmO1FBQ0FFO1FBQ0FZO1FBQ0FDO0lBQ0Y7QUFDRjtBQUNBLFNBQVMrRCxrQ0FBa0NoRixPQUFPLEVBQUVpRixnQkFBZ0IsRUFBRXZCLFFBQVE7SUFDNUUsSUFBSTVDO0lBQ0osSUFBSW1FLHFCQUFxQixZQUFZO1FBQ25DbkUsT0FBTytELGdCQUFnQjdFLFNBQVMwRDtJQUNsQyxPQUFPLElBQUl1QixxQkFBcUIsWUFBWTtRQUMxQ25FLE9BQU9zRCxnQkFBZ0IvRSwwRUFBa0JBLENBQUNXO0lBQzVDLE9BQU8sSUFBSWhCLGlFQUFTQSxDQUFDaUcsbUJBQW1CO1FBQ3RDbkUsT0FBT2lFLDJCQUEyQkUsa0JBQWtCdkI7SUFDdEQsT0FBTztRQUNMLE1BQU14QixnQkFBZ0JiLGlCQUFpQnJCO1FBQ3ZDYyxPQUFPO1lBQ0xFLEdBQUdpRSxpQkFBaUJqRSxDQUFDLEdBQUdrQixjQUFjbEIsQ0FBQztZQUN2Q0MsR0FBR2dFLGlCQUFpQmhFLENBQUMsR0FBR2lCLGNBQWNqQixDQUFDO1lBQ3ZDZixPQUFPK0UsaUJBQWlCL0UsS0FBSztZQUM3QkUsUUFBUTZFLGlCQUFpQjdFLE1BQU07UUFDakM7SUFDRjtJQUNBLE9BQU9sRCxvRUFBZ0JBLENBQUM0RDtBQUMxQjtBQUNBLFNBQVNvRSx5QkFBeUJsRixPQUFPLEVBQUVtRixRQUFRO0lBQ2pELE1BQU1DLGFBQWExRixxRUFBYUEsQ0FBQ007SUFDakMsSUFBSW9GLGVBQWVELFlBQVksQ0FBQ25HLGlFQUFTQSxDQUFDb0csZUFBZXpGLDZFQUFxQkEsQ0FBQ3lGLGFBQWE7UUFDMUYsT0FBTztJQUNUO0lBQ0EsT0FBT3RHLHdFQUFnQkEsQ0FBQ3NHLFlBQVlDLFFBQVEsS0FBSyxXQUFXSCx5QkFBeUJFLFlBQVlEO0FBQ25HO0FBRUEsNEVBQTRFO0FBQzVFLDJFQUEyRTtBQUMzRSxvQ0FBb0M7QUFDcEMsU0FBU0csNEJBQTRCdEYsT0FBTyxFQUFFdUYsS0FBSztJQUNqRCxNQUFNQyxlQUFlRCxNQUFNRSxHQUFHLENBQUN6RjtJQUMvQixJQUFJd0YsY0FBYztRQUNoQixPQUFPQTtJQUNUO0lBQ0EsSUFBSUUsU0FBU2pHLDRFQUFvQkEsQ0FBQ08sU0FBUyxFQUFFLEVBQUUsT0FBTzJGLE1BQU0sQ0FBQ0MsQ0FBQUEsS0FBTTVHLGlFQUFTQSxDQUFDNEcsT0FBT3JHLG1FQUFXQSxDQUFDcUcsUUFBUTtJQUN4RyxJQUFJQyxzQ0FBc0M7SUFDMUMsTUFBTUMsaUJBQWlCaEgsd0VBQWdCQSxDQUFDa0IsU0FBU3FGLFFBQVEsS0FBSztJQUM5RCxJQUFJVSxjQUFjRCxpQkFBaUJwRyxxRUFBYUEsQ0FBQ00sV0FBV0E7SUFFNUQscUdBQXFHO0lBQ3JHLE1BQU9oQixpRUFBU0EsQ0FBQytHLGdCQUFnQixDQUFDcEcsNkVBQXFCQSxDQUFDb0csYUFBYztRQUNwRSxNQUFNQyxnQkFBZ0JsSCx3RUFBZ0JBLENBQUNpSDtRQUN2QyxNQUFNRSwwQkFBMEJyRyx5RUFBaUJBLENBQUNtRztRQUNsRCxJQUFJLENBQUNFLDJCQUEyQkQsY0FBY1gsUUFBUSxLQUFLLFNBQVM7WUFDbEVRLHNDQUFzQztRQUN4QztRQUNBLE1BQU1LLHdCQUF3QkosaUJBQWlCLENBQUNHLDJCQUEyQixDQUFDSixzQ0FBc0MsQ0FBQ0ksMkJBQTJCRCxjQUFjWCxRQUFRLEtBQUssWUFBWSxDQUFDLENBQUNRLHVDQUF1QztZQUFDO1lBQVk7U0FBUSxDQUFDTSxRQUFRLENBQUNOLG9DQUFvQ1IsUUFBUSxLQUFLN0YseUVBQWlCQSxDQUFDdUcsZ0JBQWdCLENBQUNFLDJCQUEyQmYseUJBQXlCbEYsU0FBUytGO1FBQzlZLElBQUlHLHVCQUF1QjtZQUN6Qiw4QkFBOEI7WUFDOUJSLFNBQVNBLE9BQU9DLE1BQU0sQ0FBQ1MsQ0FBQUEsV0FBWUEsYUFBYUw7UUFDbEQsT0FBTztZQUNMLG1EQUFtRDtZQUNuREYsc0NBQXNDRztRQUN4QztRQUNBRCxjQUFjckcscUVBQWFBLENBQUNxRztJQUM5QjtJQUNBUixNQUFNYyxHQUFHLENBQUNyRyxTQUFTMEY7SUFDbkIsT0FBT0E7QUFDVDtBQUVBLDRFQUE0RTtBQUM1RSxzQkFBc0I7QUFDdEIsU0FBU1ksZ0JBQWdCOUMsSUFBSTtJQUMzQixJQUFJLEVBQ0Z4RCxPQUFPLEVBQ1B1RyxRQUFRLEVBQ1JDLFlBQVksRUFDWjlDLFFBQVEsRUFDVCxHQUFHRjtJQUNKLE1BQU1pRCwyQkFBMkJGLGFBQWEsc0JBQXNCakgsa0VBQVVBLENBQUNVLFdBQVcsRUFBRSxHQUFHc0YsNEJBQTRCdEYsU0FBUyxJQUFJLENBQUMwRyxFQUFFLElBQUksRUFBRSxDQUFDQyxNQUFNLENBQUNKO0lBQ3pKLE1BQU1LLG9CQUFvQjtXQUFJSDtRQUEwQkQ7S0FBYTtJQUNyRSxNQUFNSyx3QkFBd0JELGlCQUFpQixDQUFDLEVBQUU7SUFDbEQsTUFBTUUsZUFBZUYsa0JBQWtCRyxNQUFNLENBQUMsQ0FBQ0MsU0FBUy9CO1FBQ3RELE1BQU1uRSxPQUFPa0Usa0NBQWtDaEYsU0FBU2lGLGtCQUFrQnZCO1FBQzFFc0QsUUFBUTVFLEdBQUcsR0FBR3pELHVEQUFHQSxDQUFDbUMsS0FBS3NCLEdBQUcsRUFBRTRFLFFBQVE1RSxHQUFHO1FBQ3ZDNEUsUUFBUUMsS0FBSyxHQUFHckksdURBQUdBLENBQUNrQyxLQUFLbUcsS0FBSyxFQUFFRCxRQUFRQyxLQUFLO1FBQzdDRCxRQUFRRSxNQUFNLEdBQUd0SSx1REFBR0EsQ0FBQ2tDLEtBQUtvRyxNQUFNLEVBQUVGLFFBQVFFLE1BQU07UUFDaERGLFFBQVE3RSxJQUFJLEdBQUd4RCx1REFBR0EsQ0FBQ21DLEtBQUtxQixJQUFJLEVBQUU2RSxRQUFRN0UsSUFBSTtRQUMxQyxPQUFPNkU7SUFDVCxHQUFHaEMsa0NBQWtDaEYsU0FBUzZHLHVCQUF1Qm5EO0lBQ3JFLE9BQU87UUFDTHhELE9BQU80RyxhQUFhRyxLQUFLLEdBQUdILGFBQWEzRSxJQUFJO1FBQzdDL0IsUUFBUTBHLGFBQWFJLE1BQU0sR0FBR0osYUFBYTFFLEdBQUc7UUFDOUNwQixHQUFHOEYsYUFBYTNFLElBQUk7UUFDcEJsQixHQUFHNkYsYUFBYTFFLEdBQUc7SUFDckI7QUFDRjtBQUVBLFNBQVMrRSxjQUFjbkgsT0FBTztJQUM1QixNQUFNLEVBQ0pFLEtBQUssRUFDTEUsTUFBTSxFQUNQLEdBQUdMLGlCQUFpQkM7SUFDckIsT0FBTztRQUNMRTtRQUNBRTtJQUNGO0FBQ0Y7QUFFQSxTQUFTZ0gsOEJBQThCcEgsT0FBTyxFQUFFK0IsWUFBWSxFQUFFMkIsUUFBUTtJQUNwRSxNQUFNSSwwQkFBMEIvRSxxRUFBYUEsQ0FBQ2dEO0lBQzlDLE1BQU1tQixrQkFBa0I3RCwwRUFBa0JBLENBQUMwQztJQUMzQyxNQUFNSixVQUFVK0IsYUFBYTtJQUM3QixNQUFNNUMsT0FBT0Msc0JBQXNCZixTQUFTLE1BQU0yQixTQUFTSTtJQUMzRCxJQUFJb0IsU0FBUztRQUNYSCxZQUFZO1FBQ1pNLFdBQVc7SUFDYjtJQUNBLE1BQU1PLFVBQVVuRixnRUFBWUEsQ0FBQztJQUM3QixJQUFJb0YsMkJBQTJCLENBQUNBLDJCQUEyQixDQUFDbkMsU0FBUztRQUNuRSxJQUFJcEMsbUVBQVdBLENBQUN3QyxrQkFBa0IsVUFBVXZDLHlFQUFpQkEsQ0FBQzBELGtCQUFrQjtZQUM5RUMsU0FBUy9ELHFFQUFhQSxDQUFDMkM7UUFDekI7UUFDQSxJQUFJK0IseUJBQXlCO1lBQzNCLE1BQU1DLGFBQWFoRCxzQkFBc0JnQixjQUFjLE1BQU1KLFNBQVNJO1lBQ3RFOEIsUUFBUTdDLENBQUMsR0FBRytDLFdBQVcvQyxDQUFDLEdBQUdlLGFBQWFXLFVBQVU7WUFDbERtQixRQUFRNUMsQ0FBQyxHQUFHOEMsV0FBVzlDLENBQUMsR0FBR2MsYUFBYWEsU0FBUztRQUNuRCxPQUFPLElBQUlNLGlCQUFpQjtZQUMxQixzRUFBc0U7WUFDdEUsdUVBQXVFO1lBQ3ZFVyxRQUFRN0MsQ0FBQyxHQUFHOEIsb0JBQW9CSTtRQUNsQztJQUNGO0lBQ0EsTUFBTWMsYUFBYWQsbUJBQW1CLENBQUNZLDJCQUEyQixDQUFDbkMsVUFBVXNCLGNBQWNDLGlCQUFpQkMsVUFBVXpFLGdFQUFZQSxDQUFDO0lBQ25JLE1BQU1zQyxJQUFJRixLQUFLcUIsSUFBSSxHQUFHZ0IsT0FBT0gsVUFBVSxHQUFHYSxRQUFRN0MsQ0FBQyxHQUFHZ0QsV0FBV2hELENBQUM7SUFDbEUsTUFBTUMsSUFBSUgsS0FBS3NCLEdBQUcsR0FBR2UsT0FBT0csU0FBUyxHQUFHTyxRQUFRNUMsQ0FBQyxHQUFHK0MsV0FBVy9DLENBQUM7SUFDaEUsT0FBTztRQUNMRDtRQUNBQztRQUNBZixPQUFPWSxLQUFLWixLQUFLO1FBQ2pCRSxRQUFRVSxLQUFLVixNQUFNO0lBQ3JCO0FBQ0Y7QUFFQSxTQUFTaUgsbUJBQW1CckgsT0FBTztJQUNqQyxPQUFPbEIsd0VBQWdCQSxDQUFDa0IsU0FBU3FGLFFBQVEsS0FBSztBQUNoRDtBQUVBLFNBQVNpQyxvQkFBb0J0SCxPQUFPLEVBQUV1SCxRQUFRO0lBQzVDLElBQUksQ0FBQ3hJLHFFQUFhQSxDQUFDaUIsWUFBWWxCLHdFQUFnQkEsQ0FBQ2tCLFNBQVNxRixRQUFRLEtBQUssU0FBUztRQUM3RSxPQUFPO0lBQ1Q7SUFDQSxJQUFJa0MsVUFBVTtRQUNaLE9BQU9BLFNBQVN2SDtJQUNsQjtJQUNBLElBQUl3SCxrQkFBa0J4SCxRQUFRK0IsWUFBWTtJQUUxQyw2RUFBNkU7SUFDN0UsNkVBQTZFO0lBQzdFLDRFQUE0RTtJQUM1RSxjQUFjO0lBQ2QsSUFBSTFDLDBFQUFrQkEsQ0FBQ1csYUFBYXdILGlCQUFpQjtRQUNuREEsa0JBQWtCQSxnQkFBZ0JqRCxhQUFhLENBQUNELElBQUk7SUFDdEQ7SUFDQSxPQUFPa0Q7QUFDVDtBQUVBLHlFQUF5RTtBQUN6RSxrREFBa0Q7QUFDbEQsU0FBU0MsZ0JBQWdCekgsT0FBTyxFQUFFdUgsUUFBUTtJQUN4QyxNQUFNakcsTUFBTXJDLGlFQUFTQSxDQUFDZTtJQUN0QixJQUFJVixrRUFBVUEsQ0FBQ1UsVUFBVTtRQUN2QixPQUFPc0I7SUFDVDtJQUNBLElBQUksQ0FBQ3ZDLHFFQUFhQSxDQUFDaUIsVUFBVTtRQUMzQixJQUFJMEgsa0JBQWtCaEkscUVBQWFBLENBQUNNO1FBQ3BDLE1BQU8wSCxtQkFBbUIsQ0FBQy9ILDZFQUFxQkEsQ0FBQytILGlCQUFrQjtZQUNqRSxJQUFJMUksaUVBQVNBLENBQUMwSSxvQkFBb0IsQ0FBQ0wsbUJBQW1CSyxrQkFBa0I7Z0JBQ3RFLE9BQU9BO1lBQ1Q7WUFDQUEsa0JBQWtCaEkscUVBQWFBLENBQUNnSTtRQUNsQztRQUNBLE9BQU9wRztJQUNUO0lBQ0EsSUFBSVMsZUFBZXVGLG9CQUFvQnRILFNBQVN1SDtJQUNoRCxNQUFPeEYsZ0JBQWdCbEMsc0VBQWNBLENBQUNrQyxpQkFBaUJzRixtQkFBbUJ0RixjQUFlO1FBQ3ZGQSxlQUFldUYsb0JBQW9CdkYsY0FBY3dGO0lBQ25EO0lBQ0EsSUFBSXhGLGdCQUFnQnBDLDZFQUFxQkEsQ0FBQ29DLGlCQUFpQnNGLG1CQUFtQnRGLGlCQUFpQixDQUFDbkMseUVBQWlCQSxDQUFDbUMsZUFBZTtRQUMvSCxPQUFPVDtJQUNUO0lBQ0EsT0FBT1MsZ0JBQWdCakMsMEVBQWtCQSxDQUFDRSxZQUFZc0I7QUFDeEQ7QUFFQSxNQUFNcUcsa0JBQWtCLGVBQWdCQyxJQUFJO0lBQzFDLE1BQU1DLG9CQUFvQixJQUFJLENBQUNKLGVBQWUsSUFBSUE7SUFDbEQsTUFBTUssa0JBQWtCLElBQUksQ0FBQ1gsYUFBYTtJQUMxQyxNQUFNWSxxQkFBcUIsTUFBTUQsZ0JBQWdCRixLQUFLaEUsUUFBUTtJQUM5RCxPQUFPO1FBQ0xvRSxXQUFXWiw4QkFBOEJRLEtBQUtJLFNBQVMsRUFBRSxNQUFNSCxrQkFBa0JELEtBQUtoRSxRQUFRLEdBQUdnRSxLQUFLbEUsUUFBUTtRQUM5R0UsVUFBVTtZQUNSNUMsR0FBRztZQUNIQyxHQUFHO1lBQ0hmLE9BQU82SCxtQkFBbUI3SCxLQUFLO1lBQy9CRSxRQUFRMkgsbUJBQW1CM0gsTUFBTTtRQUNuQztJQUNGO0FBQ0Y7QUFFQSxTQUFTNkgsTUFBTWpJLE9BQU87SUFDcEIsT0FBT2xCLHdFQUFnQkEsQ0FBQ2tCLFNBQVM0RSxTQUFTLEtBQUs7QUFDakQ7QUFFQSxNQUFNc0QsV0FBVztJQUNmM0U7SUFDQWxFLGtCQUFrQkEsd0VBQUFBO0lBQ2xCaUg7SUFDQW1CO0lBQ0FFO0lBQ0ExRDtJQUNBa0Q7SUFDQXZHO0lBQ0E1QixTQUFTQSwrREFBQUE7SUFDVGlKO0FBQ0Y7QUFFQSx5Q0FBeUM7QUFDekMsU0FBU0UsWUFBWW5JLE9BQU8sRUFBRW9JLE1BQU07SUFDbEMsSUFBSUMsS0FBSztJQUNULElBQUlDO0lBQ0osTUFBTUMsT0FBT2xKLDBFQUFrQkEsQ0FBQ1c7SUFDaEMsU0FBU3dJO1FBQ1AsSUFBSUM7UUFDSkMsYUFBYUo7UUFDWkcsQ0FBQUEsTUFBTUosRUFBQyxLQUFNLFFBQVFJLElBQUlFLFVBQVU7UUFDcENOLEtBQUs7SUFDUDtJQUNBLFNBQVNPLFFBQVFDLElBQUksRUFBRUMsU0FBUztRQUM5QixJQUFJRCxTQUFTLEtBQUssR0FBRztZQUNuQkEsT0FBTztRQUNUO1FBQ0EsSUFBSUMsY0FBYyxLQUFLLEdBQUc7WUFDeEJBLFlBQVk7UUFDZDtRQUNBTjtRQUNBLE1BQU0sRUFDSnJHLElBQUksRUFDSkMsR0FBRyxFQUNIbEMsS0FBSyxFQUNMRSxNQUFNLEVBQ1AsR0FBR0osUUFBUWUscUJBQXFCO1FBQ2pDLElBQUksQ0FBQzhILE1BQU07WUFDVFQ7UUFDRjtRQUNBLElBQUksQ0FBQ2xJLFNBQVMsQ0FBQ0UsUUFBUTtZQUNyQjtRQUNGO1FBQ0EsTUFBTTJJLFdBQVdsSyx5REFBS0EsQ0FBQ3VEO1FBQ3ZCLE1BQU00RyxhQUFhbksseURBQUtBLENBQUMwSixLQUFLOUQsV0FBVyxHQUFJdEMsQ0FBQUEsT0FBT2pDLEtBQUk7UUFDeEQsTUFBTStJLGNBQWNwSyx5REFBS0EsQ0FBQzBKLEtBQUs1RCxZQUFZLEdBQUl2QyxDQUFBQSxNQUFNaEMsTUFBSztRQUMxRCxNQUFNOEksWUFBWXJLLHlEQUFLQSxDQUFDc0Q7UUFDeEIsTUFBTWdILGFBQWEsQ0FBQ0osV0FBVyxRQUFRLENBQUNDLGFBQWEsUUFBUSxDQUFDQyxjQUFjLFFBQVEsQ0FBQ0MsWUFBWTtRQUNqRyxNQUFNRSxVQUFVO1lBQ2REO1lBQ0FMLFdBQVduSyx1REFBR0EsQ0FBQyxHQUFHQyx1REFBR0EsQ0FBQyxHQUFHa0ssZUFBZTtRQUMxQztRQUNBLElBQUlPLGdCQUFnQjtRQUNwQixTQUFTQyxjQUFjQyxPQUFPO1lBQzVCLE1BQU1DLFFBQVFELE9BQU8sQ0FBQyxFQUFFLENBQUNFLGlCQUFpQjtZQUMxQyxJQUFJRCxVQUFVVixXQUFXO2dCQUN2QixJQUFJLENBQUNPLGVBQWU7b0JBQ2xCLE9BQU9UO2dCQUNUO2dCQUNBLElBQUksQ0FBQ1ksT0FBTztvQkFDVixvRUFBb0U7b0JBQ3BFLDBDQUEwQztvQkFDMUNsQixZQUFZb0IsV0FBVzt3QkFDckJkLFFBQVEsT0FBTztvQkFDakIsR0FBRztnQkFDTCxPQUFPO29CQUNMQSxRQUFRLE9BQU9ZO2dCQUNqQjtZQUNGO1lBQ0FILGdCQUFnQjtRQUNsQjtRQUVBLDBFQUEwRTtRQUMxRSxTQUFTO1FBQ1QsSUFBSTtZQUNGaEIsS0FBSyxJQUFJc0IscUJBQXFCTCxlQUFlO2dCQUMzQyxHQUFHRixPQUFPO2dCQUNWLG1CQUFtQjtnQkFDbkJiLE1BQU1BLEtBQUtoRSxhQUFhO1lBQzFCO1FBQ0YsRUFBRSxPQUFPcUYsR0FBRztZQUNWdkIsS0FBSyxJQUFJc0IscUJBQXFCTCxlQUFlRjtRQUMvQztRQUNBZixHQUFHd0IsT0FBTyxDQUFDN0o7SUFDYjtJQUNBNEksUUFBUTtJQUNSLE9BQU9KO0FBQ1Q7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU3NCLFdBQVc5QixTQUFTLEVBQUVwRSxRQUFRLEVBQUVtRyxNQUFNLEVBQUVYLE9BQU87SUFDdEQsSUFBSUEsWUFBWSxLQUFLLEdBQUc7UUFDdEJBLFVBQVUsQ0FBQztJQUNiO0lBQ0EsTUFBTSxFQUNKWSxpQkFBaUIsSUFBSSxFQUNyQkMsaUJBQWlCLElBQUksRUFDckJDLGdCQUFnQixPQUFPQyxtQkFBbUIsVUFBVSxFQUNwREMsY0FBYyxPQUFPVCx5QkFBeUIsVUFBVSxFQUN4RFUsaUJBQWlCLEtBQUssRUFDdkIsR0FBR2pCO0lBQ0osTUFBTWtCLGNBQWM1SixjQUFjc0g7SUFDbEMsTUFBTXVDLFlBQVlQLGtCQUFrQkMsaUJBQWlCO1dBQUtLLGNBQWM3Syw0RUFBb0JBLENBQUM2SyxlQUFlLEVBQUU7V0FBTTdLLDRFQUFvQkEsQ0FBQ21FO0tBQVUsR0FBRyxFQUFFO0lBQ3hKMkcsVUFBVUMsT0FBTyxDQUFDcEUsQ0FBQUE7UUFDaEI0RCxrQkFBa0I1RCxTQUFTcUUsZ0JBQWdCLENBQUMsVUFBVVYsUUFBUTtZQUM1RFcsU0FBUztRQUNYO1FBQ0FULGtCQUFrQjdELFNBQVNxRSxnQkFBZ0IsQ0FBQyxVQUFVVjtJQUN4RDtJQUNBLE1BQU1ZLFlBQVlMLGVBQWVGLGNBQWNqQyxZQUFZbUMsYUFBYVAsVUFBVTtJQUNsRixJQUFJYSxpQkFBaUIsQ0FBQztJQUN0QixJQUFJQyxpQkFBaUI7SUFDckIsSUFBSVgsZUFBZTtRQUNqQlcsaUJBQWlCLElBQUlWLGVBQWUzRyxDQUFBQTtZQUNsQyxJQUFJLENBQUNzSCxXQUFXLEdBQUd0SDtZQUNuQixJQUFJc0gsY0FBY0EsV0FBV0MsTUFBTSxLQUFLVCxlQUFlTyxnQkFBZ0I7Z0JBQ3JFLHlEQUF5RDtnQkFDekQseURBQXlEO2dCQUN6REEsZUFBZUcsU0FBUyxDQUFDcEg7Z0JBQ3pCcUgscUJBQXFCTDtnQkFDckJBLGlCQUFpQk0sc0JBQXNCO29CQUNyQyxJQUFJQztvQkFDSEEsQ0FBQUEsa0JBQWtCTixjQUFhLEtBQU0sUUFBUU0sZ0JBQWdCdEIsT0FBTyxDQUFDakc7Z0JBQ3hFO1lBQ0Y7WUFDQW1HO1FBQ0Y7UUFDQSxJQUFJTyxlQUFlLENBQUNELGdCQUFnQjtZQUNsQ1EsZUFBZWhCLE9BQU8sQ0FBQ1M7UUFDekI7UUFDQU8sZUFBZWhCLE9BQU8sQ0FBQ2pHO0lBQ3pCO0lBQ0EsSUFBSXdIO0lBQ0osSUFBSUMsY0FBY2hCLGlCQUFpQnRKLHNCQUFzQmlILGFBQWE7SUFDdEUsSUFBSXFDLGdCQUFnQjtRQUNsQmlCO0lBQ0Y7SUFDQSxTQUFTQTtRQUNQLE1BQU1DLGNBQWN4SyxzQkFBc0JpSDtRQUMxQyxJQUFJcUQsZUFBZ0JFLENBQUFBLFlBQVl2SyxDQUFDLEtBQUtxSyxZQUFZckssQ0FBQyxJQUFJdUssWUFBWXRLLENBQUMsS0FBS29LLFlBQVlwSyxDQUFDLElBQUlzSyxZQUFZckwsS0FBSyxLQUFLbUwsWUFBWW5MLEtBQUssSUFBSXFMLFlBQVluTCxNQUFNLEtBQUtpTCxZQUFZakwsTUFBTSxHQUFHO1lBQy9LMko7UUFDRjtRQUNBc0IsY0FBY0U7UUFDZEgsVUFBVUYsc0JBQXNCSTtJQUNsQztJQUNBdkI7SUFDQSxPQUFPO1FBQ0wsSUFBSXlCO1FBQ0pqQixVQUFVQyxPQUFPLENBQUNwRSxDQUFBQTtZQUNoQjRELGtCQUFrQjVELFNBQVNxRixtQkFBbUIsQ0FBQyxVQUFVMUI7WUFDekRFLGtCQUFrQjdELFNBQVNxRixtQkFBbUIsQ0FBQyxVQUFVMUI7UUFDM0Q7UUFDQVksYUFBYSxRQUFRQTtRQUNwQmEsQ0FBQUEsbUJBQW1CWCxjQUFhLEtBQU0sUUFBUVcsaUJBQWlCN0MsVUFBVTtRQUMxRWtDLGlCQUFpQjtRQUNqQixJQUFJUixnQkFBZ0I7WUFDbEJZLHFCQUFxQkc7UUFDdkI7SUFDRjtBQUNGO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNELE1BQU1qTyxpQkFBaUJDLDZEQUFnQkE7QUFFdkM7Ozs7OztDQU1DLEdBQ0QsTUFBTUMsU0FBU0MscURBQVFBO0FBRXZCOzs7OztDQUtDLEdBQ0QsTUFBTUMsZ0JBQWdCQyw0REFBZUE7QUFFckM7Ozs7Q0FJQyxHQUNELE1BQU1DLFFBQVFDLG9EQUFPQTtBQUVyQjs7Ozs7Q0FLQyxHQUNELE1BQU1DLE9BQU9DLG1EQUFNQTtBQUVuQjs7Ozs7Q0FLQyxHQUNELE1BQU1DLE9BQU9DLG1EQUFNQTtBQUVuQjs7OztDQUlDLEdBQ0QsTUFBTUMsT0FBT0MsbURBQU1BO0FBRW5COzs7O0NBSUMsR0FDRCxNQUFNQyxRQUFRQyxvREFBT0E7QUFFckI7Ozs7Q0FJQyxHQUNELE1BQU1DLFNBQVNDLHFEQUFRQTtBQUV2Qjs7Q0FFQyxHQUNELE1BQU1DLGFBQWFDLHlEQUFZQTtBQUUvQjs7O0NBR0MsR0FDRCxNQUFNQyxrQkFBa0IsQ0FBQ3lKLFdBQVdwRSxVQUFVd0Y7SUFDNUMsMkVBQTJFO0lBQzNFLHdFQUF3RTtJQUN4RSw2RUFBNkU7SUFDN0UsTUFBTTdELFFBQVEsSUFBSW1HO0lBQ2xCLE1BQU1DLGdCQUFnQjtRQUNwQnpEO1FBQ0EsR0FBR2tCLE9BQU87SUFDWjtJQUNBLE1BQU13QyxvQkFBb0I7UUFDeEIsR0FBR0QsY0FBY3pELFFBQVE7UUFDekJ4QixJQUFJbkI7SUFDTjtJQUNBLE9BQU8vRyxrRUFBaUJBLENBQUN3SixXQUFXcEUsVUFBVTtRQUM1QyxHQUFHK0gsYUFBYTtRQUNoQnpELFVBQVUwRDtJQUNaO0FBQ0Y7QUFFNEkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZG1pc3Npb24tdXBsaWZ0Ly4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9kb20vZGlzdC9mbG9hdGluZy11aS5kb20ubWpzPzNmYTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVjdFRvQ2xpZW50UmVjdCwgZGV0ZWN0T3ZlcmZsb3cgYXMgZGV0ZWN0T3ZlcmZsb3ckMSwgb2Zmc2V0IGFzIG9mZnNldCQxLCBhdXRvUGxhY2VtZW50IGFzIGF1dG9QbGFjZW1lbnQkMSwgc2hpZnQgYXMgc2hpZnQkMSwgZmxpcCBhcyBmbGlwJDEsIHNpemUgYXMgc2l6ZSQxLCBoaWRlIGFzIGhpZGUkMSwgYXJyb3cgYXMgYXJyb3ckMSwgaW5saW5lIGFzIGlubGluZSQxLCBsaW1pdFNoaWZ0IGFzIGxpbWl0U2hpZnQkMSwgY29tcHV0ZVBvc2l0aW9uIGFzIGNvbXB1dGVQb3NpdGlvbiQxIH0gZnJvbSAnQGZsb2F0aW5nLXVpL2NvcmUnO1xuaW1wb3J0IHsgcm91bmQsIGNyZWF0ZUNvb3JkcywgbWF4LCBtaW4sIGZsb29yIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzJztcbmltcG9ydCB7IGdldENvbXB1dGVkU3R5bGUsIGlzSFRNTEVsZW1lbnQsIGlzRWxlbWVudCwgZ2V0V2luZG93LCBpc1dlYktpdCwgZ2V0RnJhbWVFbGVtZW50LCBnZXROb2RlU2Nyb2xsLCBnZXREb2N1bWVudEVsZW1lbnQsIGlzVG9wTGF5ZXIsIGdldE5vZGVOYW1lLCBpc092ZXJmbG93RWxlbWVudCwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMsIGdldFBhcmVudE5vZGUsIGlzTGFzdFRyYXZlcnNhYmxlTm9kZSwgaXNDb250YWluaW5nQmxvY2ssIGlzVGFibGVFbGVtZW50LCBnZXRDb250YWluaW5nQmxvY2sgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMvZG9tJztcbmV4cG9ydCB7IGdldE92ZXJmbG93QW5jZXN0b3JzIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzL2RvbSc7XG5cbmZ1bmN0aW9uIGdldENzc0RpbWVuc2lvbnMoZWxlbWVudCkge1xuICBjb25zdCBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAvLyBJbiB0ZXN0aW5nIGVudmlyb25tZW50cywgdGhlIGB3aWR0aGAgYW5kIGBoZWlnaHRgIHByb3BlcnRpZXMgYXJlIGVtcHR5XG4gIC8vIHN0cmluZ3MgZm9yIFNWRyBlbGVtZW50cywgcmV0dXJuaW5nIE5hTi4gRmFsbGJhY2sgdG8gYDBgIGluIHRoaXMgY2FzZS5cbiAgbGV0IHdpZHRoID0gcGFyc2VGbG9hdChjc3Mud2lkdGgpIHx8IDA7XG4gIGxldCBoZWlnaHQgPSBwYXJzZUZsb2F0KGNzcy5oZWlnaHQpIHx8IDA7XG4gIGNvbnN0IGhhc09mZnNldCA9IGlzSFRNTEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IG9mZnNldFdpZHRoID0gaGFzT2Zmc2V0ID8gZWxlbWVudC5vZmZzZXRXaWR0aCA6IHdpZHRoO1xuICBjb25zdCBvZmZzZXRIZWlnaHQgPSBoYXNPZmZzZXQgPyBlbGVtZW50Lm9mZnNldEhlaWdodCA6IGhlaWdodDtcbiAgY29uc3Qgc2hvdWxkRmFsbGJhY2sgPSByb3VuZCh3aWR0aCkgIT09IG9mZnNldFdpZHRoIHx8IHJvdW5kKGhlaWdodCkgIT09IG9mZnNldEhlaWdodDtcbiAgaWYgKHNob3VsZEZhbGxiYWNrKSB7XG4gICAgd2lkdGggPSBvZmZzZXRXaWR0aDtcbiAgICBoZWlnaHQgPSBvZmZzZXRIZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgJDogc2hvdWxkRmFsbGJhY2tcbiAgfTtcbn1cblxuZnVuY3Rpb24gdW53cmFwRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiAhaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudC5jb250ZXh0RWxlbWVudCA6IGVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGdldFNjYWxlKGVsZW1lbnQpIHtcbiAgY29uc3QgZG9tRWxlbWVudCA9IHVud3JhcEVsZW1lbnQoZWxlbWVudCk7XG4gIGlmICghaXNIVE1MRWxlbWVudChkb21FbGVtZW50KSkge1xuICAgIHJldHVybiBjcmVhdGVDb29yZHMoMSk7XG4gIH1cbiAgY29uc3QgcmVjdCA9IGRvbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgJFxuICB9ID0gZ2V0Q3NzRGltZW5zaW9ucyhkb21FbGVtZW50KTtcbiAgbGV0IHggPSAoJCA/IHJvdW5kKHJlY3Qud2lkdGgpIDogcmVjdC53aWR0aCkgLyB3aWR0aDtcbiAgbGV0IHkgPSAoJCA/IHJvdW5kKHJlY3QuaGVpZ2h0KSA6IHJlY3QuaGVpZ2h0KSAvIGhlaWdodDtcblxuICAvLyAwLCBOYU4sIG9yIEluZmluaXR5IHNob3VsZCBhbHdheXMgZmFsbGJhY2sgdG8gMS5cblxuICBpZiAoIXggfHwgIU51bWJlci5pc0Zpbml0ZSh4KSkge1xuICAgIHggPSAxO1xuICB9XG4gIGlmICgheSB8fCAhTnVtYmVyLmlzRmluaXRlKHkpKSB7XG4gICAgeSA9IDE7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuY29uc3Qgbm9PZmZzZXRzID0gLyojX19QVVJFX18qL2NyZWF0ZUNvb3JkcygwKTtcbmZ1bmN0aW9uIGdldFZpc3VhbE9mZnNldHMoZWxlbWVudCkge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGlmICghaXNXZWJLaXQoKSB8fCAhd2luLnZpc3VhbFZpZXdwb3J0KSB7XG4gICAgcmV0dXJuIG5vT2Zmc2V0cztcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IHdpbi52aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0LFxuICAgIHk6IHdpbi52aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3BcbiAgfTtcbn1cbmZ1bmN0aW9uIHNob3VsZEFkZFZpc3VhbE9mZnNldHMoZWxlbWVudCwgaXNGaXhlZCwgZmxvYXRpbmdPZmZzZXRQYXJlbnQpIHtcbiAgaWYgKGlzRml4ZWQgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWQgPSBmYWxzZTtcbiAgfVxuICBpZiAoIWZsb2F0aW5nT2Zmc2V0UGFyZW50IHx8IGlzRml4ZWQgJiYgZmxvYXRpbmdPZmZzZXRQYXJlbnQgIT09IGdldFdpbmRvdyhlbGVtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNGaXhlZDtcbn1cblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGluY2x1ZGVTY2FsZSwgaXNGaXhlZFN0cmF0ZWd5LCBvZmZzZXRQYXJlbnQpIHtcbiAgaWYgKGluY2x1ZGVTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzRml4ZWRTdHJhdGVneSA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZFN0cmF0ZWd5ID0gZmFsc2U7XG4gIH1cbiAgY29uc3QgY2xpZW50UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGRvbUVsZW1lbnQgPSB1bndyYXBFbGVtZW50KGVsZW1lbnQpO1xuICBsZXQgc2NhbGUgPSBjcmVhdGVDb29yZHMoMSk7XG4gIGlmIChpbmNsdWRlU2NhbGUpIHtcbiAgICBpZiAob2Zmc2V0UGFyZW50KSB7XG4gICAgICBpZiAoaXNFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgICAgc2NhbGUgPSBnZXRTY2FsZShvZmZzZXRQYXJlbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzY2FsZSA9IGdldFNjYWxlKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICBjb25zdCB2aXN1YWxPZmZzZXRzID0gc2hvdWxkQWRkVmlzdWFsT2Zmc2V0cyhkb21FbGVtZW50LCBpc0ZpeGVkU3RyYXRlZ3ksIG9mZnNldFBhcmVudCkgPyBnZXRWaXN1YWxPZmZzZXRzKGRvbUVsZW1lbnQpIDogY3JlYXRlQ29vcmRzKDApO1xuICBsZXQgeCA9IChjbGllbnRSZWN0LmxlZnQgKyB2aXN1YWxPZmZzZXRzLngpIC8gc2NhbGUueDtcbiAgbGV0IHkgPSAoY2xpZW50UmVjdC50b3AgKyB2aXN1YWxPZmZzZXRzLnkpIC8gc2NhbGUueTtcbiAgbGV0IHdpZHRoID0gY2xpZW50UmVjdC53aWR0aCAvIHNjYWxlLng7XG4gIGxldCBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodCAvIHNjYWxlLnk7XG4gIGlmIChkb21FbGVtZW50KSB7XG4gICAgY29uc3Qgd2luID0gZ2V0V2luZG93KGRvbUVsZW1lbnQpO1xuICAgIGNvbnN0IG9mZnNldFdpbiA9IG9mZnNldFBhcmVudCAmJiBpc0VsZW1lbnQob2Zmc2V0UGFyZW50KSA/IGdldFdpbmRvdyhvZmZzZXRQYXJlbnQpIDogb2Zmc2V0UGFyZW50O1xuICAgIGxldCBjdXJyZW50V2luID0gd2luO1xuICAgIGxldCBjdXJyZW50SUZyYW1lID0gZ2V0RnJhbWVFbGVtZW50KGN1cnJlbnRXaW4pO1xuICAgIHdoaWxlIChjdXJyZW50SUZyYW1lICYmIG9mZnNldFBhcmVudCAmJiBvZmZzZXRXaW4gIT09IGN1cnJlbnRXaW4pIHtcbiAgICAgIGNvbnN0IGlmcmFtZVNjYWxlID0gZ2V0U2NhbGUoY3VycmVudElGcmFtZSk7XG4gICAgICBjb25zdCBpZnJhbWVSZWN0ID0gY3VycmVudElGcmFtZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IGNzcyA9IGdldENvbXB1dGVkU3R5bGUoY3VycmVudElGcmFtZSk7XG4gICAgICBjb25zdCBsZWZ0ID0gaWZyYW1lUmVjdC5sZWZ0ICsgKGN1cnJlbnRJRnJhbWUuY2xpZW50TGVmdCArIHBhcnNlRmxvYXQoY3NzLnBhZGRpbmdMZWZ0KSkgKiBpZnJhbWVTY2FsZS54O1xuICAgICAgY29uc3QgdG9wID0gaWZyYW1lUmVjdC50b3AgKyAoY3VycmVudElGcmFtZS5jbGllbnRUb3AgKyBwYXJzZUZsb2F0KGNzcy5wYWRkaW5nVG9wKSkgKiBpZnJhbWVTY2FsZS55O1xuICAgICAgeCAqPSBpZnJhbWVTY2FsZS54O1xuICAgICAgeSAqPSBpZnJhbWVTY2FsZS55O1xuICAgICAgd2lkdGggKj0gaWZyYW1lU2NhbGUueDtcbiAgICAgIGhlaWdodCAqPSBpZnJhbWVTY2FsZS55O1xuICAgICAgeCArPSBsZWZ0O1xuICAgICAgeSArPSB0b3A7XG4gICAgICBjdXJyZW50V2luID0gZ2V0V2luZG93KGN1cnJlbnRJRnJhbWUpO1xuICAgICAgY3VycmVudElGcmFtZSA9IGdldEZyYW1lRWxlbWVudChjdXJyZW50V2luKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlY3RUb0NsaWVudFJlY3Qoe1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfSk7XG59XG5cbi8vIElmIDxodG1sPiBoYXMgYSBDU1Mgd2lkdGggZ3JlYXRlciB0aGFuIHRoZSB2aWV3cG9ydCwgdGhlbiB0aGlzIHdpbGwgYmVcbi8vIGluY29ycmVjdCBmb3IgUlRMLlxuZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50LCByZWN0KSB7XG4gIGNvbnN0IGxlZnRTY3JvbGwgPSBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG4gIGlmICghcmVjdCkge1xuICAgIHJldHVybiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKS5sZWZ0ICsgbGVmdFNjcm9sbDtcbiAgfVxuICByZXR1cm4gcmVjdC5sZWZ0ICsgbGVmdFNjcm9sbDtcbn1cblxuZnVuY3Rpb24gZ2V0SFRNTE9mZnNldChkb2N1bWVudEVsZW1lbnQsIHNjcm9sbCwgaWdub3JlU2Nyb2xsYmFyWCkge1xuICBpZiAoaWdub3JlU2Nyb2xsYmFyWCA9PT0gdm9pZCAwKSB7XG4gICAgaWdub3JlU2Nyb2xsYmFyWCA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGh0bWxSZWN0ID0gZG9jdW1lbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCB4ID0gaHRtbFJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gKGlnbm9yZVNjcm9sbGJhclggPyAwIDpcbiAgLy8gUlRMIDxib2R5PiBzY3JvbGxiYXIuXG4gIGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50LCBodG1sUmVjdCkpO1xuICBjb25zdCB5ID0gaHRtbFJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcDtcbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QoX3JlZikge1xuICBsZXQge1xuICAgIGVsZW1lbnRzLFxuICAgIHJlY3QsXG4gICAgb2Zmc2V0UGFyZW50LFxuICAgIHN0cmF0ZWd5XG4gIH0gPSBfcmVmO1xuICBjb25zdCBpc0ZpeGVkID0gc3RyYXRlZ3kgPT09ICdmaXhlZCc7XG4gIGNvbnN0IGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCB0b3BMYXllciA9IGVsZW1lbnRzID8gaXNUb3BMYXllcihlbGVtZW50cy5mbG9hdGluZykgOiBmYWxzZTtcbiAgaWYgKG9mZnNldFBhcmVudCA9PT0gZG9jdW1lbnRFbGVtZW50IHx8IHRvcExheWVyICYmIGlzRml4ZWQpIHtcbiAgICByZXR1cm4gcmVjdDtcbiAgfVxuICBsZXQgc2Nyb2xsID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH07XG4gIGxldCBzY2FsZSA9IGNyZWF0ZUNvb3JkcygxKTtcbiAgY29uc3Qgb2Zmc2V0cyA9IGNyZWF0ZUNvb3JkcygwKTtcbiAgY29uc3QgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IGlzT3ZlcmZsb3dFbGVtZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG4gICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgY29uc3Qgb2Zmc2V0UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQpO1xuICAgICAgc2NhbGUgPSBnZXRTY2FsZShvZmZzZXRQYXJlbnQpO1xuICAgICAgb2Zmc2V0cy54ID0gb2Zmc2V0UmVjdC54ICsgb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgPSBvZmZzZXRSZWN0LnkgKyBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH1cbiAgfVxuICBjb25zdCBodG1sT2Zmc2V0ID0gZG9jdW1lbnRFbGVtZW50ICYmICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCA/IGdldEhUTUxPZmZzZXQoZG9jdW1lbnRFbGVtZW50LCBzY3JvbGwsIHRydWUpIDogY3JlYXRlQ29vcmRzKDApO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiByZWN0LndpZHRoICogc2NhbGUueCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0ICogc2NhbGUueSxcbiAgICB4OiByZWN0LnggKiBzY2FsZS54IC0gc2Nyb2xsLnNjcm9sbExlZnQgKiBzY2FsZS54ICsgb2Zmc2V0cy54ICsgaHRtbE9mZnNldC54LFxuICAgIHk6IHJlY3QueSAqIHNjYWxlLnkgLSBzY3JvbGwuc2Nyb2xsVG9wICogc2NhbGUueSArIG9mZnNldHMueSArIGh0bWxPZmZzZXQueVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0cyhlbGVtZW50KSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKSk7XG59XG5cbi8vIEdldHMgdGhlIGVudGlyZSBzaXplIG9mIHRoZSBzY3JvbGxhYmxlIGRvY3VtZW50IGFyZWEsIGV2ZW4gZXh0ZW5kaW5nIG91dHNpZGVcbi8vIG9mIHRoZSBgPGh0bWw+YCBhbmQgYDxib2R5PmAgcmVjdCBib3VuZHMgaWYgaG9yaXpvbnRhbGx5IHNjcm9sbGFibGUuXG5mdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICBjb25zdCBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpO1xuICBjb25zdCBib2R5ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gIGNvbnN0IHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkuc2Nyb2xsV2lkdGgsIGJvZHkuY2xpZW50V2lkdGgpO1xuICBjb25zdCBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5LnNjcm9sbEhlaWdodCwgYm9keS5jbGllbnRIZWlnaHQpO1xuICBsZXQgeCA9IC1zY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gIGNvbnN0IHkgPSAtc2Nyb2xsLnNjcm9sbFRvcDtcbiAgaWYgKGdldENvbXB1dGVkU3R5bGUoYm9keSkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHggKz0gbWF4KGh0bWwuY2xpZW50V2lkdGgsIGJvZHkuY2xpZW50V2lkdGgpIC0gd2lkdGg7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IHZpc3VhbFZpZXdwb3J0ID0gd2luLnZpc3VhbFZpZXdwb3J0O1xuICBsZXQgd2lkdGggPSBodG1sLmNsaWVudFdpZHRoO1xuICBsZXQgaGVpZ2h0ID0gaHRtbC5jbGllbnRIZWlnaHQ7XG4gIGxldCB4ID0gMDtcbiAgbGV0IHkgPSAwO1xuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDtcbiAgICBjb25zdCB2aXN1YWxWaWV3cG9ydEJhc2VkID0gaXNXZWJLaXQoKTtcbiAgICBpZiAoIXZpc3VhbFZpZXdwb3J0QmFzZWQgfHwgdmlzdWFsVmlld3BvcnRCYXNlZCAmJiBzdHJhdGVneSA9PT0gJ2ZpeGVkJykge1xuICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XG4gICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuLy8gUmV0dXJucyB0aGUgaW5uZXIgY2xpZW50IHJlY3QsIHN1YnRyYWN0aW5nIHNjcm9sbGJhcnMgaWYgcHJlc2VudC5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgdHJ1ZSwgc3RyYXRlZ3kgPT09ICdmaXhlZCcpO1xuICBjb25zdCB0b3AgPSBjbGllbnRSZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50VG9wO1xuICBjb25zdCBsZWZ0ID0gY2xpZW50UmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICBjb25zdCBzY2FsZSA9IGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgPyBnZXRTY2FsZShlbGVtZW50KSA6IGNyZWF0ZUNvb3JkcygxKTtcbiAgY29uc3Qgd2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoICogc2NhbGUueDtcbiAgY29uc3QgaGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQgKiBzY2FsZS55O1xuICBjb25zdCB4ID0gbGVmdCAqIHNjYWxlLng7XG4gIGNvbnN0IHkgPSB0b3AgKiBzY2FsZS55O1xuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSkge1xuICBsZXQgcmVjdDtcbiAgaWYgKGNsaXBwaW5nQW5jZXN0b3IgPT09ICd2aWV3cG9ydCcpIHtcbiAgICByZWN0ID0gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KTtcbiAgfSBlbHNlIGlmIChjbGlwcGluZ0FuY2VzdG9yID09PSAnZG9jdW1lbnQnKSB7XG4gICAgcmVjdCA9IGdldERvY3VtZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpO1xuICB9IGVsc2UgaWYgKGlzRWxlbWVudChjbGlwcGluZ0FuY2VzdG9yKSkge1xuICAgIHJlY3QgPSBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdmlzdWFsT2Zmc2V0cyA9IGdldFZpc3VhbE9mZnNldHMoZWxlbWVudCk7XG4gICAgcmVjdCA9IHtcbiAgICAgIHg6IGNsaXBwaW5nQW5jZXN0b3IueCAtIHZpc3VhbE9mZnNldHMueCxcbiAgICAgIHk6IGNsaXBwaW5nQW5jZXN0b3IueSAtIHZpc3VhbE9mZnNldHMueSxcbiAgICAgIHdpZHRoOiBjbGlwcGluZ0FuY2VzdG9yLndpZHRoLFxuICAgICAgaGVpZ2h0OiBjbGlwcGluZ0FuY2VzdG9yLmhlaWdodFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJlY3RUb0NsaWVudFJlY3QocmVjdCk7XG59XG5mdW5jdGlvbiBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IoZWxlbWVudCwgc3RvcE5vZGUpIHtcbiAgY29uc3QgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gIGlmIChwYXJlbnROb2RlID09PSBzdG9wTm9kZSB8fCAhaXNFbGVtZW50KHBhcmVudE5vZGUpIHx8IGlzTGFzdFRyYXZlcnNhYmxlTm9kZShwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnROb2RlKS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJyB8fCBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IocGFyZW50Tm9kZSwgc3RvcE5vZGUpO1xufVxuXG4vLyBBIFwiY2xpcHBpbmcgYW5jZXN0b3JcIiBpcyBhbiBgb3ZlcmZsb3dgIGVsZW1lbnQgd2l0aCB0aGUgY2hhcmFjdGVyaXN0aWMgb2Zcbi8vIGNsaXBwaW5nIChvciBoaWRpbmcpIGNoaWxkIGVsZW1lbnRzLiBUaGlzIHJldHVybnMgYWxsIGNsaXBwaW5nIGFuY2VzdG9yc1xuLy8gb2YgdGhlIGdpdmVuIGVsZW1lbnQgdXAgdGhlIHRyZWUuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnMoZWxlbWVudCwgY2FjaGUpIHtcbiAgY29uc3QgY2FjaGVkUmVzdWx0ID0gY2FjaGUuZ2V0KGVsZW1lbnQpO1xuICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgcmV0dXJuIGNhY2hlZFJlc3VsdDtcbiAgfVxuICBsZXQgcmVzdWx0ID0gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoZWxlbWVudCwgW10sIGZhbHNlKS5maWx0ZXIoZWwgPT4gaXNFbGVtZW50KGVsKSAmJiBnZXROb2RlTmFtZShlbCkgIT09ICdib2R5Jyk7XG4gIGxldCBjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA9IG51bGw7XG4gIGNvbnN0IGVsZW1lbnRJc0ZpeGVkID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJztcbiAgbGV0IGN1cnJlbnROb2RlID0gZWxlbWVudElzRml4ZWQgPyBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIDogZWxlbWVudDtcblxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuICB3aGlsZSAoaXNFbGVtZW50KGN1cnJlbnROb2RlKSAmJiAhaXNMYXN0VHJhdmVyc2FibGVOb2RlKGN1cnJlbnROb2RlKSkge1xuICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnROb2RlKTtcbiAgICBjb25zdCBjdXJyZW50Tm9kZUlzQ29udGFpbmluZyA9IGlzQ29udGFpbmluZ0Jsb2NrKGN1cnJlbnROb2RlKTtcbiAgICBpZiAoIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmIGNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgIGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc2hvdWxkRHJvcEN1cnJlbnROb2RlID0gZWxlbWVudElzRml4ZWQgPyAhY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgJiYgIWN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlIDogIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmIGNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09ICdzdGF0aWMnICYmICEhY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgJiYgWydhYnNvbHV0ZScsICdmaXhlZCddLmluY2x1ZGVzKGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlLnBvc2l0aW9uKSB8fCBpc092ZXJmbG93RWxlbWVudChjdXJyZW50Tm9kZSkgJiYgIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmIGhhc0ZpeGVkUG9zaXRpb25BbmNlc3RvcihlbGVtZW50LCBjdXJyZW50Tm9kZSk7XG4gICAgaWYgKHNob3VsZERyb3BDdXJyZW50Tm9kZSkge1xuICAgICAgLy8gRHJvcCBub24tY29udGFpbmluZyBibG9ja3MuXG4gICAgICByZXN1bHQgPSByZXN1bHQuZmlsdGVyKGFuY2VzdG9yID0+IGFuY2VzdG9yICE9PSBjdXJyZW50Tm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlY29yZCBsYXN0IGNvbnRhaW5pbmcgYmxvY2sgZm9yIG5leHQgaXRlcmF0aW9uLlxuICAgICAgY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgPSBjb21wdXRlZFN0eWxlO1xuICAgIH1cbiAgICBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoY3VycmVudE5vZGUpO1xuICB9XG4gIGNhY2hlLnNldChlbGVtZW50LCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBHZXRzIHRoZSBtYXhpbXVtIGFyZWEgdGhhdCB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIGluIGR1ZSB0byBhbnkgbnVtYmVyIG9mXG4vLyBjbGlwcGluZyBhbmNlc3RvcnMuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ1JlY3QoX3JlZikge1xuICBsZXQge1xuICAgIGVsZW1lbnQsXG4gICAgYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5LFxuICAgIHN0cmF0ZWd5XG4gIH0gPSBfcmVmO1xuICBjb25zdCBlbGVtZW50Q2xpcHBpbmdBbmNlc3RvcnMgPSBib3VuZGFyeSA9PT0gJ2NsaXBwaW5nQW5jZXN0b3JzJyA/IGlzVG9wTGF5ZXIoZWxlbWVudCkgPyBbXSA6IGdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9ycyhlbGVtZW50LCB0aGlzLl9jKSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIGNvbnN0IGNsaXBwaW5nQW5jZXN0b3JzID0gWy4uLmVsZW1lbnRDbGlwcGluZ0FuY2VzdG9ycywgcm9vdEJvdW5kYXJ5XTtcbiAgY29uc3QgZmlyc3RDbGlwcGluZ0FuY2VzdG9yID0gY2xpcHBpbmdBbmNlc3RvcnNbMF07XG4gIGNvbnN0IGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nQW5jZXN0b3JzLnJlZHVjZSgoYWNjUmVjdCwgY2xpcHBpbmdBbmNlc3RvcikgPT4ge1xuICAgIGNvbnN0IHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgY2xpcHBpbmdBbmNlc3Rvciwgc3RyYXRlZ3kpO1xuICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IG1pbihyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcbiAgICBhY2NSZWN0LmJvdHRvbSA9IG1pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBmaXJzdENsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KSk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0LFxuICAgIGhlaWdodDogY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3AsXG4gICAgeDogY2xpcHBpbmdSZWN0LmxlZnQsXG4gICAgeTogY2xpcHBpbmdSZWN0LnRvcFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXREaW1lbnNpb25zKGVsZW1lbnQpIHtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9ID0gZ2V0Q3NzRGltZW5zaW9ucyhlbGVtZW50KTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVjdFJlbGF0aXZlVG9PZmZzZXRQYXJlbnQoZWxlbWVudCwgb2Zmc2V0UGFyZW50LCBzdHJhdGVneSkge1xuICBjb25zdCBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IGlzRml4ZWQgPSBzdHJhdGVneSA9PT0gJ2ZpeGVkJztcbiAgY29uc3QgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCB0cnVlLCBpc0ZpeGVkLCBvZmZzZXRQYXJlbnQpO1xuICBsZXQgc2Nyb2xsID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH07XG4gIGNvbnN0IG9mZnNldHMgPSBjcmVhdGVDb29yZHMoMCk7XG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IGlzT3ZlcmZsb3dFbGVtZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG4gICAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50KSB7XG4gICAgICBjb25zdCBvZmZzZXRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCwgdHJ1ZSwgaXNGaXhlZCwgb2Zmc2V0UGFyZW50KTtcbiAgICAgIG9mZnNldHMueCA9IG9mZnNldFJlY3QueCArIG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ID0gb2Zmc2V0UmVjdC55ICsgb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgLy8gSWYgdGhlIDxib2R5PiBzY3JvbGxiYXIgYXBwZWFycyBvbiB0aGUgbGVmdCAoZS5nLiBSVEwgc3lzdGVtcykuIFVzZVxuICAgICAgLy8gRmlyZWZveCB3aXRoIGxheW91dC5zY3JvbGxiYXIuc2lkZSA9IDMgaW4gYWJvdXQ6Y29uZmlnIHRvIHRlc3QgdGhpcy5cbiAgICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgaHRtbE9mZnNldCA9IGRvY3VtZW50RWxlbWVudCAmJiAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQgPyBnZXRIVE1MT2Zmc2V0KGRvY3VtZW50RWxlbWVudCwgc2Nyb2xsKSA6IGNyZWF0ZUNvb3JkcygwKTtcbiAgY29uc3QgeCA9IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54IC0gaHRtbE9mZnNldC54O1xuICBjb25zdCB5ID0gcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55IC0gaHRtbE9mZnNldC55O1xuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeSxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljUG9zaXRpb25lZChlbGVtZW50KSB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJztcbn1cblxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50LCBwb2x5ZmlsbCkge1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChwb2x5ZmlsbCkge1xuICAgIHJldHVybiBwb2x5ZmlsbChlbGVtZW50KTtcbiAgfVxuICBsZXQgcmF3T2Zmc2V0UGFyZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG5cbiAgLy8gRmlyZWZveCByZXR1cm5zIHRoZSA8aHRtbD4gZWxlbWVudCBhcyB0aGUgb2Zmc2V0UGFyZW50IGlmIGl0J3Mgbm9uLXN0YXRpYyxcbiAgLy8gd2hpbGUgQ2hyb21lIGFuZCBTYWZhcmkgcmV0dXJuIHRoZSA8Ym9keT4gZWxlbWVudC4gVGhlIDxib2R5PiBlbGVtZW50IG11c3RcbiAgLy8gYmUgdXNlZCB0byBwZXJmb3JtIHRoZSBjb3JyZWN0IGNhbGN1bGF0aW9ucyBldmVuIGlmIHRoZSA8aHRtbD4gZWxlbWVudCBpc1xuICAvLyBub24tc3RhdGljLlxuICBpZiAoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpID09PSByYXdPZmZzZXRQYXJlbnQpIHtcbiAgICByYXdPZmZzZXRQYXJlbnQgPSByYXdPZmZzZXRQYXJlbnQub3duZXJEb2N1bWVudC5ib2R5O1xuICB9XG4gIHJldHVybiByYXdPZmZzZXRQYXJlbnQ7XG59XG5cbi8vIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgcG9zaXRpb25lZCBlbGVtZW50LiBIYW5kbGVzIHNvbWUgZWRnZSBjYXNlcyxcbi8vIHN1Y2ggYXMgdGFibGUgYW5jZXN0b3JzIGFuZCBjcm9zcyBicm93c2VyIGJ1Z3MuXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCwgcG9seWZpbGwpIHtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICBpZiAoaXNUb3BMYXllcihlbGVtZW50KSkge1xuICAgIHJldHVybiB3aW47XG4gIH1cbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgbGV0IHN2Z09mZnNldFBhcmVudCA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gICAgd2hpbGUgKHN2Z09mZnNldFBhcmVudCAmJiAhaXNMYXN0VHJhdmVyc2FibGVOb2RlKHN2Z09mZnNldFBhcmVudCkpIHtcbiAgICAgIGlmIChpc0VsZW1lbnQoc3ZnT2Zmc2V0UGFyZW50KSAmJiAhaXNTdGF0aWNQb3NpdGlvbmVkKHN2Z09mZnNldFBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuIHN2Z09mZnNldFBhcmVudDtcbiAgICAgIH1cbiAgICAgIHN2Z09mZnNldFBhcmVudCA9IGdldFBhcmVudE5vZGUoc3ZnT2Zmc2V0UGFyZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHdpbjtcbiAgfVxuICBsZXQgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50LCBwb2x5ZmlsbCk7XG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgaXNUYWJsZUVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBpc1N0YXRpY1Bvc2l0aW9uZWQob2Zmc2V0UGFyZW50KSkge1xuICAgIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50LCBwb2x5ZmlsbCk7XG4gIH1cbiAgaWYgKG9mZnNldFBhcmVudCAmJiBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUob2Zmc2V0UGFyZW50KSAmJiBpc1N0YXRpY1Bvc2l0aW9uZWQob2Zmc2V0UGFyZW50KSAmJiAhaXNDb250YWluaW5nQmxvY2sob2Zmc2V0UGFyZW50KSkge1xuICAgIHJldHVybiB3aW47XG4gIH1cbiAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkgfHwgd2luO1xufVxuXG5jb25zdCBnZXRFbGVtZW50UmVjdHMgPSBhc3luYyBmdW5jdGlvbiAoZGF0YSkge1xuICBjb25zdCBnZXRPZmZzZXRQYXJlbnRGbiA9IHRoaXMuZ2V0T2Zmc2V0UGFyZW50IHx8IGdldE9mZnNldFBhcmVudDtcbiAgY29uc3QgZ2V0RGltZW5zaW9uc0ZuID0gdGhpcy5nZXREaW1lbnNpb25zO1xuICBjb25zdCBmbG9hdGluZ0RpbWVuc2lvbnMgPSBhd2FpdCBnZXREaW1lbnNpb25zRm4oZGF0YS5mbG9hdGluZyk7XG4gIHJldHVybiB7XG4gICAgcmVmZXJlbmNlOiBnZXRSZWN0UmVsYXRpdmVUb09mZnNldFBhcmVudChkYXRhLnJlZmVyZW5jZSwgYXdhaXQgZ2V0T2Zmc2V0UGFyZW50Rm4oZGF0YS5mbG9hdGluZyksIGRhdGEuc3RyYXRlZ3kpLFxuICAgIGZsb2F0aW5nOiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiBmbG9hdGluZ0RpbWVuc2lvbnMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGZsb2F0aW5nRGltZW5zaW9ucy5oZWlnaHRcbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBpc1JUTChlbGVtZW50KSB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmRpcmVjdGlvbiA9PT0gJ3J0bCc7XG59XG5cbmNvbnN0IHBsYXRmb3JtID0ge1xuICBjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCxcbiAgZ2V0RG9jdW1lbnRFbGVtZW50LFxuICBnZXRDbGlwcGluZ1JlY3QsXG4gIGdldE9mZnNldFBhcmVudCxcbiAgZ2V0RWxlbWVudFJlY3RzLFxuICBnZXRDbGllbnRSZWN0cyxcbiAgZ2V0RGltZW5zaW9ucyxcbiAgZ2V0U2NhbGUsXG4gIGlzRWxlbWVudCxcbiAgaXNSVExcbn07XG5cbi8vIGh0dHBzOi8vc2FtdGhvci5hdS8yMDIxL29ic2VydmluZy1kb20vXG5mdW5jdGlvbiBvYnNlcnZlTW92ZShlbGVtZW50LCBvbk1vdmUpIHtcbiAgbGV0IGlvID0gbnVsbDtcbiAgbGV0IHRpbWVvdXRJZDtcbiAgY29uc3Qgcm9vdCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICB2YXIgX2lvO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIChfaW8gPSBpbykgPT0gbnVsbCB8fCBfaW8uZGlzY29ubmVjdCgpO1xuICAgIGlvID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiByZWZyZXNoKHNraXAsIHRocmVzaG9sZCkge1xuICAgIGlmIChza2lwID09PSB2b2lkIDApIHtcbiAgICAgIHNraXAgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRocmVzaG9sZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJlc2hvbGQgPSAxO1xuICAgIH1cbiAgICBjbGVhbnVwKCk7XG4gICAgY29uc3Qge1xuICAgICAgbGVmdCxcbiAgICAgIHRvcCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKCFza2lwKSB7XG4gICAgICBvbk1vdmUoKTtcbiAgICB9XG4gICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluc2V0VG9wID0gZmxvb3IodG9wKTtcbiAgICBjb25zdCBpbnNldFJpZ2h0ID0gZmxvb3Iocm9vdC5jbGllbnRXaWR0aCAtIChsZWZ0ICsgd2lkdGgpKTtcbiAgICBjb25zdCBpbnNldEJvdHRvbSA9IGZsb29yKHJvb3QuY2xpZW50SGVpZ2h0IC0gKHRvcCArIGhlaWdodCkpO1xuICAgIGNvbnN0IGluc2V0TGVmdCA9IGZsb29yKGxlZnQpO1xuICAgIGNvbnN0IHJvb3RNYXJnaW4gPSAtaW5zZXRUb3AgKyBcInB4IFwiICsgLWluc2V0UmlnaHQgKyBcInB4IFwiICsgLWluc2V0Qm90dG9tICsgXCJweCBcIiArIC1pbnNldExlZnQgKyBcInB4XCI7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHJvb3RNYXJnaW4sXG4gICAgICB0aHJlc2hvbGQ6IG1heCgwLCBtaW4oMSwgdGhyZXNob2xkKSkgfHwgMVxuICAgIH07XG4gICAgbGV0IGlzRmlyc3RVcGRhdGUgPSB0cnVlO1xuICAgIGZ1bmN0aW9uIGhhbmRsZU9ic2VydmUoZW50cmllcykge1xuICAgICAgY29uc3QgcmF0aW8gPSBlbnRyaWVzWzBdLmludGVyc2VjdGlvblJhdGlvO1xuICAgICAgaWYgKHJhdGlvICE9PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgaWYgKCFpc0ZpcnN0VXBkYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJhdGlvKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHJlZmVyZW5jZSBpcyBjbGlwcGVkLCB0aGUgcmF0aW8gaXMgMC4gVGhyb3R0bGUgdGhlIHJlZnJlc2hcbiAgICAgICAgICAvLyB0byBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3Agb2YgdXBkYXRlcy5cbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHJlZnJlc2goZmFsc2UsIDFlLTcpO1xuICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnJlc2goZmFsc2UsIHJhdGlvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaXNGaXJzdFVwZGF0ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIE9sZGVyIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgYSBgZG9jdW1lbnRgIGFzIHRoZSByb290IGFuZCB3aWxsIHRocm93IGFuXG4gICAgLy8gZXJyb3IuXG4gICAgdHJ5IHtcbiAgICAgIGlvID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGhhbmRsZU9ic2VydmUsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgLy8gSGFuZGxlIDxpZnJhbWU+c1xuICAgICAgICByb290OiByb290Lm93bmVyRG9jdW1lbnRcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlvID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGhhbmRsZU9ic2VydmUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpby5vYnNlcnZlKGVsZW1lbnQpO1xuICB9XG4gIHJlZnJlc2godHJ1ZSk7XG4gIHJldHVybiBjbGVhbnVwO1xufVxuXG4vKipcbiAqIEF1dG9tYXRpY2FsbHkgdXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgd2hlbiBuZWNlc3NhcnkuXG4gKiBTaG91bGQgb25seSBiZSBjYWxsZWQgd2hlbiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpcyBtb3VudGVkIG9uIHRoZSBET00gb3JcbiAqIHZpc2libGUgb24gdGhlIHNjcmVlbi5cbiAqIEByZXR1cm5zIGNsZWFudXAgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgaW52b2tlZCB3aGVuIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzXG4gKiByZW1vdmVkIGZyb20gdGhlIERPTSBvciBoaWRkZW4gZnJvbSB0aGUgc2NyZWVuLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2F1dG9VcGRhdGVcbiAqL1xuZnVuY3Rpb24gYXV0b1VwZGF0ZShyZWZlcmVuY2UsIGZsb2F0aW5nLCB1cGRhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgYW5jZXN0b3JTY3JvbGwgPSB0cnVlLFxuICAgIGFuY2VzdG9yUmVzaXplID0gdHJ1ZSxcbiAgICBlbGVtZW50UmVzaXplID0gdHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSAnZnVuY3Rpb24nLFxuICAgIGxheW91dFNoaWZ0ID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09PSAnZnVuY3Rpb24nLFxuICAgIGFuaW1hdGlvbkZyYW1lID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHJlZmVyZW5jZUVsID0gdW53cmFwRWxlbWVudChyZWZlcmVuY2UpO1xuICBjb25zdCBhbmNlc3RvcnMgPSBhbmNlc3RvclNjcm9sbCB8fCBhbmNlc3RvclJlc2l6ZSA/IFsuLi4ocmVmZXJlbmNlRWwgPyBnZXRPdmVyZmxvd0FuY2VzdG9ycyhyZWZlcmVuY2VFbCkgOiBbXSksIC4uLmdldE92ZXJmbG93QW5jZXN0b3JzKGZsb2F0aW5nKV0gOiBbXTtcbiAgYW5jZXN0b3JzLmZvckVhY2goYW5jZXN0b3IgPT4ge1xuICAgIGFuY2VzdG9yU2Nyb2xsICYmIGFuY2VzdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHVwZGF0ZSwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGFuY2VzdG9yUmVzaXplICYmIGFuY2VzdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZSk7XG4gIH0pO1xuICBjb25zdCBjbGVhbnVwSW8gPSByZWZlcmVuY2VFbCAmJiBsYXlvdXRTaGlmdCA/IG9ic2VydmVNb3ZlKHJlZmVyZW5jZUVsLCB1cGRhdGUpIDogbnVsbDtcbiAgbGV0IHJlb2JzZXJ2ZUZyYW1lID0gLTE7XG4gIGxldCByZXNpemVPYnNlcnZlciA9IG51bGw7XG4gIGlmIChlbGVtZW50UmVzaXplKSB7XG4gICAgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoX3JlZiA9PiB7XG4gICAgICBsZXQgW2ZpcnN0RW50cnldID0gX3JlZjtcbiAgICAgIGlmIChmaXJzdEVudHJ5ICYmIGZpcnN0RW50cnkudGFyZ2V0ID09PSByZWZlcmVuY2VFbCAmJiByZXNpemVPYnNlcnZlcikge1xuICAgICAgICAvLyBQcmV2ZW50IHVwZGF0ZSBsb29wcyB3aGVuIHVzaW5nIHRoZSBgc2l6ZWAgbWlkZGxld2FyZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8xNzQwXG4gICAgICAgIHJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZShmbG9hdGluZyk7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlb2JzZXJ2ZUZyYW1lKTtcbiAgICAgICAgcmVvYnNlcnZlRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIHZhciBfcmVzaXplT2JzZXJ2ZXI7XG4gICAgICAgICAgKF9yZXNpemVPYnNlcnZlciA9IHJlc2l6ZU9ic2VydmVyKSA9PSBudWxsIHx8IF9yZXNpemVPYnNlcnZlci5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB1cGRhdGUoKTtcbiAgICB9KTtcbiAgICBpZiAocmVmZXJlbmNlRWwgJiYgIWFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKHJlZmVyZW5jZUVsKTtcbiAgICB9XG4gICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShmbG9hdGluZyk7XG4gIH1cbiAgbGV0IGZyYW1lSWQ7XG4gIGxldCBwcmV2UmVmUmVjdCA9IGFuaW1hdGlvbkZyYW1lID8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHJlZmVyZW5jZSkgOiBudWxsO1xuICBpZiAoYW5pbWF0aW9uRnJhbWUpIHtcbiAgICBmcmFtZUxvb3AoKTtcbiAgfVxuICBmdW5jdGlvbiBmcmFtZUxvb3AoKSB7XG4gICAgY29uc3QgbmV4dFJlZlJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocmVmZXJlbmNlKTtcbiAgICBpZiAocHJldlJlZlJlY3QgJiYgKG5leHRSZWZSZWN0LnggIT09IHByZXZSZWZSZWN0LnggfHwgbmV4dFJlZlJlY3QueSAhPT0gcHJldlJlZlJlY3QueSB8fCBuZXh0UmVmUmVjdC53aWR0aCAhPT0gcHJldlJlZlJlY3Qud2lkdGggfHwgbmV4dFJlZlJlY3QuaGVpZ2h0ICE9PSBwcmV2UmVmUmVjdC5oZWlnaHQpKSB7XG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG4gICAgcHJldlJlZlJlY3QgPSBuZXh0UmVmUmVjdDtcbiAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lTG9vcCk7XG4gIH1cbiAgdXBkYXRlKCk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgdmFyIF9yZXNpemVPYnNlcnZlcjI7XG4gICAgYW5jZXN0b3JzLmZvckVhY2goYW5jZXN0b3IgPT4ge1xuICAgICAgYW5jZXN0b3JTY3JvbGwgJiYgYW5jZXN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdXBkYXRlKTtcbiAgICAgIGFuY2VzdG9yUmVzaXplICYmIGFuY2VzdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZSk7XG4gICAgfSk7XG4gICAgY2xlYW51cElvID09IG51bGwgfHwgY2xlYW51cElvKCk7XG4gICAgKF9yZXNpemVPYnNlcnZlcjIgPSByZXNpemVPYnNlcnZlcikgPT0gbnVsbCB8fCBfcmVzaXplT2JzZXJ2ZXIyLmRpc2Nvbm5lY3QoKTtcbiAgICByZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgaWYgKGFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgd2l0aCBhbiBvYmplY3Qgb2Ygb3ZlcmZsb3cgc2lkZSBvZmZzZXRzIHRoYXQgZGV0ZXJtaW5lIGhvdyBtdWNoIHRoZVxuICogZWxlbWVudCBpcyBvdmVyZmxvd2luZyBhIGdpdmVuIGNsaXBwaW5nIGJvdW5kYXJ5IG9uIGVhY2ggc2lkZS5cbiAqIC0gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgYm91bmRhcnkgYnkgdGhhdCBudW1iZXIgb2YgcGl4ZWxzXG4gKiAtIG5lZ2F0aXZlID0gaG93IG1hbnkgcGl4ZWxzIGxlZnQgYmVmb3JlIGl0IHdpbGwgb3ZlcmZsb3dcbiAqIC0gMCA9IGxpZXMgZmx1c2ggd2l0aCB0aGUgYm91bmRhcnlcbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9kZXRlY3RPdmVyZmxvd1xuICovXG5jb25zdCBkZXRlY3RPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93JDE7XG5cbi8qKlxuICogTW9kaWZpZXMgdGhlIHBsYWNlbWVudCBieSB0cmFuc2xhdGluZyB0aGUgZmxvYXRpbmcgZWxlbWVudCBhbG9uZyB0aGVcbiAqIHNwZWNpZmllZCBheGVzLlxuICogQSBudW1iZXIgKHNob3J0aGFuZCBmb3IgYG1haW5BeGlzYCBvciBkaXN0YW5jZSksIG9yIGFuIGF4ZXMgY29uZmlndXJhdGlvblxuICogb2JqZWN0IG1heSBiZSBwYXNzZWQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvb2Zmc2V0XG4gKi9cbmNvbnN0IG9mZnNldCA9IG9mZnNldCQxO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBjaG9vc2luZyB0aGUgcGxhY2VtZW50XG4gKiB0aGF0IGhhcyB0aGUgbW9zdCBzcGFjZSBhdmFpbGFibGUgYXV0b21hdGljYWxseSwgd2l0aG91dCBuZWVkaW5nIHRvIHNwZWNpZnkgYVxuICogcHJlZmVycmVkIHBsYWNlbWVudC4gQWx0ZXJuYXRpdmUgdG8gYGZsaXBgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2F1dG9QbGFjZW1lbnRcbiAqL1xuY29uc3QgYXV0b1BsYWNlbWVudCA9IGF1dG9QbGFjZW1lbnQkMTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgc2hpZnRpbmcgaXQgaW4gb3JkZXIgdG9cbiAqIGtlZXAgaXQgaW4gdmlldyB3aGVuIGl0IHdpbGwgb3ZlcmZsb3cgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NoaWZ0XG4gKi9cbmNvbnN0IHNoaWZ0ID0gc2hpZnQkMTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgZmxpcHBpbmcgdGhlIGBwbGFjZW1lbnRgXG4gKiBpbiBvcmRlciB0byBrZWVwIGl0IGluIHZpZXcgd2hlbiB0aGUgcHJlZmVycmVkIHBsYWNlbWVudChzKSB3aWxsIG92ZXJmbG93IHRoZVxuICogY2xpcHBpbmcgYm91bmRhcnkuIEFsdGVybmF0aXZlIHRvIGBhdXRvUGxhY2VtZW50YC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9mbGlwXG4gKi9cbmNvbnN0IGZsaXAgPSBmbGlwJDE7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0aGF0IGFsbG93cyB5b3UgdG8gY2hhbmdlIHRoZSBzaXplIG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IOKAlFxuICogZm9yIGluc3RhbmNlLCBwcmV2ZW50IGl0IGZyb20gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5IG9yIG1hdGNoIHRoZVxuICogd2lkdGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NpemVcbiAqL1xuY29uc3Qgc2l6ZSA9IHNpemUkMTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIGhpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW4gYXBwbGljYWJsZSBzaXR1YXRpb25zLCBzdWNoIGFzXG4gKiB3aGVuIGl0IGlzIG5vdCBpbiB0aGUgc2FtZSBjbGlwcGluZyBjb250ZXh0IGFzIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9oaWRlXG4gKi9cbmNvbnN0IGhpZGUgPSBoaWRlJDE7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHNvIHRoYXQgaXRcbiAqIGFwcGVhcnMgY2VudGVyZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93ID0gYXJyb3ckMTtcblxuLyoqXG4gKiBQcm92aWRlcyBpbXByb3ZlZCBwb3NpdGlvbmluZyBmb3IgaW5saW5lIHJlZmVyZW5jZSBlbGVtZW50cyB0aGF0IGNhbiBzcGFuXG4gKiBvdmVyIG11bHRpcGxlIGxpbmVzLCBzdWNoIGFzIGh5cGVybGlua3Mgb3IgcmFuZ2Ugc2VsZWN0aW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9pbmxpbmVcbiAqL1xuY29uc3QgaW5saW5lID0gaW5saW5lJDE7XG5cbi8qKlxuICogQnVpbHQtaW4gYGxpbWl0ZXJgIHRoYXQgd2lsbCBzdG9wIGBzaGlmdCgpYCBhdCBhIGNlcnRhaW4gcG9pbnQuXG4gKi9cbmNvbnN0IGxpbWl0U2hpZnQgPSBsaW1pdFNoaWZ0JDE7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIHRoYXQgd2lsbCBwbGFjZSB0aGUgZmxvYXRpbmcgZWxlbWVudFxuICogbmV4dCB0byBhIGdpdmVuIHJlZmVyZW5jZSBlbGVtZW50LlxuICovXG5jb25zdCBjb21wdXRlUG9zaXRpb24gPSAocmVmZXJlbmNlLCBmbG9hdGluZywgb3B0aW9ucykgPT4ge1xuICAvLyBUaGlzIGNhY2hlcyB0aGUgZXhwZW5zaXZlIGBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnNgIGZ1bmN0aW9uIHNvIHRoYXRcbiAgLy8gbXVsdGlwbGUgbGlmZWN5Y2xlIHJlc2V0cyByZS11c2UgdGhlIHNhbWUgcmVzdWx0LiBJdCBvbmx5IGxpdmVzIGZvciBhXG4gIC8vIHNpbmdsZSBjYWxsLiBJZiBvdGhlciBmdW5jdGlvbnMgYmVjb21lIGV4cGVuc2l2ZSwgd2UgY2FuIGFkZCB0aGVtIGFzIHdlbGwuXG4gIGNvbnN0IGNhY2hlID0gbmV3IE1hcCgpO1xuICBjb25zdCBtZXJnZWRPcHRpb25zID0ge1xuICAgIHBsYXRmb3JtLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgY29uc3QgcGxhdGZvcm1XaXRoQ2FjaGUgPSB7XG4gICAgLi4ubWVyZ2VkT3B0aW9ucy5wbGF0Zm9ybSxcbiAgICBfYzogY2FjaGVcbiAgfTtcbiAgcmV0dXJuIGNvbXB1dGVQb3NpdGlvbiQxKHJlZmVyZW5jZSwgZmxvYXRpbmcsIHtcbiAgICAuLi5tZXJnZWRPcHRpb25zLFxuICAgIHBsYXRmb3JtOiBwbGF0Zm9ybVdpdGhDYWNoZVxuICB9KTtcbn07XG5cbmV4cG9ydCB7IGFycm93LCBhdXRvUGxhY2VtZW50LCBhdXRvVXBkYXRlLCBjb21wdXRlUG9zaXRpb24sIGRldGVjdE92ZXJmbG93LCBmbGlwLCBoaWRlLCBpbmxpbmUsIGxpbWl0U2hpZnQsIG9mZnNldCwgcGxhdGZvcm0sIHNoaWZ0LCBzaXplIH07XG4iXSwibmFtZXMiOlsicmVjdFRvQ2xpZW50UmVjdCIsImRldGVjdE92ZXJmbG93IiwiZGV0ZWN0T3ZlcmZsb3ckMSIsIm9mZnNldCIsIm9mZnNldCQxIiwiYXV0b1BsYWNlbWVudCIsImF1dG9QbGFjZW1lbnQkMSIsInNoaWZ0Iiwic2hpZnQkMSIsImZsaXAiLCJmbGlwJDEiLCJzaXplIiwic2l6ZSQxIiwiaGlkZSIsImhpZGUkMSIsImFycm93IiwiYXJyb3ckMSIsImlubGluZSIsImlubGluZSQxIiwibGltaXRTaGlmdCIsImxpbWl0U2hpZnQkMSIsImNvbXB1dGVQb3NpdGlvbiIsImNvbXB1dGVQb3NpdGlvbiQxIiwicm91bmQiLCJjcmVhdGVDb29yZHMiLCJtYXgiLCJtaW4iLCJmbG9vciIsImdldENvbXB1dGVkU3R5bGUiLCJpc0hUTUxFbGVtZW50IiwiaXNFbGVtZW50IiwiZ2V0V2luZG93IiwiaXNXZWJLaXQiLCJnZXRGcmFtZUVsZW1lbnQiLCJnZXROb2RlU2Nyb2xsIiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwiaXNUb3BMYXllciIsImdldE5vZGVOYW1lIiwiaXNPdmVyZmxvd0VsZW1lbnQiLCJnZXRPdmVyZmxvd0FuY2VzdG9ycyIsImdldFBhcmVudE5vZGUiLCJpc0xhc3RUcmF2ZXJzYWJsZU5vZGUiLCJpc0NvbnRhaW5pbmdCbG9jayIsImlzVGFibGVFbGVtZW50IiwiZ2V0Q29udGFpbmluZ0Jsb2NrIiwiZ2V0Q3NzRGltZW5zaW9ucyIsImVsZW1lbnQiLCJjc3MiLCJ3aWR0aCIsInBhcnNlRmxvYXQiLCJoZWlnaHQiLCJoYXNPZmZzZXQiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsInNob3VsZEZhbGxiYWNrIiwiJCIsInVud3JhcEVsZW1lbnQiLCJjb250ZXh0RWxlbWVudCIsImdldFNjYWxlIiwiZG9tRWxlbWVudCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ4IiwieSIsIk51bWJlciIsImlzRmluaXRlIiwibm9PZmZzZXRzIiwiZ2V0VmlzdWFsT2Zmc2V0cyIsIndpbiIsInZpc3VhbFZpZXdwb3J0Iiwib2Zmc2V0TGVmdCIsIm9mZnNldFRvcCIsInNob3VsZEFkZFZpc3VhbE9mZnNldHMiLCJpc0ZpeGVkIiwiZmxvYXRpbmdPZmZzZXRQYXJlbnQiLCJpbmNsdWRlU2NhbGUiLCJpc0ZpeGVkU3RyYXRlZ3kiLCJvZmZzZXRQYXJlbnQiLCJjbGllbnRSZWN0Iiwic2NhbGUiLCJ2aXN1YWxPZmZzZXRzIiwibGVmdCIsInRvcCIsIm9mZnNldFdpbiIsImN1cnJlbnRXaW4iLCJjdXJyZW50SUZyYW1lIiwiaWZyYW1lU2NhbGUiLCJpZnJhbWVSZWN0IiwiY2xpZW50TGVmdCIsInBhZGRpbmdMZWZ0IiwiY2xpZW50VG9wIiwicGFkZGluZ1RvcCIsImdldFdpbmRvd1Njcm9sbEJhclgiLCJsZWZ0U2Nyb2xsIiwic2Nyb2xsTGVmdCIsImdldEhUTUxPZmZzZXQiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JvbGwiLCJpZ25vcmVTY3JvbGxiYXJYIiwiaHRtbFJlY3QiLCJzY3JvbGxUb3AiLCJjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCIsIl9yZWYiLCJlbGVtZW50cyIsInN0cmF0ZWd5IiwidG9wTGF5ZXIiLCJmbG9hdGluZyIsIm9mZnNldHMiLCJpc09mZnNldFBhcmVudEFuRWxlbWVudCIsIm9mZnNldFJlY3QiLCJodG1sT2Zmc2V0IiwiZ2V0Q2xpZW50UmVjdHMiLCJBcnJheSIsImZyb20iLCJnZXREb2N1bWVudFJlY3QiLCJodG1sIiwiYm9keSIsIm93bmVyRG9jdW1lbnQiLCJzY3JvbGxXaWR0aCIsImNsaWVudFdpZHRoIiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiZGlyZWN0aW9uIiwiZ2V0Vmlld3BvcnRSZWN0IiwidmlzdWFsVmlld3BvcnRCYXNlZCIsImdldElubmVyQm91bmRpbmdDbGllbnRSZWN0IiwiZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yIiwiY2xpcHBpbmdBbmNlc3RvciIsImhhc0ZpeGVkUG9zaXRpb25BbmNlc3RvciIsInN0b3BOb2RlIiwicGFyZW50Tm9kZSIsInBvc2l0aW9uIiwiZ2V0Q2xpcHBpbmdFbGVtZW50QW5jZXN0b3JzIiwiY2FjaGUiLCJjYWNoZWRSZXN1bHQiLCJnZXQiLCJyZXN1bHQiLCJmaWx0ZXIiLCJlbCIsImN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlIiwiZWxlbWVudElzRml4ZWQiLCJjdXJyZW50Tm9kZSIsImNvbXB1dGVkU3R5bGUiLCJjdXJyZW50Tm9kZUlzQ29udGFpbmluZyIsInNob3VsZERyb3BDdXJyZW50Tm9kZSIsImluY2x1ZGVzIiwiYW5jZXN0b3IiLCJzZXQiLCJnZXRDbGlwcGluZ1JlY3QiLCJib3VuZGFyeSIsInJvb3RCb3VuZGFyeSIsImVsZW1lbnRDbGlwcGluZ0FuY2VzdG9ycyIsIl9jIiwiY29uY2F0IiwiY2xpcHBpbmdBbmNlc3RvcnMiLCJmaXJzdENsaXBwaW5nQW5jZXN0b3IiLCJjbGlwcGluZ1JlY3QiLCJyZWR1Y2UiLCJhY2NSZWN0IiwicmlnaHQiLCJib3R0b20iLCJnZXREaW1lbnNpb25zIiwiZ2V0UmVjdFJlbGF0aXZlVG9PZmZzZXRQYXJlbnQiLCJpc1N0YXRpY1Bvc2l0aW9uZWQiLCJnZXRUcnVlT2Zmc2V0UGFyZW50IiwicG9seWZpbGwiLCJyYXdPZmZzZXRQYXJlbnQiLCJnZXRPZmZzZXRQYXJlbnQiLCJzdmdPZmZzZXRQYXJlbnQiLCJnZXRFbGVtZW50UmVjdHMiLCJkYXRhIiwiZ2V0T2Zmc2V0UGFyZW50Rm4iLCJnZXREaW1lbnNpb25zRm4iLCJmbG9hdGluZ0RpbWVuc2lvbnMiLCJyZWZlcmVuY2UiLCJpc1JUTCIsInBsYXRmb3JtIiwib2JzZXJ2ZU1vdmUiLCJvbk1vdmUiLCJpbyIsInRpbWVvdXRJZCIsInJvb3QiLCJjbGVhbnVwIiwiX2lvIiwiY2xlYXJUaW1lb3V0IiwiZGlzY29ubmVjdCIsInJlZnJlc2giLCJza2lwIiwidGhyZXNob2xkIiwiaW5zZXRUb3AiLCJpbnNldFJpZ2h0IiwiaW5zZXRCb3R0b20iLCJpbnNldExlZnQiLCJyb290TWFyZ2luIiwib3B0aW9ucyIsImlzRmlyc3RVcGRhdGUiLCJoYW5kbGVPYnNlcnZlIiwiZW50cmllcyIsInJhdGlvIiwiaW50ZXJzZWN0aW9uUmF0aW8iLCJzZXRUaW1lb3V0IiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJlIiwib2JzZXJ2ZSIsImF1dG9VcGRhdGUiLCJ1cGRhdGUiLCJhbmNlc3RvclNjcm9sbCIsImFuY2VzdG9yUmVzaXplIiwiZWxlbWVudFJlc2l6ZSIsIlJlc2l6ZU9ic2VydmVyIiwibGF5b3V0U2hpZnQiLCJhbmltYXRpb25GcmFtZSIsInJlZmVyZW5jZUVsIiwiYW5jZXN0b3JzIiwiZm9yRWFjaCIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXNzaXZlIiwiY2xlYW51cElvIiwicmVvYnNlcnZlRnJhbWUiLCJyZXNpemVPYnNlcnZlciIsImZpcnN0RW50cnkiLCJ0YXJnZXQiLCJ1bm9ic2VydmUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIl9yZXNpemVPYnNlcnZlciIsImZyYW1lSWQiLCJwcmV2UmVmUmVjdCIsImZyYW1lTG9vcCIsIm5leHRSZWZSZWN0IiwiX3Jlc2l6ZU9ic2VydmVyMiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJNYXAiLCJtZXJnZWRPcHRpb25zIiwicGxhdGZvcm1XaXRoQ2FjaGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getComputedStyle: () => (/* binding */ getComputedStyle),\n/* harmony export */   getContainingBlock: () => (/* binding */ getContainingBlock),\n/* harmony export */   getDocumentElement: () => (/* binding */ getDocumentElement),\n/* harmony export */   getFrameElement: () => (/* binding */ getFrameElement),\n/* harmony export */   getNearestOverflowAncestor: () => (/* binding */ getNearestOverflowAncestor),\n/* harmony export */   getNodeName: () => (/* binding */ getNodeName),\n/* harmony export */   getNodeScroll: () => (/* binding */ getNodeScroll),\n/* harmony export */   getOverflowAncestors: () => (/* binding */ getOverflowAncestors),\n/* harmony export */   getParentNode: () => (/* binding */ getParentNode),\n/* harmony export */   getWindow: () => (/* binding */ getWindow),\n/* harmony export */   isContainingBlock: () => (/* binding */ isContainingBlock),\n/* harmony export */   isElement: () => (/* binding */ isElement),\n/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),\n/* harmony export */   isLastTraversableNode: () => (/* binding */ isLastTraversableNode),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isOverflowElement: () => (/* binding */ isOverflowElement),\n/* harmony export */   isShadowRoot: () => (/* binding */ isShadowRoot),\n/* harmony export */   isTableElement: () => (/* binding */ isTableElement),\n/* harmony export */   isTopLayer: () => (/* binding */ isTopLayer),\n/* harmony export */   isWebKit: () => (/* binding */ isWebKit)\n/* harmony export */ });\nfunction hasWindow() {\n    return \"undefined\" !== \"undefined\";\n}\nfunction getNodeName(node) {\n    if (isNode(node)) {\n        return (node.nodeName || \"\").toLowerCase();\n    }\n    // Mocked nodes in testing environments may not be instances of Node. By\n    // returning `#document` an infinite loop won't occur.\n    // https://github.com/floating-ui/floating-ui/issues/2317\n    return \"#document\";\n}\nfunction getWindow(node) {\n    var _node$ownerDocument;\n    return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n    var _ref;\n    return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n    if (!hasWindow()) {\n        return false;\n    }\n    return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n    if (!hasWindow()) {\n        return false;\n    }\n    return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n    if (!hasWindow()) {\n        return false;\n    }\n    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n    if (!hasWindow() || typeof ShadowRoot === \"undefined\") {\n        return false;\n    }\n    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n    const { overflow, overflowX, overflowY, display } = getComputedStyle(element);\n    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && ![\n        \"inline\",\n        \"contents\"\n    ].includes(display);\n}\nfunction isTableElement(element) {\n    return [\n        \"table\",\n        \"td\",\n        \"th\"\n    ].includes(getNodeName(element));\n}\nfunction isTopLayer(element) {\n    return [\n        \":popover-open\",\n        \":modal\"\n    ].some((selector)=>{\n        try {\n            return element.matches(selector);\n        } catch (e) {\n            return false;\n        }\n    });\n}\nfunction isContainingBlock(elementOrCss) {\n    const webkit = isWebKit();\n    const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    return css.transform !== \"none\" || css.perspective !== \"none\" || (css.containerType ? css.containerType !== \"normal\" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== \"none\" : false) || !webkit && (css.filter ? css.filter !== \"none\" : false) || [\n        \"transform\",\n        \"perspective\",\n        \"filter\"\n    ].some((value)=>(css.willChange || \"\").includes(value)) || [\n        \"paint\",\n        \"layout\",\n        \"strict\",\n        \"content\"\n    ].some((value)=>(css.contain || \"\").includes(value));\n}\nfunction getContainingBlock(element) {\n    let currentNode = getParentNode(element);\n    while(isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)){\n        if (isContainingBlock(currentNode)) {\n            return currentNode;\n        } else if (isTopLayer(currentNode)) {\n            return null;\n        }\n        currentNode = getParentNode(currentNode);\n    }\n    return null;\n}\nfunction isWebKit() {\n    if (typeof CSS === \"undefined\" || !CSS.supports) return false;\n    return CSS.supports(\"-webkit-backdrop-filter\", \"none\");\n}\nfunction isLastTraversableNode(node) {\n    return [\n        \"html\",\n        \"body\",\n        \"#document\"\n    ].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n    return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n    if (isElement(element)) {\n        return {\n            scrollLeft: element.scrollLeft,\n            scrollTop: element.scrollTop\n        };\n    }\n    return {\n        scrollLeft: element.scrollX,\n        scrollTop: element.scrollY\n    };\n}\nfunction getParentNode(node) {\n    if (getNodeName(node) === \"html\") {\n        return node;\n    }\n    const result = // Step into the shadow DOM of the parent of a slotted node.\n    node.assignedSlot || // DOM Element detected.\n    node.parentNode || // ShadowRoot detected.\n    isShadowRoot(node) && node.host || // Fallback.\n    getDocumentElement(node);\n    return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n    const parentNode = getParentNode(node);\n    if (isLastTraversableNode(parentNode)) {\n        return node.ownerDocument ? node.ownerDocument.body : node.body;\n    }\n    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n        return parentNode;\n    }\n    return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n    var _node$ownerDocument2;\n    if (list === void 0) {\n        list = [];\n    }\n    if (traverseIframes === void 0) {\n        traverseIframes = true;\n    }\n    const scrollableAncestor = getNearestOverflowAncestor(node);\n    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n    const win = getWindow(scrollableAncestor);\n    if (isBody) {\n        const frameElement = getFrameElement(win);\n        return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n    }\n    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n    return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMuZG9tLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLFNBQVNBO0lBQ1AsT0FBTyxnQkFBa0I7QUFDM0I7QUFDQSxTQUFTQyxZQUFZQyxJQUFJO0lBQ3ZCLElBQUlDLE9BQU9ELE9BQU87UUFDaEIsT0FBTyxDQUFDQSxLQUFLRSxRQUFRLElBQUksRUFBQyxFQUFHQyxXQUFXO0lBQzFDO0lBQ0Esd0VBQXdFO0lBQ3hFLHNEQUFzRDtJQUN0RCx5REFBeUQ7SUFDekQsT0FBTztBQUNUO0FBQ0EsU0FBU0MsVUFBVUosSUFBSTtJQUNyQixJQUFJSztJQUNKLE9BQU8sQ0FBQ0wsUUFBUSxRQUFRLENBQUNLLHNCQUFzQkwsS0FBS00sYUFBYSxLQUFLLE9BQU8sS0FBSyxJQUFJRCxvQkFBb0JFLFdBQVcsS0FBS0M7QUFDNUg7QUFDQSxTQUFTQyxtQkFBbUJULElBQUk7SUFDOUIsSUFBSVU7SUFDSixPQUFPLENBQUNBLE9BQU8sQ0FBQ1QsT0FBT0QsUUFBUUEsS0FBS00sYUFBYSxHQUFHTixLQUFLVyxRQUFRLEtBQUtILE9BQU9HLFFBQVEsS0FBSyxPQUFPLEtBQUssSUFBSUQsS0FBS0UsZUFBZTtBQUNoSTtBQUNBLFNBQVNYLE9BQU9ZLEtBQUs7SUFDbkIsSUFBSSxDQUFDZixhQUFhO1FBQ2hCLE9BQU87SUFDVDtJQUNBLE9BQU9lLGlCQUFpQkMsUUFBUUQsaUJBQWlCVCxVQUFVUyxPQUFPQyxJQUFJO0FBQ3hFO0FBQ0EsU0FBU0MsVUFBVUYsS0FBSztJQUN0QixJQUFJLENBQUNmLGFBQWE7UUFDaEIsT0FBTztJQUNUO0lBQ0EsT0FBT2UsaUJBQWlCRyxXQUFXSCxpQkFBaUJULFVBQVVTLE9BQU9HLE9BQU87QUFDOUU7QUFDQSxTQUFTQyxjQUFjSixLQUFLO0lBQzFCLElBQUksQ0FBQ2YsYUFBYTtRQUNoQixPQUFPO0lBQ1Q7SUFD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S1EsTUFBTSxDQUFDSCxLQUFLQSxJQUFJSSxjQUFjLElBQUksRUFBRSxFQUFFdEQsa0JBQWtCZ0Qsc0JBQXNCQSxxQkFBcUIsRUFBRSxFQUFFRyxnQkFBZ0JMLGtCQUFrQkYscUJBQXFCTyxnQkFBZ0IsRUFBRTtJQUM5TDtJQUNBLE9BQU9OLEtBQUtRLE1BQU0sQ0FBQ0wsb0JBQW9CSixxQkFBcUJJLG9CQUFvQixFQUFFLEVBQUVGO0FBQ3RGO0FBQ0EsU0FBU00sZ0JBQWdCRixHQUFHO0lBQzFCLE9BQU9BLElBQUlLLE1BQU0sSUFBSUMsT0FBT0MsY0FBYyxDQUFDUCxJQUFJSyxNQUFNLElBQUlMLElBQUlDLFlBQVksR0FBRztBQUM5RTtBQUVnViIsInNvdXJjZXMiOlsid2VicGFjazovL2FkbWlzc2lvbi11cGxpZnQvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMuZG9tLm1qcz8yNGVhIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGhhc1dpbmRvdygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZU5hbWUobm9kZSkge1xuICBpZiAoaXNOb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIChub2RlLm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIC8vIE1vY2tlZCBub2RlcyBpbiB0ZXN0aW5nIGVudmlyb25tZW50cyBtYXkgbm90IGJlIGluc3RhbmNlcyBvZiBOb2RlLiBCeVxuICAvLyByZXR1cm5pbmcgYCNkb2N1bWVudGAgYW4gaW5maW5pdGUgbG9vcCB3b24ndCBvY2N1ci5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8yMzE3XG4gIHJldHVybiAnI2RvY3VtZW50Jztcbn1cbmZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XG4gIHZhciBfbm9kZSRvd25lckRvY3VtZW50O1xuICByZXR1cm4gKG5vZGUgPT0gbnVsbCB8fCAoX25vZGUkb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpIHx8IHdpbmRvdztcbn1cbmZ1bmN0aW9uIGdldERvY3VtZW50RWxlbWVudChub2RlKSB7XG4gIHZhciBfcmVmO1xuICByZXR1cm4gKF9yZWYgPSAoaXNOb2RlKG5vZGUpID8gbm9kZS5vd25lckRvY3VtZW50IDogbm9kZS5kb2N1bWVudCkgfHwgd2luZG93LmRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3JlZi5kb2N1bWVudEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc05vZGUodmFsdWUpIHtcbiAgaWYgKCFoYXNXaW5kb3coKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBOb2RlIHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5Ob2RlO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gIGlmICghaGFzV2luZG93KCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudCB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQodmFsdWUpIHtcbiAgaWYgKCFoYXNXaW5kb3coKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuSFRNTEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc1NoYWRvd1Jvb3QodmFsdWUpIHtcbiAgaWYgKCFoYXNXaW5kb3coKSB8fCB0eXBlb2YgU2hhZG93Um9vdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU2hhZG93Um9vdCB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuU2hhZG93Um9vdDtcbn1cbmZ1bmN0aW9uIGlzT3ZlcmZsb3dFbGVtZW50KGVsZW1lbnQpIHtcbiAgY29uc3Qge1xuICAgIG92ZXJmbG93LFxuICAgIG92ZXJmbG93WCxcbiAgICBvdmVyZmxvd1ksXG4gICAgZGlzcGxheVxuICB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgcmV0dXJuIC9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbnxjbGlwLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKSAmJiAhWydpbmxpbmUnLCAnY29udGVudHMnXS5pbmNsdWRlcyhkaXNwbGF5KTtcbn1cbmZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFsndGFibGUnLCAndGQnLCAndGgnXS5pbmNsdWRlcyhnZXROb2RlTmFtZShlbGVtZW50KSk7XG59XG5mdW5jdGlvbiBpc1RvcExheWVyKGVsZW1lbnQpIHtcbiAgcmV0dXJuIFsnOnBvcG92ZXItb3BlbicsICc6bW9kYWwnXS5zb21lKHNlbGVjdG9yID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQubWF0Y2hlcyhzZWxlY3Rvcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBpc0NvbnRhaW5pbmdCbG9jayhlbGVtZW50T3JDc3MpIHtcbiAgY29uc3Qgd2Via2l0ID0gaXNXZWJLaXQoKTtcbiAgY29uc3QgY3NzID0gaXNFbGVtZW50KGVsZW1lbnRPckNzcykgPyBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnRPckNzcykgOiBlbGVtZW50T3JDc3M7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcbiAgcmV0dXJuIGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fCBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fCAoY3NzLmNvbnRhaW5lclR5cGUgPyBjc3MuY29udGFpbmVyVHlwZSAhPT0gJ25vcm1hbCcgOiBmYWxzZSkgfHwgIXdlYmtpdCAmJiAoY3NzLmJhY2tkcm9wRmlsdGVyID8gY3NzLmJhY2tkcm9wRmlsdGVyICE9PSAnbm9uZScgOiBmYWxzZSkgfHwgIXdlYmtpdCAmJiAoY3NzLmZpbHRlciA/IGNzcy5maWx0ZXIgIT09ICdub25lJyA6IGZhbHNlKSB8fCBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZScsICdmaWx0ZXInXS5zb21lKHZhbHVlID0+IChjc3Mud2lsbENoYW5nZSB8fCAnJykuaW5jbHVkZXModmFsdWUpKSB8fCBbJ3BhaW50JywgJ2xheW91dCcsICdzdHJpY3QnLCAnY29udGVudCddLnNvbWUodmFsdWUgPT4gKGNzcy5jb250YWluIHx8ICcnKS5pbmNsdWRlcyh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcbiAgbGV0IGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmICFpc0xhc3RUcmF2ZXJzYWJsZU5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgaWYgKGlzQ29udGFpbmluZ0Jsb2NrKGN1cnJlbnROb2RlKSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSBpZiAoaXNUb3BMYXllcihjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoY3VycmVudE5vZGUpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNXZWJLaXQoKSB7XG4gIGlmICh0eXBlb2YgQ1NTID09PSAndW5kZWZpbmVkJyB8fCAhQ1NTLnN1cHBvcnRzKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBDU1Muc3VwcG9ydHMoJy13ZWJraXQtYmFja2Ryb3AtZmlsdGVyJywgJ25vbmUnKTtcbn1cbmZ1bmN0aW9uIGlzTGFzdFRyYXZlcnNhYmxlTm9kZShub2RlKSB7XG4gIHJldHVybiBbJ2h0bWwnLCAnYm9keScsICcjZG9jdW1lbnQnXS5pbmNsdWRlcyhnZXROb2RlTmFtZShub2RlKSk7XG59XG5mdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChlbGVtZW50KSB7XG4gIGlmIChpc0VsZW1lbnQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbFgsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUobm9kZSkge1xuICBpZiAoZ2V0Tm9kZU5hbWUobm9kZSkgPT09ICdodG1sJykge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9XG4gIC8vIFN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlLlxuICBub2RlLmFzc2lnbmVkU2xvdCB8fFxuICAvLyBET00gRWxlbWVudCBkZXRlY3RlZC5cbiAgbm9kZS5wYXJlbnROb2RlIHx8XG4gIC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWQuXG4gIGlzU2hhZG93Um9vdChub2RlKSAmJiBub2RlLmhvc3QgfHxcbiAgLy8gRmFsbGJhY2suXG4gIGdldERvY3VtZW50RWxlbWVudChub2RlKTtcbiAgcmV0dXJuIGlzU2hhZG93Um9vdChyZXN1bHQpID8gcmVzdWx0Lmhvc3QgOiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3Rvcihub2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKG5vZGUpO1xuICBpZiAoaXNMYXN0VHJhdmVyc2FibGVOb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudCA/IG5vZGUub3duZXJEb2N1bWVudC5ib2R5IDogbm9kZS5ib2R5O1xuICB9XG4gIGlmIChpc0hUTUxFbGVtZW50KHBhcmVudE5vZGUpICYmIGlzT3ZlcmZsb3dFbGVtZW50KHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIHBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKHBhcmVudE5vZGUpO1xufVxuZnVuY3Rpb24gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMobm9kZSwgbGlzdCwgdHJhdmVyc2VJZnJhbWVzKSB7XG4gIHZhciBfbm9kZSRvd25lckRvY3VtZW50MjtcbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuICBpZiAodHJhdmVyc2VJZnJhbWVzID09PSB2b2lkIDApIHtcbiAgICB0cmF2ZXJzZUlmcmFtZXMgPSB0cnVlO1xuICB9XG4gIGNvbnN0IHNjcm9sbGFibGVBbmNlc3RvciA9IGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKG5vZGUpO1xuICBjb25zdCBpc0JvZHkgPSBzY3JvbGxhYmxlQW5jZXN0b3IgPT09ICgoX25vZGUkb3duZXJEb2N1bWVudDIgPSBub2RlLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRvd25lckRvY3VtZW50Mi5ib2R5KTtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KHNjcm9sbGFibGVBbmNlc3Rvcik7XG4gIGlmIChpc0JvZHkpIHtcbiAgICBjb25zdCBmcmFtZUVsZW1lbnQgPSBnZXRGcmFtZUVsZW1lbnQod2luKTtcbiAgICByZXR1cm4gbGlzdC5jb25jYXQod2luLCB3aW4udmlzdWFsVmlld3BvcnQgfHwgW10sIGlzT3ZlcmZsb3dFbGVtZW50KHNjcm9sbGFibGVBbmNlc3RvcikgPyBzY3JvbGxhYmxlQW5jZXN0b3IgOiBbXSwgZnJhbWVFbGVtZW50ICYmIHRyYXZlcnNlSWZyYW1lcyA/IGdldE92ZXJmbG93QW5jZXN0b3JzKGZyYW1lRWxlbWVudCkgOiBbXSk7XG4gIH1cbiAgcmV0dXJuIGxpc3QuY29uY2F0KHNjcm9sbGFibGVBbmNlc3RvciwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoc2Nyb2xsYWJsZUFuY2VzdG9yLCBbXSwgdHJhdmVyc2VJZnJhbWVzKSk7XG59XG5mdW5jdGlvbiBnZXRGcmFtZUVsZW1lbnQod2luKSB7XG4gIHJldHVybiB3aW4ucGFyZW50ICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZih3aW4ucGFyZW50KSA/IHdpbi5mcmFtZUVsZW1lbnQgOiBudWxsO1xufVxuXG5leHBvcnQgeyBnZXRDb21wdXRlZFN0eWxlLCBnZXRDb250YWluaW5nQmxvY2ssIGdldERvY3VtZW50RWxlbWVudCwgZ2V0RnJhbWVFbGVtZW50LCBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3RvciwgZ2V0Tm9kZU5hbWUsIGdldE5vZGVTY3JvbGwsIGdldE92ZXJmbG93QW5jZXN0b3JzLCBnZXRQYXJlbnROb2RlLCBnZXRXaW5kb3csIGlzQ29udGFpbmluZ0Jsb2NrLCBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzTGFzdFRyYXZlcnNhYmxlTm9kZSwgaXNOb2RlLCBpc092ZXJmbG93RWxlbWVudCwgaXNTaGFkb3dSb290LCBpc1RhYmxlRWxlbWVudCwgaXNUb3BMYXllciwgaXNXZWJLaXQgfTtcbiJdLCJuYW1lcyI6WyJoYXNXaW5kb3ciLCJnZXROb2RlTmFtZSIsIm5vZGUiLCJpc05vZGUiLCJub2RlTmFtZSIsInRvTG93ZXJDYXNlIiwiZ2V0V2luZG93IiwiX25vZGUkb3duZXJEb2N1bWVudCIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsIndpbmRvdyIsImdldERvY3VtZW50RWxlbWVudCIsIl9yZWYiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsInZhbHVlIiwiTm9kZSIsImlzRWxlbWVudCIsIkVsZW1lbnQiLCJpc0hUTUxFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJpc1NoYWRvd1Jvb3QiLCJTaGFkb3dSb290IiwiaXNPdmVyZmxvd0VsZW1lbnQiLCJlbGVtZW50Iiwib3ZlcmZsb3ciLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJkaXNwbGF5IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInRlc3QiLCJpbmNsdWRlcyIsImlzVGFibGVFbGVtZW50IiwiaXNUb3BMYXllciIsInNvbWUiLCJzZWxlY3RvciIsIm1hdGNoZXMiLCJlIiwiaXNDb250YWluaW5nQmxvY2siLCJlbGVtZW50T3JDc3MiLCJ3ZWJraXQiLCJpc1dlYktpdCIsImNzcyIsInRyYW5zZm9ybSIsInBlcnNwZWN0aXZlIiwiY29udGFpbmVyVHlwZSIsImJhY2tkcm9wRmlsdGVyIiwiZmlsdGVyIiwid2lsbENoYW5nZSIsImNvbnRhaW4iLCJnZXRDb250YWluaW5nQmxvY2siLCJjdXJyZW50Tm9kZSIsImdldFBhcmVudE5vZGUiLCJpc0xhc3RUcmF2ZXJzYWJsZU5vZGUiLCJDU1MiLCJzdXBwb3J0cyIsImdldE5vZGVTY3JvbGwiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwic2Nyb2xsWCIsInNjcm9sbFkiLCJyZXN1bHQiLCJhc3NpZ25lZFNsb3QiLCJwYXJlbnROb2RlIiwiaG9zdCIsImdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yIiwiYm9keSIsImdldE92ZXJmbG93QW5jZXN0b3JzIiwibGlzdCIsInRyYXZlcnNlSWZyYW1lcyIsIl9ub2RlJG93bmVyRG9jdW1lbnQyIiwic2Nyb2xsYWJsZUFuY2VzdG9yIiwiaXNCb2R5Iiwid2luIiwiZnJhbWVFbGVtZW50IiwiZ2V0RnJhbWVFbGVtZW50IiwiY29uY2F0IiwidmlzdWFsVmlld3BvcnQiLCJwYXJlbnQiLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   alignments: () => (/* binding */ alignments),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   createCoords: () => (/* binding */ createCoords),\n/* harmony export */   evaluate: () => (/* binding */ evaluate),\n/* harmony export */   expandPaddingObject: () => (/* binding */ expandPaddingObject),\n/* harmony export */   floor: () => (/* binding */ floor),\n/* harmony export */   getAlignment: () => (/* binding */ getAlignment),\n/* harmony export */   getAlignmentAxis: () => (/* binding */ getAlignmentAxis),\n/* harmony export */   getAlignmentSides: () => (/* binding */ getAlignmentSides),\n/* harmony export */   getAxisLength: () => (/* binding */ getAxisLength),\n/* harmony export */   getExpandedPlacements: () => (/* binding */ getExpandedPlacements),\n/* harmony export */   getOppositeAlignmentPlacement: () => (/* binding */ getOppositeAlignmentPlacement),\n/* harmony export */   getOppositeAxis: () => (/* binding */ getOppositeAxis),\n/* harmony export */   getOppositeAxisPlacements: () => (/* binding */ getOppositeAxisPlacements),\n/* harmony export */   getOppositePlacement: () => (/* binding */ getOppositePlacement),\n/* harmony export */   getPaddingObject: () => (/* binding */ getPaddingObject),\n/* harmony export */   getSide: () => (/* binding */ getSide),\n/* harmony export */   getSideAxis: () => (/* binding */ getSideAxis),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   placements: () => (/* binding */ placements),\n/* harmony export */   rectToClientRect: () => (/* binding */ rectToClientRect),\n/* harmony export */   round: () => (/* binding */ round),\n/* harmony export */   sides: () => (/* binding */ sides)\n/* harmony export */ });\n/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */ const sides = [\n    \"top\",\n    \"right\",\n    \"bottom\",\n    \"left\"\n];\nconst alignments = [\n    \"start\",\n    \"end\"\n];\nconst placements = /*#__PURE__*/ sides.reduce((acc, side)=>acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = (v)=>({\n        x: v,\n        y: v\n    });\nconst oppositeSideMap = {\n    left: \"right\",\n    right: \"left\",\n    bottom: \"top\",\n    top: \"bottom\"\n};\nconst oppositeAlignmentMap = {\n    start: \"end\",\n    end: \"start\"\n};\nfunction clamp(start, value, end) {\n    return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n    return typeof value === \"function\" ? value(param) : value;\n}\nfunction getSide(placement) {\n    return placement.split(\"-\")[0];\n}\nfunction getAlignment(placement) {\n    return placement.split(\"-\")[1];\n}\nfunction getOppositeAxis(axis) {\n    return axis === \"x\" ? \"y\" : \"x\";\n}\nfunction getAxisLength(axis) {\n    return axis === \"y\" ? \"height\" : \"width\";\n}\nfunction getSideAxis(placement) {\n    return [\n        \"top\",\n        \"bottom\"\n    ].includes(getSide(placement)) ? \"y\" : \"x\";\n}\nfunction getAlignmentAxis(placement) {\n    return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n    if (rtl === void 0) {\n        rtl = false;\n    }\n    const alignment = getAlignment(placement);\n    const alignmentAxis = getAlignmentAxis(placement);\n    const length = getAxisLength(alignmentAxis);\n    let mainAlignmentSide = alignmentAxis === \"x\" ? alignment === (rtl ? \"end\" : \"start\") ? \"right\" : \"left\" : alignment === \"start\" ? \"bottom\" : \"top\";\n    if (rects.reference[length] > rects.floating[length]) {\n        mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n    }\n    return [\n        mainAlignmentSide,\n        getOppositePlacement(mainAlignmentSide)\n    ];\n}\nfunction getExpandedPlacements(placement) {\n    const oppositePlacement = getOppositePlacement(placement);\n    return [\n        getOppositeAlignmentPlacement(placement),\n        oppositePlacement,\n        getOppositeAlignmentPlacement(oppositePlacement)\n    ];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n    return placement.replace(/start|end/g, (alignment)=>oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n    const lr = [\n        \"left\",\n        \"right\"\n    ];\n    const rl = [\n        \"right\",\n        \"left\"\n    ];\n    const tb = [\n        \"top\",\n        \"bottom\"\n    ];\n    const bt = [\n        \"bottom\",\n        \"top\"\n    ];\n    switch(side){\n        case \"top\":\n        case \"bottom\":\n            if (rtl) return isStart ? rl : lr;\n            return isStart ? lr : rl;\n        case \"left\":\n        case \"right\":\n            return isStart ? tb : bt;\n        default:\n            return [];\n    }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n    const alignment = getAlignment(placement);\n    let list = getSideList(getSide(placement), direction === \"start\", rtl);\n    if (alignment) {\n        list = list.map((side)=>side + \"-\" + alignment);\n        if (flipAlignment) {\n            list = list.concat(list.map(getOppositeAlignmentPlacement));\n        }\n    }\n    return list;\n}\nfunction getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, (side)=>oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n    return {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0,\n        ...padding\n    };\n}\nfunction getPaddingObject(padding) {\n    return typeof padding !== \"number\" ? expandPaddingObject(padding) : {\n        top: padding,\n        right: padding,\n        bottom: padding,\n        left: padding\n    };\n}\nfunction rectToClientRect(rect) {\n    const { x, y, width, height } = rect;\n    return {\n        width,\n        height,\n        top: y,\n        left: x,\n        right: x + width,\n        bottom: y + height,\n        x,\n        y\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Q0FHQyxHQUVELE1BQU1BLFFBQVE7SUFBQztJQUFPO0lBQVM7SUFBVTtDQUFPO0FBQ2hELE1BQU1DLGFBQWE7SUFBQztJQUFTO0NBQU07QUFDbkMsTUFBTUMsYUFBYSxXQUFXLEdBQUVGLE1BQU1HLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxPQUFTRCxJQUFJRSxNQUFNLENBQUNELE1BQU1BLE9BQU8sTUFBTUosVUFBVSxDQUFDLEVBQUUsRUFBRUksT0FBTyxNQUFNSixVQUFVLENBQUMsRUFBRSxHQUFHLEVBQUU7QUFDeEksTUFBTU0sTUFBTUMsS0FBS0QsR0FBRztBQUNwQixNQUFNRSxNQUFNRCxLQUFLQyxHQUFHO0FBQ3BCLE1BQU1DLFFBQVFGLEtBQUtFLEtBQUs7QUFDeEIsTUFBTUMsUUFBUUgsS0FBS0csS0FBSztBQUN4QixNQUFNQyxlQUFlQyxDQUFBQSxJQUFNO1FBQ3pCQyxHQUFHRDtRQUNIRSxHQUFHRjtJQUNMO0FBQ0EsTUFBTUcsa0JBQWtCO0lBQ3RCQyxNQUFNO0lBQ05DLE9BQU87SUFDUEMsUUFBUTtJQUNSQyxLQUFLO0FBQ1A7QUFDQSxNQUFNQyx1QkFBdUI7SUFDM0JDLE9BQU87SUFDUEMsS0FBSztBQUNQO0FBQ0EsU0FBU0MsTUFBTUYsS0FBSyxFQUFFRyxLQUFLLEVBQUVGLEdBQUc7SUFDOUIsT0FBT2QsSUFBSWEsT0FBT2YsSUFBSWtCLE9BQU9GO0FBQy9CO0FBQ0EsU0FBU0csU0FBU0QsS0FBSyxFQUFFRSxLQUFLO0lBQzVCLE9BQU8sT0FBT0YsVUFBVSxhQUFhQSxNQUFNRSxTQUFTRjtBQUN0RDtBQUNBLFNBQVNHLFFBQVFDLFNBQVM7SUFDeEIsT0FBT0EsVUFBVUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQ2hDO0FBQ0EsU0FB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Qy9CLE9BQU8sT0FBT0EsWUFBWSxXQUFXRCxvQkFBb0JDLFdBQVc7UUFDbEU1QyxLQUFLNEM7UUFDTDlDLE9BQU84QztRQUNQN0MsUUFBUTZDO1FBQ1IvQyxNQUFNK0M7SUFDUjtBQUNGO0FBQ0EsU0FBU0UsaUJBQWlCQyxJQUFJO0lBQzVCLE1BQU0sRUFDSnJELENBQUMsRUFDREMsQ0FBQyxFQUNEcUQsS0FBSyxFQUNMQyxNQUFNLEVBQ1AsR0FBR0Y7SUFDSixPQUFPO1FBQ0xDO1FBQ0FDO1FBQ0FqRCxLQUFLTDtRQUNMRSxNQUFNSDtRQUNOSSxPQUFPSixJQUFJc0Q7UUFDWGpELFFBQVFKLElBQUlzRDtRQUNadkQ7UUFDQUM7SUFDRjtBQUNGO0FBRXlXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWRtaXNzaW9uLXVwbGlmdC8uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvdXRpbHMvZGlzdC9mbG9hdGluZy11aS51dGlscy5tanM/NWFlYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEN1c3RvbSBwb3NpdGlvbmluZyByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy92aXJ0dWFsLWVsZW1lbnRzXG4gKi9cblxuY29uc3Qgc2lkZXMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuY29uc3QgYWxpZ25tZW50cyA9IFsnc3RhcnQnLCAnZW5kJ107XG5jb25zdCBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL3NpZGVzLnJlZHVjZSgoYWNjLCBzaWRlKSA9PiBhY2MuY29uY2F0KHNpZGUsIHNpZGUgKyBcIi1cIiArIGFsaWdubWVudHNbMF0sIHNpZGUgKyBcIi1cIiArIGFsaWdubWVudHNbMV0pLCBbXSk7XG5jb25zdCBtaW4gPSBNYXRoLm1pbjtcbmNvbnN0IG1heCA9IE1hdGgubWF4O1xuY29uc3Qgcm91bmQgPSBNYXRoLnJvdW5kO1xuY29uc3QgZmxvb3IgPSBNYXRoLmZsb29yO1xuY29uc3QgY3JlYXRlQ29vcmRzID0gdiA9PiAoe1xuICB4OiB2LFxuICB5OiB2XG59KTtcbmNvbnN0IG9wcG9zaXRlU2lkZU1hcCA9IHtcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgcmlnaHQ6ICdsZWZ0JyxcbiAgYm90dG9tOiAndG9wJyxcbiAgdG9wOiAnYm90dG9tJ1xufTtcbmNvbnN0IG9wcG9zaXRlQWxpZ25tZW50TWFwID0ge1xuICBzdGFydDogJ2VuZCcsXG4gIGVuZDogJ3N0YXJ0J1xufTtcbmZ1bmN0aW9uIGNsYW1wKHN0YXJ0LCB2YWx1ZSwgZW5kKSB7XG4gIHJldHVybiBtYXgoc3RhcnQsIG1pbih2YWx1ZSwgZW5kKSk7XG59XG5mdW5jdGlvbiBldmFsdWF0ZSh2YWx1ZSwgcGFyYW0pIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlKHBhcmFtKSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0U2lkZShwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufVxuZnVuY3Rpb24gZ2V0QXhpc0xlbmd0aChheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG59XG5mdW5jdGlvbiBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluY2x1ZGVzKGdldFNpZGUocGxhY2VtZW50KSkgPyAneScgOiAneCc7XG59XG5mdW5jdGlvbiBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCkge1xuICByZXR1cm4gZ2V0T3Bwb3NpdGVBeGlzKGdldFNpZGVBeGlzKHBsYWNlbWVudCkpO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50U2lkZXMocGxhY2VtZW50LCByZWN0cywgcnRsKSB7XG4gIGlmIChydGwgPT09IHZvaWQgMCkge1xuICAgIHJ0bCA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbm1lbnRBeGlzID0gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpO1xuICBjb25zdCBsZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGFsaWdubWVudEF4aXMpO1xuICBsZXQgbWFpbkFsaWdubWVudFNpZGUgPSBhbGlnbm1lbnRBeGlzID09PSAneCcgPyBhbGlnbm1lbnQgPT09IChydGwgPyAnZW5kJyA6ICdzdGFydCcpID8gJ3JpZ2h0JyA6ICdsZWZ0JyA6IGFsaWdubWVudCA9PT0gJ3N0YXJ0JyA/ICdib3R0b20nIDogJ3RvcCc7XG4gIGlmIChyZWN0cy5yZWZlcmVuY2VbbGVuZ3RoXSA+IHJlY3RzLmZsb2F0aW5nW2xlbmd0aF0pIHtcbiAgICBtYWluQWxpZ25tZW50U2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5BbGlnbm1lbnRTaWRlKTtcbiAgfVxuICByZXR1cm4gW21haW5BbGlnbm1lbnRTaWRlLCBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluQWxpZ25tZW50U2lkZSldO1xufVxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBjb25zdCBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHJldHVybiBbZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQocGxhY2VtZW50KSwgb3Bwb3NpdGVQbGFjZW1lbnQsIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KG9wcG9zaXRlUGxhY2VtZW50KV07XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgYWxpZ25tZW50ID0+IG9wcG9zaXRlQWxpZ25tZW50TWFwW2FsaWdubWVudF0pO1xufVxuZnVuY3Rpb24gZ2V0U2lkZUxpc3Qoc2lkZSwgaXNTdGFydCwgcnRsKSB7XG4gIGNvbnN0IGxyID0gWydsZWZ0JywgJ3JpZ2h0J107XG4gIGNvbnN0IHJsID0gWydyaWdodCcsICdsZWZ0J107XG4gIGNvbnN0IHRiID0gWyd0b3AnLCAnYm90dG9tJ107XG4gIGNvbnN0IGJ0ID0gWydib3R0b20nLCAndG9wJ107XG4gIHN3aXRjaCAoc2lkZSkge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIGlmIChydGwpIHJldHVybiBpc1N0YXJ0ID8gcmwgOiBscjtcbiAgICAgIHJldHVybiBpc1N0YXJ0ID8gbHIgOiBybDtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICByZXR1cm4gaXNTdGFydCA/IHRiIDogYnQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBbXTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyhwbGFjZW1lbnQsIGZsaXBBbGlnbm1lbnQsIGRpcmVjdGlvbiwgcnRsKSB7XG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICBsZXQgbGlzdCA9IGdldFNpZGVMaXN0KGdldFNpZGUocGxhY2VtZW50KSwgZGlyZWN0aW9uID09PSAnc3RhcnQnLCBydGwpO1xuICBpZiAoYWxpZ25tZW50KSB7XG4gICAgbGlzdCA9IGxpc3QubWFwKHNpZGUgPT4gc2lkZSArIFwiLVwiICsgYWxpZ25tZW50KTtcbiAgICBpZiAoZmxpcEFsaWdubWVudCkge1xuICAgICAgbGlzdCA9IGxpc3QuY29uY2F0KGxpc3QubWFwKGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsaXN0O1xufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIHNpZGUgPT4gb3Bwb3NpdGVTaWRlTWFwW3NpZGVdKTtcbn1cbmZ1bmN0aW9uIGV4cGFuZFBhZGRpbmdPYmplY3QocGFkZGluZykge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMCxcbiAgICAuLi5wYWRkaW5nXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IGV4cGFuZFBhZGRpbmdPYmplY3QocGFkZGluZykgOiB7XG4gICAgdG9wOiBwYWRkaW5nLFxuICAgIHJpZ2h0OiBwYWRkaW5nLFxuICAgIGJvdHRvbTogcGFkZGluZyxcbiAgICBsZWZ0OiBwYWRkaW5nXG4gIH07XG59XG5mdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgY29uc3Qge1xuICAgIHgsXG4gICAgeSxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IHJlY3Q7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHRvcDogeSxcbiAgICBsZWZ0OiB4LFxuICAgIHJpZ2h0OiB4ICsgd2lkdGgsXG4gICAgYm90dG9tOiB5ICsgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5leHBvcnQgeyBhbGlnbm1lbnRzLCBjbGFtcCwgY3JlYXRlQ29vcmRzLCBldmFsdWF0ZSwgZXhwYW5kUGFkZGluZ09iamVjdCwgZmxvb3IsIGdldEFsaWdubWVudCwgZ2V0QWxpZ25tZW50QXhpcywgZ2V0QWxpZ25tZW50U2lkZXMsIGdldEF4aXNMZW5ndGgsIGdldEV4cGFuZGVkUGxhY2VtZW50cywgZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQsIGdldE9wcG9zaXRlQXhpcywgZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cywgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQsIGdldFBhZGRpbmdPYmplY3QsIGdldFNpZGUsIGdldFNpZGVBeGlzLCBtYXgsIG1pbiwgcGxhY2VtZW50cywgcmVjdFRvQ2xpZW50UmVjdCwgcm91bmQsIHNpZGVzIH07XG4iXSwibmFtZXMiOlsic2lkZXMiLCJhbGlnbm1lbnRzIiwicGxhY2VtZW50cyIsInJlZHVjZSIsImFjYyIsInNpZGUiLCJjb25jYXQiLCJtaW4iLCJNYXRoIiwibWF4Iiwicm91bmQiLCJmbG9vciIsImNyZWF0ZUNvb3JkcyIsInYiLCJ4IiwieSIsIm9wcG9zaXRlU2lkZU1hcCIsImxlZnQiLCJyaWdodCIsImJvdHRvbSIsInRvcCIsIm9wcG9zaXRlQWxpZ25tZW50TWFwIiwic3RhcnQiLCJlbmQiLCJjbGFtcCIsInZhbHVlIiwiZXZhbHVhdGUiLCJwYXJhbSIsImdldFNpZGUiLCJwbGFjZW1lbnQiLCJzcGxpdCIsImdldEFsaWdubWVudCIsImdldE9wcG9zaXRlQXhpcyIsImF4aXMiLCJnZXRBeGlzTGVuZ3RoIiwiZ2V0U2lkZUF4aXMiLCJpbmNsdWRlcyIsImdldEFsaWdubWVudEF4aXMiLCJnZXRBbGlnbm1lbnRTaWRlcyIsInJlY3RzIiwicnRsIiwiYWxpZ25tZW50IiwiYWxpZ25tZW50QXhpcyIsImxlbmd0aCIsIm1haW5BbGlnbm1lbnRTaWRlIiwicmVmZXJlbmNlIiwiZmxvYXRpbmciLCJnZXRPcHBvc2l0ZVBsYWNlbWVudCIsImdldEV4cGFuZGVkUGxhY2VtZW50cyIsIm9wcG9zaXRlUGxhY2VtZW50IiwiZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQiLCJyZXBsYWNlIiwiZ2V0U2lkZUxpc3QiLCJpc1N0YXJ0IiwibHIiLCJybCIsInRiIiwiYnQiLCJnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzIiwiZmxpcEFsaWdubWVudCIsImRpcmVjdGlvbiIsImxpc3QiLCJtYXAiLCJleHBhbmRQYWRkaW5nT2JqZWN0IiwicGFkZGluZyIsImdldFBhZGRpbmdPYmplY3QiLCJyZWN0VG9DbGllbnRSZWN0IiwicmVjdCIsIndpZHRoIiwiaGVpZ2h0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\n");

/***/ })

};
;