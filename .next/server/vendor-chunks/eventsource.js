/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/eventsource";
exports.ids = ["vendor-chunks/eventsource"];
exports.modules = {

/***/ "(ssr)/./node_modules/eventsource/lib/eventsource.js":
/*!*****************************************************!*\
  !*** ./node_modules/eventsource/lib/eventsource.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var parse = (__webpack_require__(/*! url */ \"url\").parse);\nvar events = __webpack_require__(/*! events */ \"events\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar http = __webpack_require__(/*! http */ \"http\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar httpsOptions = [\n    \"pfx\",\n    \"key\",\n    \"passphrase\",\n    \"cert\",\n    \"ca\",\n    \"ciphers\",\n    \"rejectUnauthorized\",\n    \"secureProtocol\",\n    \"servername\",\n    \"checkServerIdentity\"\n];\nvar bom = [\n    239,\n    187,\n    191\n];\nvar colon = 58;\nvar space = 32;\nvar lineFeed = 10;\nvar carriageReturn = 13;\n// Beyond 256KB we could not observe any gain in performance\nvar maxBufferAheadAllocation = 1024 * 256;\n// Headers matching the pattern should be removed when redirecting to different origin\nvar reUnsafeHeader = /^(cookie|authorization)$/i;\nfunction hasBom(buf) {\n    return bom.every(function(charCode, index) {\n        return buf[index] === charCode;\n    });\n}\n/**\n * Creates a new EventSource object\n *\n * @param {String} url the URL to which to connect\n * @param {Object} [eventSourceInitDict] extra init params. See README for details.\n * @api public\n **/ function EventSource(url, eventSourceInitDict) {\n    var readyState = EventSource.CONNECTING;\n    var headers = eventSourceInitDict && eventSourceInitDict.headers;\n    var hasNewOrigin = false;\n    Object.defineProperty(this, \"readyState\", {\n        get: function() {\n            return readyState;\n        }\n    });\n    Object.defineProperty(this, \"url\", {\n        get: function() {\n            return url;\n        }\n    });\n    var self = this;\n    self.reconnectInterval = 1000;\n    self.connectionInProgress = false;\n    function onConnectionClosed(message) {\n        if (readyState === EventSource.CLOSED) return;\n        readyState = EventSource.CONNECTING;\n        _emit(\"error\", new Event(\"error\", {\n            message: message\n        }));\n        // The url may have been changed by a temporary redirect. If that's the case,\n        // revert it now, and flag that we are no longer pointing to a new origin\n        if (reconnectUrl) {\n            url = reconnectUrl;\n            reconnectUrl = null;\n            hasNewOrigin = false;\n        }\n        setTimeout(function() {\n            if (readyState !== EventSource.CONNECTING || self.connectionInProgress) {\n                return;\n            }\n            self.connectionInProgress = true;\n            connect();\n        }, self.reconnectInterval);\n    }\n    var req;\n    var lastEventId = \"\";\n    if (headers && headers[\"Last-Event-ID\"]) {\n        lastEventId = headers[\"Last-Event-ID\"];\n        delete headers[\"Last-Event-ID\"];\n    }\n    var discardTrailingNewline = false;\n    var data = \"\";\n    var eventName = \"\";\n    var reconnectUrl = null;\n    function connect() {\n        var options = parse(url);\n        var isSecure = options.protocol === \"https:\";\n        options.headers = {\n            \"Cache-Control\": \"no-cache\",\n            \"Accept\": \"text/event-stream\"\n        };\n        if (lastEventId) options.headers[\"Last-Event-ID\"] = lastEventId;\n        if (headers) {\n            var reqHeaders = hasNewOrigin ? removeUnsafeHeaders(headers) : headers;\n            for(var i in reqHeaders){\n                var header = reqHeaders[i];\n                if (header) {\n                    options.headers[i] = header;\n                }\n            }\n        }\n        // Legacy: this should be specified as `eventSourceInitDict.https.rejectUnauthorized`,\n        // but for now exists as a backwards-compatibility layer\n        options.rejectUnauthorized = !(eventSourceInitDict && !eventSourceInitDict.rejectUnauthorized);\n        if (eventSourceInitDict && eventSourceInitDict.createConnection !== undefined) {\n            options.createConnection = eventSourceInitDict.createConnection;\n        }\n        // If specify http proxy, make the request to sent to the proxy server,\n        // and include the original url in path and Host headers\n        var useProxy = eventSourceInitDict && eventSourceInitDict.proxy;\n        if (useProxy) {\n            var proxy = parse(eventSourceInitDict.proxy);\n            isSecure = proxy.protocol === \"https:\";\n            options.protocol = isSecure ? \"https:\" : \"http:\";\n            options.path = url;\n            options.headers.Host = options.host;\n            options.hostname = proxy.hostname;\n            options.host = proxy.host;\n            options.port = proxy.port;\n        }\n        // If https options are specified, merge them into the request options\n        if (eventSourceInitDict && eventSourceInitDict.https) {\n            for(var optName in eventSourceInitDict.https){\n                if (httpsOptions.indexOf(optName) === -1) {\n                    continue;\n                }\n                var option = eventSourceInitDict.https[optName];\n                if (option !== undefined) {\n                    options[optName] = option;\n                }\n            }\n        }\n        // Pass this on to the XHR\n        if (eventSourceInitDict && eventSourceInitDict.withCredentials !== undefined) {\n            options.withCredentials = eventSourceInitDict.withCredentials;\n        }\n        req = (isSecure ? https : http).request(options, function(res) {\n            self.connectionInProgress = false;\n            // Handle HTTP errors\n            if (res.statusCode === 500 || res.statusCode === 502 || res.statusCode === 503 || res.statusCode === 504) {\n                _emit(\"error\", new Event(\"error\", {\n                    status: res.statusCode,\n                    message: res.statusMessage\n                }));\n                onConnectionClosed();\n                return;\n            }\n            // Handle HTTP redirects\n            if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                var location = res.headers.location;\n                if (!location) {\n                    // Server sent redirect response without Location header.\n                    _emit(\"error\", new Event(\"error\", {\n                        status: res.statusCode,\n                        message: res.statusMessage\n                    }));\n                    return;\n                }\n                var prevOrigin = new URL(url).origin;\n                var nextOrigin = new URL(location).origin;\n                hasNewOrigin = prevOrigin !== nextOrigin;\n                if (res.statusCode === 307) reconnectUrl = url;\n                url = location;\n                process.nextTick(connect);\n                return;\n            }\n            if (res.statusCode !== 200) {\n                _emit(\"error\", new Event(\"error\", {\n                    status: res.statusCode,\n                    message: res.statusMessage\n                }));\n                return self.close();\n            }\n            readyState = EventSource.OPEN;\n            res.on(\"close\", function() {\n                res.removeAllListeners(\"close\");\n                res.removeAllListeners(\"end\");\n                onConnectionClosed();\n            });\n            res.on(\"end\", function() {\n                res.removeAllListeners(\"close\");\n                res.removeAllListeners(\"end\");\n                onConnectionClosed();\n            });\n            _emit(\"open\", new Event(\"open\"));\n            // text/event-stream parser adapted from webkit's\n            // Source/WebCore/page/EventSource.cpp\n            var buf;\n            var newBuffer;\n            var startingPos = 0;\n            var startingFieldLength = -1;\n            var newBufferSize = 0;\n            var bytesUsed = 0;\n            res.on(\"data\", function(chunk) {\n                if (!buf) {\n                    buf = chunk;\n                    if (hasBom(buf)) {\n                        buf = buf.slice(bom.length);\n                    }\n                    bytesUsed = buf.length;\n                } else {\n                    if (chunk.length > buf.length - bytesUsed) {\n                        newBufferSize = buf.length * 2 + chunk.length;\n                        if (newBufferSize > maxBufferAheadAllocation) {\n                            newBufferSize = buf.length + chunk.length + maxBufferAheadAllocation;\n                        }\n                        newBuffer = Buffer.alloc(newBufferSize);\n                        buf.copy(newBuffer, 0, 0, bytesUsed);\n                        buf = newBuffer;\n                    }\n                    chunk.copy(buf, bytesUsed);\n                    bytesUsed += chunk.length;\n                }\n                var pos = 0;\n                var length = bytesUsed;\n                while(pos < length){\n                    if (discardTrailingNewline) {\n                        if (buf[pos] === lineFeed) {\n                            ++pos;\n                        }\n                        discardTrailingNewline = false;\n                    }\n                    var lineLength = -1;\n                    var fieldLength = startingFieldLength;\n                    var c;\n                    for(var i = startingPos; lineLength < 0 && i < length; ++i){\n                        c = buf[i];\n                        if (c === colon) {\n                            if (fieldLength < 0) {\n                                fieldLength = i - pos;\n                            }\n                        } else if (c === carriageReturn) {\n                            discardTrailingNewline = true;\n                            lineLength = i - pos;\n                        } else if (c === lineFeed) {\n                            lineLength = i - pos;\n                        }\n                    }\n                    if (lineLength < 0) {\n                        startingPos = length - pos;\n                        startingFieldLength = fieldLength;\n                        break;\n                    } else {\n                        startingPos = 0;\n                        startingFieldLength = -1;\n                    }\n                    parseEventStreamLine(buf, pos, fieldLength, lineLength);\n                    pos += lineLength + 1;\n                }\n                if (pos === length) {\n                    buf = void 0;\n                    bytesUsed = 0;\n                } else if (pos > 0) {\n                    buf = buf.slice(pos, bytesUsed);\n                    bytesUsed = buf.length;\n                }\n            });\n        });\n        req.on(\"error\", function(err) {\n            self.connectionInProgress = false;\n            onConnectionClosed(err.message);\n        });\n        if (req.setNoDelay) req.setNoDelay(true);\n        req.end();\n    }\n    connect();\n    function _emit() {\n        if (self.listeners(arguments[0]).length > 0) {\n            self.emit.apply(self, arguments);\n        }\n    }\n    this._close = function() {\n        if (readyState === EventSource.CLOSED) return;\n        readyState = EventSource.CLOSED;\n        if (req.abort) req.abort();\n        if (req.xhr && req.xhr.abort) req.xhr.abort();\n    };\n    function parseEventStreamLine(buf, pos, fieldLength, lineLength) {\n        if (lineLength === 0) {\n            if (data.length > 0) {\n                var type = eventName || \"message\";\n                _emit(type, new MessageEvent(type, {\n                    data: data.slice(0, -1),\n                    lastEventId: lastEventId,\n                    origin: new URL(url).origin\n                }));\n                data = \"\";\n            }\n            eventName = void 0;\n        } else if (fieldLength > 0) {\n            var noValue = fieldLength < 0;\n            var step = 0;\n            var field = buf.slice(pos, pos + (noValue ? lineLength : fieldLength)).toString();\n            if (noValue) {\n                step = lineLength;\n            } else if (buf[pos + fieldLength + 1] !== space) {\n                step = fieldLength + 1;\n            } else {\n                step = fieldLength + 2;\n            }\n            pos += step;\n            var valueLength = lineLength - step;\n            var value = buf.slice(pos, pos + valueLength).toString();\n            if (field === \"data\") {\n                data += value + \"\\n\";\n            } else if (field === \"event\") {\n                eventName = value;\n            } else if (field === \"id\") {\n                lastEventId = value;\n            } else if (field === \"retry\") {\n                var retry = parseInt(value, 10);\n                if (!Number.isNaN(retry)) {\n                    self.reconnectInterval = retry;\n                }\n            }\n        }\n    }\n}\nmodule.exports = EventSource;\nutil.inherits(EventSource, events.EventEmitter);\nEventSource.prototype.constructor = EventSource; // make stacktraces readable\n[\n    \"open\",\n    \"error\",\n    \"message\"\n].forEach(function(method) {\n    Object.defineProperty(EventSource.prototype, \"on\" + method, {\n        /**\n     * Returns the current listener\n     *\n     * @return {Mixed} the set function or undefined\n     * @api private\n     */ get: function get() {\n            var listener = this.listeners(method)[0];\n            return listener ? listener._listener ? listener._listener : listener : undefined;\n        },\n        /**\n     * Start listening for events\n     *\n     * @param {Function} listener the listener\n     * @return {Mixed} the set function or undefined\n     * @api private\n     */ set: function set(listener) {\n            this.removeAllListeners(method);\n            this.addEventListener(method, listener);\n        }\n    });\n});\n/**\n * Ready states\n */ Object.defineProperty(EventSource, \"CONNECTING\", {\n    enumerable: true,\n    value: 0\n});\nObject.defineProperty(EventSource, \"OPEN\", {\n    enumerable: true,\n    value: 1\n});\nObject.defineProperty(EventSource, \"CLOSED\", {\n    enumerable: true,\n    value: 2\n});\nEventSource.prototype.CONNECTING = 0;\nEventSource.prototype.OPEN = 1;\nEventSource.prototype.CLOSED = 2;\n/**\n * Closes the connection, if one is made, and sets the readyState attribute to 2 (closed)\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventSource/close\n * @api public\n */ EventSource.prototype.close = function() {\n    this._close();\n};\n/**\n * Emulates the W3C Browser based WebSocket interface using addEventListener.\n *\n * @param {String} type A string representing the event type to listen out for\n * @param {Function} listener callback\n * @see https://developer.mozilla.org/en/DOM/element.addEventListener\n * @see http://dev.w3.org/html5/websockets/#the-websocket-interface\n * @api public\n */ EventSource.prototype.addEventListener = function addEventListener(type, listener) {\n    if (typeof listener === \"function\") {\n        // store a reference so we can return the original function again\n        listener._listener = listener;\n        this.on(type, listener);\n    }\n};\n/**\n * Emulates the W3C Browser based WebSocket interface using dispatchEvent.\n *\n * @param {Event} event An event to be dispatched\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent\n * @api public\n */ EventSource.prototype.dispatchEvent = function dispatchEvent(event) {\n    if (!event.type) {\n        throw new Error(\"UNSPECIFIED_EVENT_TYPE_ERR\");\n    }\n    // if event is instance of an CustomEvent (or has 'details' property),\n    // send the detail object as the payload for the event\n    this.emit(event.type, event.detail);\n};\n/**\n * Emulates the W3C Browser based WebSocket interface using removeEventListener.\n *\n * @param {String} type A string representing the event type to remove\n * @param {Function} listener callback\n * @see https://developer.mozilla.org/en/DOM/element.removeEventListener\n * @see http://dev.w3.org/html5/websockets/#the-websocket-interface\n * @api public\n */ EventSource.prototype.removeEventListener = function removeEventListener(type, listener) {\n    if (typeof listener === \"function\") {\n        listener._listener = undefined;\n        this.removeListener(type, listener);\n    }\n};\n/**\n * W3C Event\n *\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#interface-Event\n * @api private\n */ function Event(type, optionalProperties) {\n    Object.defineProperty(this, \"type\", {\n        writable: false,\n        value: type,\n        enumerable: true\n    });\n    if (optionalProperties) {\n        for(var f in optionalProperties){\n            if (optionalProperties.hasOwnProperty(f)) {\n                Object.defineProperty(this, f, {\n                    writable: false,\n                    value: optionalProperties[f],\n                    enumerable: true\n                });\n            }\n        }\n    }\n}\n/**\n * W3C MessageEvent\n *\n * @see http://www.w3.org/TR/webmessaging/#event-definitions\n * @api private\n */ function MessageEvent(type, eventInitDict) {\n    Object.defineProperty(this, \"type\", {\n        writable: false,\n        value: type,\n        enumerable: true\n    });\n    for(var f in eventInitDict){\n        if (eventInitDict.hasOwnProperty(f)) {\n            Object.defineProperty(this, f, {\n                writable: false,\n                value: eventInitDict[f],\n                enumerable: true\n            });\n        }\n    }\n}\n/**\n * Returns a new object of headers that does not include any authorization and cookie headers\n *\n * @param {Object} headers An object of headers ({[headerName]: headerValue})\n * @return {Object} a new object of headers\n * @api private\n */ function removeUnsafeHeaders(headers) {\n    var safe = {};\n    for(var key in headers){\n        if (reUnsafeHeader.test(key)) {\n            continue;\n        }\n        safe[key] = headers[key];\n    }\n    return safe;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXZlbnRzb3VyY2UvbGliL2V2ZW50c291cmNlLmpzIiwibWFwcGluZ3MiOiJBQUFBLElBQUlBLFFBQVFDLDZDQUFvQjtBQUNoQyxJQUFJQyxTQUFTRCxtQkFBT0EsQ0FBQztBQUNyQixJQUFJRSxRQUFRRixtQkFBT0EsQ0FBQztBQUNwQixJQUFJRyxPQUFPSCxtQkFBT0EsQ0FBQztBQUNuQixJQUFJSSxPQUFPSixtQkFBT0EsQ0FBQztBQUVuQixJQUFJSyxlQUFlO0lBQ2pCO0lBQU87SUFBTztJQUFjO0lBQVE7SUFBTTtJQUMxQztJQUFzQjtJQUFrQjtJQUFjO0NBQ3ZEO0FBRUQsSUFBSUMsTUFBTTtJQUFDO0lBQUs7SUFBSztDQUFJO0FBQ3pCLElBQUlDLFFBQVE7QUFDWixJQUFJQyxRQUFRO0FBQ1osSUFBSUMsV0FBVztBQUNmLElBQUlDLGlCQUFpQjtBQUNyQiw0REFBNEQ7QUFDNUQsSUFBSUMsMkJBQTJCLE9BQU87QUFDdEMsc0ZBQXNGO0FBQ3RGLElBQUlDLGlCQUFpQjtBQUVyQixTQUFTQyxPQUFRQyxHQUFHO0lBQ2xCLE9BQU9SLElBQUlTLEtBQUssQ0FBQyxTQUFVQyxRQUFRLEVBQUVDLEtBQUs7UUFDeEMsT0FBT0gsR0FBRyxDQUFDRyxNQUFNLEtBQUtEO0lBQ3hCO0FBQ0Y7QUFFQTs7Ozs7O0VBTUUsR0FDRixTQUFTRSxZQUFhQyxHQUFHLEVBQUVDLG1CQUFtQjtJQUM1QyxJQUFJQyxhQUFhSCxZQUFZSSxVQUFVO0lBQ3ZDLElBQUlDLFVBQVVILHVCQUF1QkEsb0JBQW9CRyxPQUFPO0lBQ2hFLElBQUlDLGVBQWU7SUFDbkJDLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsY0FBYztRQUN4Q0MsS0FBSztZQUNILE9BQU9OO1FBQ1Q7SUFDRjtJQUVBSSxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLE9BQU87UUFDakNDLEtBQUs7WUFDSCxPQUFPUjtRQUNUO0lBQ0Y7SUFFQSxJQUFJUyxPQUFPLElBQUk7SUFDZkEs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QUFFaUgsVUFBVTtRQUFPekIsT0FBT1A7UUFBTXdCLFlBQVk7SUFBSztJQUNyRixJQUFLLElBQUlTLEtBQUtFLGNBQWU7UUFDM0IsSUFBSUEsY0FBY0QsY0FBYyxDQUFDRCxJQUFJO1lBQ25DbkgsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRWtILEdBQUc7Z0JBQUVELFVBQVU7Z0JBQU96QixPQUFPNEIsYUFBYSxDQUFDRixFQUFFO2dCQUFFVCxZQUFZO1lBQUs7UUFDOUY7SUFDRjtBQUNGO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU25GLG9CQUFxQnpCLE9BQU87SUFDbkMsSUFBSXdILE9BQU8sQ0FBQztJQUNaLElBQUssSUFBSUMsT0FBT3pILFFBQVM7UUFDdkIsSUFBSVgsZUFBZXFJLElBQUksQ0FBQ0QsTUFBTTtZQUM1QjtRQUNGO1FBRUFELElBQUksQ0FBQ0MsSUFBSSxHQUFHekgsT0FBTyxDQUFDeUgsSUFBSTtJQUMxQjtJQUVBLE9BQU9EO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZG1pc3Npb24tdXBsaWZ0Ly4vbm9kZV9tb2R1bGVzL2V2ZW50c291cmNlL2xpYi9ldmVudHNvdXJjZS5qcz9kZDJlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBwYXJzZSA9IHJlcXVpcmUoJ3VybCcpLnBhcnNlXG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJylcbnZhciBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJylcbnZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuXG52YXIgaHR0cHNPcHRpb25zID0gW1xuICAncGZ4JywgJ2tleScsICdwYXNzcGhyYXNlJywgJ2NlcnQnLCAnY2EnLCAnY2lwaGVycycsXG4gICdyZWplY3RVbmF1dGhvcml6ZWQnLCAnc2VjdXJlUHJvdG9jb2wnLCAnc2VydmVybmFtZScsICdjaGVja1NlcnZlcklkZW50aXR5J1xuXVxuXG52YXIgYm9tID0gWzIzOSwgMTg3LCAxOTFdXG52YXIgY29sb24gPSA1OFxudmFyIHNwYWNlID0gMzJcbnZhciBsaW5lRmVlZCA9IDEwXG52YXIgY2FycmlhZ2VSZXR1cm4gPSAxM1xuLy8gQmV5b25kIDI1NktCIHdlIGNvdWxkIG5vdCBvYnNlcnZlIGFueSBnYWluIGluIHBlcmZvcm1hbmNlXG52YXIgbWF4QnVmZmVyQWhlYWRBbGxvY2F0aW9uID0gMTAyNCAqIDI1NlxuLy8gSGVhZGVycyBtYXRjaGluZyB0aGUgcGF0dGVybiBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHJlZGlyZWN0aW5nIHRvIGRpZmZlcmVudCBvcmlnaW5cbnZhciByZVVuc2FmZUhlYWRlciA9IC9eKGNvb2tpZXxhdXRob3JpemF0aW9uKSQvaVxuXG5mdW5jdGlvbiBoYXNCb20gKGJ1Zikge1xuICByZXR1cm4gYm9tLmV2ZXJ5KGZ1bmN0aW9uIChjaGFyQ29kZSwgaW5kZXgpIHtcbiAgICByZXR1cm4gYnVmW2luZGV4XSA9PT0gY2hhckNvZGVcbiAgfSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEV2ZW50U291cmNlIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgdGhlIFVSTCB0byB3aGljaCB0byBjb25uZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gW2V2ZW50U291cmNlSW5pdERpY3RdIGV4dHJhIGluaXQgcGFyYW1zLiBTZWUgUkVBRE1FIGZvciBkZXRhaWxzLlxuICogQGFwaSBwdWJsaWNcbiAqKi9cbmZ1bmN0aW9uIEV2ZW50U291cmNlICh1cmwsIGV2ZW50U291cmNlSW5pdERpY3QpIHtcbiAgdmFyIHJlYWR5U3RhdGUgPSBFdmVudFNvdXJjZS5DT05ORUNUSU5HXG4gIHZhciBoZWFkZXJzID0gZXZlbnRTb3VyY2VJbml0RGljdCAmJiBldmVudFNvdXJjZUluaXREaWN0LmhlYWRlcnNcbiAgdmFyIGhhc05ld09yaWdpbiA9IGZhbHNlXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVhZHlTdGF0ZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZWFkeVN0YXRlXG4gICAgfVxuICB9KVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndXJsJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHVybFxuICAgIH1cbiAgfSlcblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5yZWNvbm5lY3RJbnRlcnZhbCA9IDEwMDBcbiAgc2VsZi5jb25uZWN0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlXG5cbiAgZnVuY3Rpb24gb25Db25uZWN0aW9uQ2xvc2VkIChtZXNzYWdlKSB7XG4gICAgaWYgKHJlYWR5U3RhdGUgPT09IEV2ZW50U291cmNlLkNMT1NFRCkgcmV0dXJuXG4gICAgcmVhZHlTdGF0ZSA9IEV2ZW50U291cmNlLkNPTk5FQ1RJTkdcbiAgICBfZW1pdCgnZXJyb3InLCBuZXcgRXZlbnQoJ2Vycm9yJywge21lc3NhZ2U6IG1lc3NhZ2V9KSlcblxuICAgIC8vIFRoZSB1cmwgbWF5IGhhdmUgYmVlbiBjaGFuZ2VkIGJ5IGEgdGVtcG9yYXJ5IHJlZGlyZWN0LiBJZiB0aGF0J3MgdGhlIGNhc2UsXG4gICAgLy8gcmV2ZXJ0IGl0IG5vdywgYW5kIGZsYWcgdGhhdCB3ZSBhcmUgbm8gbG9uZ2VyIHBvaW50aW5nIHRvIGEgbmV3IG9yaWdpblxuICAgIGlmIChyZWNvbm5lY3RVcmwpIHtcbiAgICAgIHVybCA9IHJlY29ubmVjdFVybFxuICAgICAgcmVjb25uZWN0VXJsID0gbnVsbFxuICAgICAgaGFzTmV3T3JpZ2luID0gZmFsc2VcbiAgICB9XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocmVhZHlTdGF0ZSAhPT0gRXZlbnRTb3VyY2UuQ09OTkVDVElORyB8fCBzZWxmLmNvbm5lY3Rpb25JblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgc2VsZi5jb25uZWN0aW9uSW5Qcm9ncmVzcyA9IHRydWVcbiAgICAgIGNvbm5lY3QoKVxuICAgIH0sIHNlbGYucmVjb25uZWN0SW50ZXJ2YWwpXG4gIH1cblxuICB2YXIgcmVxXG4gIHZhciBsYXN0RXZlbnRJZCA9ICcnXG4gIGlmIChoZWFkZXJzICYmIGhlYWRlcnNbJ0xhc3QtRXZlbnQtSUQnXSkge1xuICAgIGxhc3RFdmVudElkID0gaGVhZGVyc1snTGFzdC1FdmVudC1JRCddXG4gICAgZGVsZXRlIGhlYWRlcnNbJ0xhc3QtRXZlbnQtSUQnXVxuICB9XG5cbiAgdmFyIGRpc2NhcmRUcmFpbGluZ05ld2xpbmUgPSBmYWxzZVxuICB2YXIgZGF0YSA9ICcnXG4gIHZhciBldmVudE5hbWUgPSAnJ1xuXG4gIHZhciByZWNvbm5lY3RVcmwgPSBudWxsXG5cbiAgZnVuY3Rpb24gY29ubmVjdCAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBwYXJzZSh1cmwpXG4gICAgdmFyIGlzU2VjdXJlID0gb3B0aW9ucy5wcm90b2NvbCA9PT0gJ2h0dHBzOidcbiAgICBvcHRpb25zLmhlYWRlcnMgPSB7ICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlJywgJ0FjY2VwdCc6ICd0ZXh0L2V2ZW50LXN0cmVhbScgfVxuICAgIGlmIChsYXN0RXZlbnRJZCkgb3B0aW9ucy5oZWFkZXJzWydMYXN0LUV2ZW50LUlEJ10gPSBsYXN0RXZlbnRJZFxuICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICB2YXIgcmVxSGVhZGVycyA9IGhhc05ld09yaWdpbiA/IHJlbW92ZVVuc2FmZUhlYWRlcnMoaGVhZGVycykgOiBoZWFkZXJzXG4gICAgICBmb3IgKHZhciBpIGluIHJlcUhlYWRlcnMpIHtcbiAgICAgICAgdmFyIGhlYWRlciA9IHJlcUhlYWRlcnNbaV1cbiAgICAgICAgaWYgKGhlYWRlcikge1xuICAgICAgICAgIG9wdGlvbnMuaGVhZGVyc1tpXSA9IGhlYWRlclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5OiB0aGlzIHNob3VsZCBiZSBzcGVjaWZpZWQgYXMgYGV2ZW50U291cmNlSW5pdERpY3QuaHR0cHMucmVqZWN0VW5hdXRob3JpemVkYCxcbiAgICAvLyBidXQgZm9yIG5vdyBleGlzdHMgYXMgYSBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBsYXllclxuICAgIG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkID0gIShldmVudFNvdXJjZUluaXREaWN0ICYmICFldmVudFNvdXJjZUluaXREaWN0LnJlamVjdFVuYXV0aG9yaXplZClcblxuICAgIGlmIChldmVudFNvdXJjZUluaXREaWN0ICYmIGV2ZW50U291cmNlSW5pdERpY3QuY3JlYXRlQ29ubmVjdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zLmNyZWF0ZUNvbm5lY3Rpb24gPSBldmVudFNvdXJjZUluaXREaWN0LmNyZWF0ZUNvbm5lY3Rpb25cbiAgICB9XG5cbiAgICAvLyBJZiBzcGVjaWZ5IGh0dHAgcHJveHksIG1ha2UgdGhlIHJlcXVlc3QgdG8gc2VudCB0byB0aGUgcHJveHkgc2VydmVyLFxuICAgIC8vIGFuZCBpbmNsdWRlIHRoZSBvcmlnaW5hbCB1cmwgaW4gcGF0aCBhbmQgSG9zdCBoZWFkZXJzXG4gICAgdmFyIHVzZVByb3h5ID0gZXZlbnRTb3VyY2VJbml0RGljdCAmJiBldmVudFNvdXJjZUluaXREaWN0LnByb3h5XG4gICAgaWYgKHVzZVByb3h5KSB7XG4gICAgICB2YXIgcHJveHkgPSBwYXJzZShldmVudFNvdXJjZUluaXREaWN0LnByb3h5KVxuICAgICAgaXNTZWN1cmUgPSBwcm94eS5wcm90b2NvbCA9PT0gJ2h0dHBzOidcblxuICAgICAgb3B0aW9ucy5wcm90b2NvbCA9IGlzU2VjdXJlID8gJ2h0dHBzOicgOiAnaHR0cDonXG4gICAgICBvcHRpb25zLnBhdGggPSB1cmxcbiAgICAgIG9wdGlvbnMuaGVhZGVycy5Ib3N0ID0gb3B0aW9ucy5ob3N0XG4gICAgICBvcHRpb25zLmhvc3RuYW1lID0gcHJveHkuaG9zdG5hbWVcbiAgICAgIG9wdGlvbnMuaG9zdCA9IHByb3h5Lmhvc3RcbiAgICAgIG9wdGlvbnMucG9ydCA9IHByb3h5LnBvcnRcbiAgICB9XG5cbiAgICAvLyBJZiBodHRwcyBvcHRpb25zIGFyZSBzcGVjaWZpZWQsIG1lcmdlIHRoZW0gaW50byB0aGUgcmVxdWVzdCBvcHRpb25zXG4gICAgaWYgKGV2ZW50U291cmNlSW5pdERpY3QgJiYgZXZlbnRTb3VyY2VJbml0RGljdC5odHRwcykge1xuICAgICAgZm9yICh2YXIgb3B0TmFtZSBpbiBldmVudFNvdXJjZUluaXREaWN0Lmh0dHBzKSB7XG4gICAgICAgIGlmIChodHRwc09wdGlvbnMuaW5kZXhPZihvcHROYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wdGlvbiA9IGV2ZW50U291cmNlSW5pdERpY3QuaHR0cHNbb3B0TmFtZV1cbiAgICAgICAgaWYgKG9wdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3B0aW9uc1tvcHROYW1lXSA9IG9wdGlvblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGFzcyB0aGlzIG9uIHRvIHRoZSBYSFJcbiAgICBpZiAoZXZlbnRTb3VyY2VJbml0RGljdCAmJiBldmVudFNvdXJjZUluaXREaWN0LndpdGhDcmVkZW50aWFscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zLndpdGhDcmVkZW50aWFscyA9IGV2ZW50U291cmNlSW5pdERpY3Qud2l0aENyZWRlbnRpYWxzXG4gICAgfVxuXG4gICAgcmVxID0gKGlzU2VjdXJlID8gaHR0cHMgOiBodHRwKS5yZXF1ZXN0KG9wdGlvbnMsIGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIHNlbGYuY29ubmVjdGlvbkluUHJvZ3Jlc3MgPSBmYWxzZVxuICAgICAgLy8gSGFuZGxlIEhUVFAgZXJyb3JzXG4gICAgICBpZiAocmVzLnN0YXR1c0NvZGUgPT09IDUwMCB8fCByZXMuc3RhdHVzQ29kZSA9PT0gNTAyIHx8IHJlcy5zdGF0dXNDb2RlID09PSA1MDMgfHwgcmVzLnN0YXR1c0NvZGUgPT09IDUwNCkge1xuICAgICAgICBfZW1pdCgnZXJyb3InLCBuZXcgRXZlbnQoJ2Vycm9yJywge3N0YXR1czogcmVzLnN0YXR1c0NvZGUsIG1lc3NhZ2U6IHJlcy5zdGF0dXNNZXNzYWdlfSkpXG4gICAgICAgIG9uQ29ubmVjdGlvbkNsb3NlZCgpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBIYW5kbGUgSFRUUCByZWRpcmVjdHNcbiAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA9PT0gMzAxIHx8IHJlcy5zdGF0dXNDb2RlID09PSAzMDIgfHwgcmVzLnN0YXR1c0NvZGUgPT09IDMwNykge1xuICAgICAgICB2YXIgbG9jYXRpb24gPSByZXMuaGVhZGVycy5sb2NhdGlvblxuICAgICAgICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgICAgICAgLy8gU2VydmVyIHNlbnQgcmVkaXJlY3QgcmVzcG9uc2Ugd2l0aG91dCBMb2NhdGlvbiBoZWFkZXIuXG4gICAgICAgICAgX2VtaXQoJ2Vycm9yJywgbmV3IEV2ZW50KCdlcnJvcicsIHtzdGF0dXM6IHJlcy5zdGF0dXNDb2RlLCBtZXNzYWdlOiByZXMuc3RhdHVzTWVzc2FnZX0pKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2T3JpZ2luID0gbmV3IFVSTCh1cmwpLm9yaWdpblxuICAgICAgICB2YXIgbmV4dE9yaWdpbiA9IG5ldyBVUkwobG9jYXRpb24pLm9yaWdpblxuICAgICAgICBoYXNOZXdPcmlnaW4gPSBwcmV2T3JpZ2luICE9PSBuZXh0T3JpZ2luXG4gICAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA9PT0gMzA3KSByZWNvbm5lY3RVcmwgPSB1cmxcbiAgICAgICAgdXJsID0gbG9jYXRpb25cbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhjb25uZWN0KVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlICE9PSAyMDApIHtcbiAgICAgICAgX2VtaXQoJ2Vycm9yJywgbmV3IEV2ZW50KCdlcnJvcicsIHtzdGF0dXM6IHJlcy5zdGF0dXNDb2RlLCBtZXNzYWdlOiByZXMuc3RhdHVzTWVzc2FnZX0pKVxuICAgICAgICByZXR1cm4gc2VsZi5jbG9zZSgpXG4gICAgICB9XG5cbiAgICAgIHJlYWR5U3RhdGUgPSBFdmVudFNvdXJjZS5PUEVOXG4gICAgICByZXMub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdjbG9zZScpXG4gICAgICAgIHJlcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2VuZCcpXG4gICAgICAgIG9uQ29ubmVjdGlvbkNsb3NlZCgpXG4gICAgICB9KVxuXG4gICAgICByZXMub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVzLnJlbW92ZUFsbExpc3RlbmVycygnY2xvc2UnKVxuICAgICAgICByZXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdlbmQnKVxuICAgICAgICBvbkNvbm5lY3Rpb25DbG9zZWQoKVxuICAgICAgfSlcbiAgICAgIF9lbWl0KCdvcGVuJywgbmV3IEV2ZW50KCdvcGVuJykpXG5cbiAgICAgIC8vIHRleHQvZXZlbnQtc3RyZWFtIHBhcnNlciBhZGFwdGVkIGZyb20gd2Via2l0J3NcbiAgICAgIC8vIFNvdXJjZS9XZWJDb3JlL3BhZ2UvRXZlbnRTb3VyY2UuY3BwXG4gICAgICB2YXIgYnVmXG4gICAgICB2YXIgbmV3QnVmZmVyXG4gICAgICB2YXIgc3RhcnRpbmdQb3MgPSAwXG4gICAgICB2YXIgc3RhcnRpbmdGaWVsZExlbmd0aCA9IC0xXG4gICAgICB2YXIgbmV3QnVmZmVyU2l6ZSA9IDBcbiAgICAgIHZhciBieXRlc1VzZWQgPSAwXG5cbiAgICAgIHJlcy5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICBpZiAoIWJ1Zikge1xuICAgICAgICAgIGJ1ZiA9IGNodW5rXG4gICAgICAgICAgaWYgKGhhc0JvbShidWYpKSB7XG4gICAgICAgICAgICBidWYgPSBidWYuc2xpY2UoYm9tLmxlbmd0aClcbiAgICAgICAgICB9XG4gICAgICAgICAgYnl0ZXNVc2VkID0gYnVmLmxlbmd0aFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjaHVuay5sZW5ndGggPiBidWYubGVuZ3RoIC0gYnl0ZXNVc2VkKSB7XG4gICAgICAgICAgICBuZXdCdWZmZXJTaXplID0gKGJ1Zi5sZW5ndGggKiAyKSArIGNodW5rLmxlbmd0aFxuICAgICAgICAgICAgaWYgKG5ld0J1ZmZlclNpemUgPiBtYXhCdWZmZXJBaGVhZEFsbG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgbmV3QnVmZmVyU2l6ZSA9IGJ1Zi5sZW5ndGggKyBjaHVuay5sZW5ndGggKyBtYXhCdWZmZXJBaGVhZEFsbG9jYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0J1ZmZlciA9IEJ1ZmZlci5hbGxvYyhuZXdCdWZmZXJTaXplKVxuICAgICAgICAgICAgYnVmLmNvcHkobmV3QnVmZmVyLCAwLCAwLCBieXRlc1VzZWQpXG4gICAgICAgICAgICBidWYgPSBuZXdCdWZmZXJcbiAgICAgICAgICB9XG4gICAgICAgICAgY2h1bmsuY29weShidWYsIGJ5dGVzVXNlZClcbiAgICAgICAgICBieXRlc1VzZWQgKz0gY2h1bmsubGVuZ3RoXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9zID0gMFxuICAgICAgICB2YXIgbGVuZ3RoID0gYnl0ZXNVc2VkXG5cbiAgICAgICAgd2hpbGUgKHBvcyA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChkaXNjYXJkVHJhaWxpbmdOZXdsaW5lKSB7XG4gICAgICAgICAgICBpZiAoYnVmW3Bvc10gPT09IGxpbmVGZWVkKSB7XG4gICAgICAgICAgICAgICsrcG9zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNjYXJkVHJhaWxpbmdOZXdsaW5lID0gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbGluZUxlbmd0aCA9IC0xXG4gICAgICAgICAgdmFyIGZpZWxkTGVuZ3RoID0gc3RhcnRpbmdGaWVsZExlbmd0aFxuICAgICAgICAgIHZhciBjXG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRpbmdQb3M7IGxpbmVMZW5ndGggPCAwICYmIGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYyA9IGJ1ZltpXVxuICAgICAgICAgICAgaWYgKGMgPT09IGNvbG9uKSB7XG4gICAgICAgICAgICAgIGlmIChmaWVsZExlbmd0aCA8IDApIHtcbiAgICAgICAgICAgICAgICBmaWVsZExlbmd0aCA9IGkgLSBwb3NcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSBjYXJyaWFnZVJldHVybikge1xuICAgICAgICAgICAgICBkaXNjYXJkVHJhaWxpbmdOZXdsaW5lID0gdHJ1ZVxuICAgICAgICAgICAgICBsaW5lTGVuZ3RoID0gaSAtIHBvc1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSBsaW5lRmVlZCkge1xuICAgICAgICAgICAgICBsaW5lTGVuZ3RoID0gaSAtIHBvc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsaW5lTGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgc3RhcnRpbmdQb3MgPSBsZW5ndGggLSBwb3NcbiAgICAgICAgICAgIHN0YXJ0aW5nRmllbGRMZW5ndGggPSBmaWVsZExlbmd0aFxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRpbmdQb3MgPSAwXG4gICAgICAgICAgICBzdGFydGluZ0ZpZWxkTGVuZ3RoID0gLTFcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJzZUV2ZW50U3RyZWFtTGluZShidWYsIHBvcywgZmllbGRMZW5ndGgsIGxpbmVMZW5ndGgpXG5cbiAgICAgICAgICBwb3MgKz0gbGluZUxlbmd0aCArIDFcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3MgPT09IGxlbmd0aCkge1xuICAgICAgICAgIGJ1ZiA9IHZvaWQgMFxuICAgICAgICAgIGJ5dGVzVXNlZCA9IDBcbiAgICAgICAgfSBlbHNlIGlmIChwb3MgPiAwKSB7XG4gICAgICAgICAgYnVmID0gYnVmLnNsaWNlKHBvcywgYnl0ZXNVc2VkKVxuICAgICAgICAgIGJ5dGVzVXNlZCA9IGJ1Zi5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHNlbGYuY29ubmVjdGlvbkluUHJvZ3Jlc3MgPSBmYWxzZVxuICAgICAgb25Db25uZWN0aW9uQ2xvc2VkKGVyci5tZXNzYWdlKVxuICAgIH0pXG5cbiAgICBpZiAocmVxLnNldE5vRGVsYXkpIHJlcS5zZXROb0RlbGF5KHRydWUpXG4gICAgcmVxLmVuZCgpXG4gIH1cblxuICBjb25uZWN0KClcblxuICBmdW5jdGlvbiBfZW1pdCAoKSB7XG4gICAgaWYgKHNlbGYubGlzdGVuZXJzKGFyZ3VtZW50c1swXSkubGVuZ3RoID4gMCkge1xuICAgICAgc2VsZi5lbWl0LmFwcGx5KHNlbGYsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cblxuICB0aGlzLl9jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocmVhZHlTdGF0ZSA9PT0gRXZlbnRTb3VyY2UuQ0xPU0VEKSByZXR1cm5cbiAgICByZWFkeVN0YXRlID0gRXZlbnRTb3VyY2UuQ0xPU0VEXG4gICAgaWYgKHJlcS5hYm9ydCkgcmVxLmFib3J0KClcbiAgICBpZiAocmVxLnhociAmJiByZXEueGhyLmFib3J0KSByZXEueGhyLmFib3J0KClcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRXZlbnRTdHJlYW1MaW5lIChidWYsIHBvcywgZmllbGRMZW5ndGgsIGxpbmVMZW5ndGgpIHtcbiAgICBpZiAobGluZUxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgdHlwZSA9IGV2ZW50TmFtZSB8fCAnbWVzc2FnZSdcbiAgICAgICAgX2VtaXQodHlwZSwgbmV3IE1lc3NhZ2VFdmVudCh0eXBlLCB7XG4gICAgICAgICAgZGF0YTogZGF0YS5zbGljZSgwLCAtMSksIC8vIHJlbW92ZSB0cmFpbGluZyBuZXdsaW5lXG4gICAgICAgICAgbGFzdEV2ZW50SWQ6IGxhc3RFdmVudElkLFxuICAgICAgICAgIG9yaWdpbjogbmV3IFVSTCh1cmwpLm9yaWdpblxuICAgICAgICB9KSlcbiAgICAgICAgZGF0YSA9ICcnXG4gICAgICB9XG4gICAgICBldmVudE5hbWUgPSB2b2lkIDBcbiAgICB9IGVsc2UgaWYgKGZpZWxkTGVuZ3RoID4gMCkge1xuICAgICAgdmFyIG5vVmFsdWUgPSBmaWVsZExlbmd0aCA8IDBcbiAgICAgIHZhciBzdGVwID0gMFxuICAgICAgdmFyIGZpZWxkID0gYnVmLnNsaWNlKHBvcywgcG9zICsgKG5vVmFsdWUgPyBsaW5lTGVuZ3RoIDogZmllbGRMZW5ndGgpKS50b1N0cmluZygpXG5cbiAgICAgIGlmIChub1ZhbHVlKSB7XG4gICAgICAgIHN0ZXAgPSBsaW5lTGVuZ3RoXG4gICAgICB9IGVsc2UgaWYgKGJ1Zltwb3MgKyBmaWVsZExlbmd0aCArIDFdICE9PSBzcGFjZSkge1xuICAgICAgICBzdGVwID0gZmllbGRMZW5ndGggKyAxXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGVwID0gZmllbGRMZW5ndGggKyAyXG4gICAgICB9XG4gICAgICBwb3MgKz0gc3RlcFxuXG4gICAgICB2YXIgdmFsdWVMZW5ndGggPSBsaW5lTGVuZ3RoIC0gc3RlcFxuICAgICAgdmFyIHZhbHVlID0gYnVmLnNsaWNlKHBvcywgcG9zICsgdmFsdWVMZW5ndGgpLnRvU3RyaW5nKClcblxuICAgICAgaWYgKGZpZWxkID09PSAnZGF0YScpIHtcbiAgICAgICAgZGF0YSArPSB2YWx1ZSArICdcXG4nXG4gICAgICB9IGVsc2UgaWYgKGZpZWxkID09PSAnZXZlbnQnKSB7XG4gICAgICAgIGV2ZW50TmFtZSA9IHZhbHVlXG4gICAgICB9IGVsc2UgaWYgKGZpZWxkID09PSAnaWQnKSB7XG4gICAgICAgIGxhc3RFdmVudElkID0gdmFsdWVcbiAgICAgIH0gZWxzZSBpZiAoZmllbGQgPT09ICdyZXRyeScpIHtcbiAgICAgICAgdmFyIHJldHJ5ID0gcGFyc2VJbnQodmFsdWUsIDEwKVxuICAgICAgICBpZiAoIU51bWJlci5pc05hTihyZXRyeSkpIHtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdEludGVydmFsID0gcmV0cnlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50U291cmNlXG5cbnV0aWwuaW5oZXJpdHMoRXZlbnRTb3VyY2UsIGV2ZW50cy5FdmVudEVtaXR0ZXIpXG5FdmVudFNvdXJjZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFdmVudFNvdXJjZTsgLy8gbWFrZSBzdGFja3RyYWNlcyByZWFkYWJsZVxuXG5bJ29wZW4nLCAnZXJyb3InLCAnbWVzc2FnZSddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRTb3VyY2UucHJvdG90eXBlLCAnb24nICsgbWV0aG9kLCB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBsaXN0ZW5lclxuICAgICAqXG4gICAgICogQHJldHVybiB7TWl4ZWR9IHRoZSBzZXQgZnVuY3Rpb24gb3IgdW5kZWZpbmVkXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgdmFyIGxpc3RlbmVyID0gdGhpcy5saXN0ZW5lcnMobWV0aG9kKVswXVxuICAgICAgcmV0dXJuIGxpc3RlbmVyID8gKGxpc3RlbmVyLl9saXN0ZW5lciA/IGxpc3RlbmVyLl9saXN0ZW5lciA6IGxpc3RlbmVyKSA6IHVuZGVmaW5lZFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgdGhlIGxpc3RlbmVyXG4gICAgICogQHJldHVybiB7TWl4ZWR9IHRoZSBzZXQgZnVuY3Rpb24gb3IgdW5kZWZpbmVkXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQgKGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhtZXRob2QpXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIobWV0aG9kLCBsaXN0ZW5lcilcbiAgICB9XG4gIH0pXG59KVxuXG4vKipcbiAqIFJlYWR5IHN0YXRlc1xuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRTb3VyY2UsICdDT05ORUNUSU5HJywge2VudW1lcmFibGU6IHRydWUsIHZhbHVlOiAwfSlcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudFNvdXJjZSwgJ09QRU4nLCB7ZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IDF9KVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50U291cmNlLCAnQ0xPU0VEJywge2VudW1lcmFibGU6IHRydWUsIHZhbHVlOiAyfSlcblxuRXZlbnRTb3VyY2UucHJvdG90eXBlLkNPTk5FQ1RJTkcgPSAwXG5FdmVudFNvdXJjZS5wcm90b3R5cGUuT1BFTiA9IDFcbkV2ZW50U291cmNlLnByb3RvdHlwZS5DTE9TRUQgPSAyXG5cbi8qKlxuICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLCBpZiBvbmUgaXMgbWFkZSwgYW5kIHNldHMgdGhlIHJlYWR5U3RhdGUgYXR0cmlidXRlIHRvIDIgKGNsb3NlZClcbiAqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFNvdXJjZS9jbG9zZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRTb3VyY2UucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9jbG9zZSgpXG59XG5cbi8qKlxuICogRW11bGF0ZXMgdGhlIFczQyBCcm93c2VyIGJhc2VkIFdlYlNvY2tldCBpbnRlcmZhY2UgdXNpbmcgYWRkRXZlbnRMaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIG91dCBmb3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIGNhbGxiYWNrXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXJcbiAqIEBzZWUgaHR0cDovL2Rldi53My5vcmcvaHRtbDUvd2Vic29ja2V0cy8jdGhlLXdlYnNvY2tldC1pbnRlcmZhY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50U291cmNlLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lciAodHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIHN0b3JlIGEgcmVmZXJlbmNlIHNvIHdlIGNhbiByZXR1cm4gdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGFnYWluXG4gICAgbGlzdGVuZXIuX2xpc3RlbmVyID0gbGlzdGVuZXJcbiAgICB0aGlzLm9uKHR5cGUsIGxpc3RlbmVyKVxuICB9XG59XG5cbi8qKlxuICogRW11bGF0ZXMgdGhlIFczQyBCcm93c2VyIGJhc2VkIFdlYlNvY2tldCBpbnRlcmZhY2UgdXNpbmcgZGlzcGF0Y2hFdmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBBbiBldmVudCB0byBiZSBkaXNwYXRjaGVkXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9kaXNwYXRjaEV2ZW50XG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudFNvdXJjZS5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQgKGV2ZW50KSB7XG4gIGlmICghZXZlbnQudHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVU5TUEVDSUZJRURfRVZFTlRfVFlQRV9FUlInKVxuICB9XG4gIC8vIGlmIGV2ZW50IGlzIGluc3RhbmNlIG9mIGFuIEN1c3RvbUV2ZW50IChvciBoYXMgJ2RldGFpbHMnIHByb3BlcnR5KSxcbiAgLy8gc2VuZCB0aGUgZGV0YWlsIG9iamVjdCBhcyB0aGUgcGF5bG9hZCBmb3IgdGhlIGV2ZW50XG4gIHRoaXMuZW1pdChldmVudC50eXBlLCBldmVudC5kZXRhaWwpXG59XG5cbi8qKlxuICogRW11bGF0ZXMgdGhlIFczQyBCcm93c2VyIGJhc2VkIFdlYlNvY2tldCBpbnRlcmZhY2UgdXNpbmcgcmVtb3ZlRXZlbnRMaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gcmVtb3ZlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBjYWxsYmFja1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyXG4gKiBAc2VlIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3dlYnNvY2tldHMvI3RoZS13ZWJzb2NrZXQtaW50ZXJmYWNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudFNvdXJjZS5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIgKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBsaXN0ZW5lci5fbGlzdGVuZXIgPSB1bmRlZmluZWRcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKVxuICB9XG59XG5cbi8qKlxuICogVzNDIEV2ZW50XG4gKlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2ludGVyZmFjZS1FdmVudFxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEV2ZW50ICh0eXBlLCBvcHRpb25hbFByb3BlcnRpZXMpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywgeyB3cml0YWJsZTogZmFsc2UsIHZhbHVlOiB0eXBlLCBlbnVtZXJhYmxlOiB0cnVlIH0pXG4gIGlmIChvcHRpb25hbFByb3BlcnRpZXMpIHtcbiAgICBmb3IgKHZhciBmIGluIG9wdGlvbmFsUHJvcGVydGllcykge1xuICAgICAgaWYgKG9wdGlvbmFsUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShmKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgZiwgeyB3cml0YWJsZTogZmFsc2UsIHZhbHVlOiBvcHRpb25hbFByb3BlcnRpZXNbZl0sIGVudW1lcmFibGU6IHRydWUgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBXM0MgTWVzc2FnZUV2ZW50XG4gKlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi93ZWJtZXNzYWdpbmcvI2V2ZW50LWRlZmluaXRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gTWVzc2FnZUV2ZW50ICh0eXBlLCBldmVudEluaXREaWN0KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHsgd3JpdGFibGU6IGZhbHNlLCB2YWx1ZTogdHlwZSwgZW51bWVyYWJsZTogdHJ1ZSB9KVxuICBmb3IgKHZhciBmIGluIGV2ZW50SW5pdERpY3QpIHtcbiAgICBpZiAoZXZlbnRJbml0RGljdC5oYXNPd25Qcm9wZXJ0eShmKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGYsIHsgd3JpdGFibGU6IGZhbHNlLCB2YWx1ZTogZXZlbnRJbml0RGljdFtmXSwgZW51bWVyYWJsZTogdHJ1ZSB9KVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgb2JqZWN0IG9mIGhlYWRlcnMgdGhhdCBkb2VzIG5vdCBpbmNsdWRlIGFueSBhdXRob3JpemF0aW9uIGFuZCBjb29raWUgaGVhZGVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzIEFuIG9iamVjdCBvZiBoZWFkZXJzICh7W2hlYWRlck5hbWVdOiBoZWFkZXJWYWx1ZX0pXG4gKiBAcmV0dXJuIHtPYmplY3R9IGEgbmV3IG9iamVjdCBvZiBoZWFkZXJzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlVW5zYWZlSGVhZGVycyAoaGVhZGVycykge1xuICB2YXIgc2FmZSA9IHt9XG4gIGZvciAodmFyIGtleSBpbiBoZWFkZXJzKSB7XG4gICAgaWYgKHJlVW5zYWZlSGVhZGVyLnRlc3Qoa2V5KSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBzYWZlW2tleV0gPSBoZWFkZXJzW2tleV1cbiAgfVxuXG4gIHJldHVybiBzYWZlXG59XG4iXSwibmFtZXMiOlsicGFyc2UiLCJyZXF1aXJlIiwiZXZlbnRzIiwiaHR0cHMiLCJodHRwIiwidXRpbCIsImh0dHBzT3B0aW9ucyIsImJvbSIsImNvbG9uIiwic3BhY2UiLCJsaW5lRmVlZCIsImNhcnJpYWdlUmV0dXJuIiwibWF4QnVmZmVyQWhlYWRBbGxvY2F0aW9uIiwicmVVbnNhZmVIZWFkZXIiLCJoYXNCb20iLCJidWYiLCJldmVyeSIsImNoYXJDb2RlIiwiaW5kZXgiLCJFdmVudFNvdXJjZSIsInVybCIsImV2ZW50U291cmNlSW5pdERpY3QiLCJyZWFkeVN0YXRlIiwiQ09OTkVDVElORyIsImhlYWRlcnMiLCJoYXNOZXdPcmlnaW4iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsInNlbGYiLCJyZWNvbm5lY3RJbnRlcnZhbCIsImNvbm5lY3Rpb25JblByb2dyZXNzIiwib25Db25uZWN0aW9uQ2xvc2VkIiwibWVzc2FnZSIsIkNMT1NFRCIsIl9lbWl0IiwiRXZlbnQiLCJyZWNvbm5lY3RVcmwiLCJzZXRUaW1lb3V0IiwiY29ubmVjdCIsInJlcSIsImxhc3RFdmVudElkIiwiZGlzY2FyZFRyYWlsaW5nTmV3bGluZSIsImRhdGEiLCJldmVudE5hbWUiLCJvcHRpb25zIiwiaXNTZWN1cmUiLCJwcm90b2NvbCIsInJlcUhlYWRlcnMiLCJyZW1vdmVVbnNhZmVIZWFkZXJzIiwiaSIsImhlYWRlciIsInJlamVjdFVuYXV0aG9yaXplZCIsImNyZWF0ZUNvbm5lY3Rpb24iLCJ1bmRlZmluZWQiLCJ1c2VQcm94eSIsInByb3h5IiwicGF0aCIsIkhvc3QiLCJob3N0IiwiaG9zdG5hbWUiLCJwb3J0Iiwib3B0TmFtZSIsImluZGV4T2YiLCJvcHRpb24iLCJ3aXRoQ3JlZGVudGlhbHMiLCJyZXF1ZXN0IiwicmVzIiwic3RhdHVzQ29kZSIsInN0YXR1cyIsInN0YXR1c01lc3NhZ2UiLCJsb2NhdGlvbiIsInByZXZPcmlnaW4iLCJVUkwiLCJvcmlnaW4iLCJuZXh0T3JpZ2luIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiY2xvc2UiLCJPUEVOIiwib24iLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJuZXdCdWZmZXIiLCJzdGFydGluZ1BvcyIsInN0YXJ0aW5nRmllbGRMZW5ndGgiLCJuZXdCdWZmZXJTaXplIiwiYnl0ZXNVc2VkIiwiY2h1bmsiLCJzbGljZSIsImxlbmd0aCIsIkJ1ZmZlciIsImFsbG9jIiwiY29weSIsInBvcyIsImxpbmVMZW5ndGgiLCJmaWVsZExlbmd0aCIsImMiLCJwYXJzZUV2ZW50U3RyZWFtTGluZSIsImVyciIsInNldE5vRGVsYXkiLCJlbmQiLCJsaXN0ZW5lcnMiLCJhcmd1bWVudHMiLCJlbWl0IiwiYXBwbHkiLCJfY2xvc2UiLCJhYm9ydCIsInhociIsInR5cGUiLCJNZXNzYWdlRXZlbnQiLCJub1ZhbHVlIiwic3RlcCIsImZpZWxkIiwidG9TdHJpbmciLCJ2YWx1ZUxlbmd0aCIsInZhbHVlIiwicmV0cnkiLCJwYXJzZUludCIsIk51bWJlciIsImlzTmFOIiwibW9kdWxlIiwiZXhwb3J0cyIsImluaGVyaXRzIiwiRXZlbnRFbWl0dGVyIiwicHJvdG90eXBlIiwiY29uc3RydWN0b3IiLCJmb3JFYWNoIiwibWV0aG9kIiwibGlzdGVuZXIiLCJfbGlzdGVuZXIiLCJzZXQiLCJhZGRFdmVudExpc3RlbmVyIiwiZW51bWVyYWJsZSIsImRpc3BhdGNoRXZlbnQiLCJldmVudCIsIkVycm9yIiwiZGV0YWlsIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwib3B0aW9uYWxQcm9wZXJ0aWVzIiwid3JpdGFibGUiLCJmIiwiaGFzT3duUHJvcGVydHkiLCJldmVudEluaXREaWN0Iiwic2FmZSIsImtleSIsInRlc3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eventsource/lib/eventsource.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/eventsource/lib/eventsource.js":
/*!*****************************************************!*\
  !*** ./node_modules/eventsource/lib/eventsource.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var parse = (__webpack_require__(/*! url */ \"url\").parse);\nvar events = __webpack_require__(/*! events */ \"events\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar http = __webpack_require__(/*! http */ \"http\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar httpsOptions = [\n    \"pfx\",\n    \"key\",\n    \"passphrase\",\n    \"cert\",\n    \"ca\",\n    \"ciphers\",\n    \"rejectUnauthorized\",\n    \"secureProtocol\",\n    \"servername\",\n    \"checkServerIdentity\"\n];\nvar bom = [\n    239,\n    187,\n    191\n];\nvar colon = 58;\nvar space = 32;\nvar lineFeed = 10;\nvar carriageReturn = 13;\n// Beyond 256KB we could not observe any gain in performance\nvar maxBufferAheadAllocation = 1024 * 256;\n// Headers matching the pattern should be removed when redirecting to different origin\nvar reUnsafeHeader = /^(cookie|authorization)$/i;\nfunction hasBom(buf) {\n    return bom.every(function(charCode, index) {\n        return buf[index] === charCode;\n    });\n}\n/**\n * Creates a new EventSource object\n *\n * @param {String} url the URL to which to connect\n * @param {Object} [eventSourceInitDict] extra init params. See README for details.\n * @api public\n **/ function EventSource(url, eventSourceInitDict) {\n    var readyState = EventSource.CONNECTING;\n    var headers = eventSourceInitDict && eventSourceInitDict.headers;\n    var hasNewOrigin = false;\n    Object.defineProperty(this, \"readyState\", {\n        get: function() {\n            return readyState;\n        }\n    });\n    Object.defineProperty(this, \"url\", {\n        get: function() {\n            return url;\n        }\n    });\n    var self = this;\n    self.reconnectInterval = 1000;\n    self.connectionInProgress = false;\n    function onConnectionClosed(message) {\n        if (readyState === EventSource.CLOSED) return;\n        readyState = EventSource.CONNECTING;\n        _emit(\"error\", new Event(\"error\", {\n            message: message\n        }));\n        // The url may have been changed by a temporary redirect. If that's the case,\n        // revert it now, and flag that we are no longer pointing to a new origin\n        if (reconnectUrl) {\n            url = reconnectUrl;\n            reconnectUrl = null;\n            hasNewOrigin = false;\n        }\n        setTimeout(function() {\n            if (readyState !== EventSource.CONNECTING || self.connectionInProgress) {\n                return;\n            }\n            self.connectionInProgress = true;\n            connect();\n        }, self.reconnectInterval);\n    }\n    var req;\n    var lastEventId = \"\";\n    if (headers && headers[\"Last-Event-ID\"]) {\n        lastEventId = headers[\"Last-Event-ID\"];\n        delete headers[\"Last-Event-ID\"];\n    }\n    var discardTrailingNewline = false;\n    var data = \"\";\n    var eventName = \"\";\n    var reconnectUrl = null;\n    function connect() {\n        var options = parse(url);\n        var isSecure = options.protocol === \"https:\";\n        options.headers = {\n            \"Cache-Control\": \"no-cache\",\n            \"Accept\": \"text/event-stream\"\n        };\n        if (lastEventId) options.headers[\"Last-Event-ID\"] = lastEventId;\n        if (headers) {\n            var reqHeaders = hasNewOrigin ? removeUnsafeHeaders(headers) : headers;\n            for(var i in reqHeaders){\n                var header = reqHeaders[i];\n                if (header) {\n                    options.headers[i] = header;\n                }\n            }\n        }\n        // Legacy: this should be specified as `eventSourceInitDict.https.rejectUnauthorized`,\n        // but for now exists as a backwards-compatibility layer\n        options.rejectUnauthorized = !(eventSourceInitDict && !eventSourceInitDict.rejectUnauthorized);\n        if (eventSourceInitDict && eventSourceInitDict.createConnection !== undefined) {\n            options.createConnection = eventSourceInitDict.createConnection;\n        }\n        // If specify http proxy, make the request to sent to the proxy server,\n        // and include the original url in path and Host headers\n        var useProxy = eventSourceInitDict && eventSourceInitDict.proxy;\n        if (useProxy) {\n            var proxy = parse(eventSourceInitDict.proxy);\n            isSecure = proxy.protocol === \"https:\";\n            options.protocol = isSecure ? \"https:\" : \"http:\";\n            options.path = url;\n            options.headers.Host = options.host;\n            options.hostname = proxy.hostname;\n            options.host = proxy.host;\n            options.port = proxy.port;\n        }\n        // If https options are specified, merge them into the request options\n        if (eventSourceInitDict && eventSourceInitDict.https) {\n            for(var optName in eventSourceInitDict.https){\n                if (httpsOptions.indexOf(optName) === -1) {\n                    continue;\n                }\n                var option = eventSourceInitDict.https[optName];\n                if (option !== undefined) {\n                    options[optName] = option;\n                }\n            }\n        }\n        // Pass this on to the XHR\n        if (eventSourceInitDict && eventSourceInitDict.withCredentials !== undefined) {\n            options.withCredentials = eventSourceInitDict.withCredentials;\n        }\n        req = (isSecure ? https : http).request(options, function(res) {\n            self.connectionInProgress = false;\n            // Handle HTTP errors\n            if (res.statusCode === 500 || res.statusCode === 502 || res.statusCode === 503 || res.statusCode === 504) {\n                _emit(\"error\", new Event(\"error\", {\n                    status: res.statusCode,\n                    message: res.statusMessage\n                }));\n                onConnectionClosed();\n                return;\n            }\n            // Handle HTTP redirects\n            if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                var location = res.headers.location;\n                if (!location) {\n                    // Server sent redirect response without Location header.\n                    _emit(\"error\", new Event(\"error\", {\n                        status: res.statusCode,\n                        message: res.statusMessage\n                    }));\n                    return;\n                }\n                var prevOrigin = new URL(url).origin;\n                var nextOrigin = new URL(location).origin;\n                hasNewOrigin = prevOrigin !== nextOrigin;\n                if (res.statusCode === 307) reconnectUrl = url;\n                url = location;\n                process.nextTick(connect);\n                return;\n            }\n            if (res.statusCode !== 200) {\n                _emit(\"error\", new Event(\"error\", {\n                    status: res.statusCode,\n                    message: res.statusMessage\n                }));\n                return self.close();\n            }\n            readyState = EventSource.OPEN;\n            res.on(\"close\", function() {\n                res.removeAllListeners(\"close\");\n                res.removeAllListeners(\"end\");\n                onConnectionClosed();\n            });\n            res.on(\"end\", function() {\n                res.removeAllListeners(\"close\");\n                res.removeAllListeners(\"end\");\n                onConnectionClosed();\n            });\n            _emit(\"open\", new Event(\"open\"));\n            // text/event-stream parser adapted from webkit's\n            // Source/WebCore/page/EventSource.cpp\n            var buf;\n            var newBuffer;\n            var startingPos = 0;\n            var startingFieldLength = -1;\n            var newBufferSize = 0;\n            var bytesUsed = 0;\n            res.on(\"data\", function(chunk) {\n                if (!buf) {\n                    buf = chunk;\n                    if (hasBom(buf)) {\n                        buf = buf.slice(bom.length);\n                    }\n                    bytesUsed = buf.length;\n                } else {\n                    if (chunk.length > buf.length - bytesUsed) {\n                        newBufferSize = buf.length * 2 + chunk.length;\n                        if (newBufferSize > maxBufferAheadAllocation) {\n                            newBufferSize = buf.length + chunk.length + maxBufferAheadAllocation;\n                        }\n                        newBuffer = Buffer.alloc(newBufferSize);\n                        buf.copy(newBuffer, 0, 0, bytesUsed);\n                        buf = newBuffer;\n                    }\n                    chunk.copy(buf, bytesUsed);\n                    bytesUsed += chunk.length;\n                }\n                var pos = 0;\n                var length = bytesUsed;\n                while(pos < length){\n                    if (discardTrailingNewline) {\n                        if (buf[pos] === lineFeed) {\n                            ++pos;\n                        }\n                        discardTrailingNewline = false;\n                    }\n                    var lineLength = -1;\n                    var fieldLength = startingFieldLength;\n                    var c;\n                    for(var i = startingPos; lineLength < 0 && i < length; ++i){\n                        c = buf[i];\n                        if (c === colon) {\n                            if (fieldLength < 0) {\n                                fieldLength = i - pos;\n                            }\n                        } else if (c === carriageReturn) {\n                            discardTrailingNewline = true;\n                            lineLength = i - pos;\n                        } else if (c === lineFeed) {\n                            lineLength = i - pos;\n                        }\n                    }\n                    if (lineLength < 0) {\n                        startingPos = length - pos;\n                        startingFieldLength = fieldLength;\n                        break;\n                    } else {\n                        startingPos = 0;\n                        startingFieldLength = -1;\n                    }\n                    parseEventStreamLine(buf, pos, fieldLength, lineLength);\n                    pos += lineLength + 1;\n                }\n                if (pos === length) {\n                    buf = void 0;\n                    bytesUsed = 0;\n                } else if (pos > 0) {\n                    buf = buf.slice(pos, bytesUsed);\n                    bytesUsed = buf.length;\n                }\n            });\n        });\n        req.on(\"error\", function(err) {\n            self.connectionInProgress = false;\n            onConnectionClosed(err.message);\n        });\n        if (req.setNoDelay) req.setNoDelay(true);\n        req.end();\n    }\n    connect();\n    function _emit() {\n        if (self.listeners(arguments[0]).length > 0) {\n            self.emit.apply(self, arguments);\n        }\n    }\n    this._close = function() {\n        if (readyState === EventSource.CLOSED) return;\n        readyState = EventSource.CLOSED;\n        if (req.abort) req.abort();\n        if (req.xhr && req.xhr.abort) req.xhr.abort();\n    };\n    function parseEventStreamLine(buf, pos, fieldLength, lineLength) {\n        if (lineLength === 0) {\n            if (data.length > 0) {\n                var type = eventName || \"message\";\n                _emit(type, new MessageEvent(type, {\n                    data: data.slice(0, -1),\n                    lastEventId: lastEventId,\n                    origin: new URL(url).origin\n                }));\n                data = \"\";\n            }\n            eventName = void 0;\n        } else if (fieldLength > 0) {\n            var noValue = fieldLength < 0;\n            var step = 0;\n            var field = buf.slice(pos, pos + (noValue ? lineLength : fieldLength)).toString();\n            if (noValue) {\n                step = lineLength;\n            } else if (buf[pos + fieldLength + 1] !== space) {\n                step = fieldLength + 1;\n            } else {\n                step = fieldLength + 2;\n            }\n            pos += step;\n            var valueLength = lineLength - step;\n            var value = buf.slice(pos, pos + valueLength).toString();\n            if (field === \"data\") {\n                data += value + \"\\n\";\n            } else if (field === \"event\") {\n                eventName = value;\n            } else if (field === \"id\") {\n                lastEventId = value;\n            } else if (field === \"retry\") {\n                var retry = parseInt(value, 10);\n                if (!Number.isNaN(retry)) {\n                    self.reconnectInterval = retry;\n                }\n            }\n        }\n    }\n}\nmodule.exports = EventSource;\nutil.inherits(EventSource, events.EventEmitter);\nEventSource.prototype.constructor = EventSource; // make stacktraces readable\n[\n    \"open\",\n    \"error\",\n    \"message\"\n].forEach(function(method) {\n    Object.defineProperty(EventSource.prototype, \"on\" + method, {\n        /**\n     * Returns the current listener\n     *\n     * @return {Mixed} the set function or undefined\n     * @api private\n     */ get: function get() {\n            var listener = this.listeners(method)[0];\n            return listener ? listener._listener ? listener._listener : listener : undefined;\n        },\n        /**\n     * Start listening for events\n     *\n     * @param {Function} listener the listener\n     * @return {Mixed} the set function or undefined\n     * @api private\n     */ set: function set(listener) {\n            this.removeAllListeners(method);\n            this.addEventListener(method, listener);\n        }\n    });\n});\n/**\n * Ready states\n */ Object.defineProperty(EventSource, \"CONNECTING\", {\n    enumerable: true,\n    value: 0\n});\nObject.defineProperty(EventSource, \"OPEN\", {\n    enumerable: true,\n    value: 1\n});\nObject.defineProperty(EventSource, \"CLOSED\", {\n    enumerable: true,\n    value: 2\n});\nEventSource.prototype.CONNECTING = 0;\nEventSource.prototype.OPEN = 1;\nEventSource.prototype.CLOSED = 2;\n/**\n * Closes the connection, if one is made, and sets the readyState attribute to 2 (closed)\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventSource/close\n * @api public\n */ EventSource.prototype.close = function() {\n    this._close();\n};\n/**\n * Emulates the W3C Browser based WebSocket interface using addEventListener.\n *\n * @param {String} type A string representing the event type to listen out for\n * @param {Function} listener callback\n * @see https://developer.mozilla.org/en/DOM/element.addEventListener\n * @see http://dev.w3.org/html5/websockets/#the-websocket-interface\n * @api public\n */ EventSource.prototype.addEventListener = function addEventListener(type, listener) {\n    if (typeof listener === \"function\") {\n        // store a reference so we can return the original function again\n        listener._listener = listener;\n        this.on(type, listener);\n    }\n};\n/**\n * Emulates the W3C Browser based WebSocket interface using dispatchEvent.\n *\n * @param {Event} event An event to be dispatched\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent\n * @api public\n */ EventSource.prototype.dispatchEvent = function dispatchEvent(event) {\n    if (!event.type) {\n        throw new Error(\"UNSPECIFIED_EVENT_TYPE_ERR\");\n    }\n    // if event is instance of an CustomEvent (or has 'details' property),\n    // send the detail object as the payload for the event\n    this.emit(event.type, event.detail);\n};\n/**\n * Emulates the W3C Browser based WebSocket interface using removeEventListener.\n *\n * @param {String} type A string representing the event type to remove\n * @param {Function} listener callback\n * @see https://developer.mozilla.org/en/DOM/element.removeEventListener\n * @see http://dev.w3.org/html5/websockets/#the-websocket-interface\n * @api public\n */ EventSource.prototype.removeEventListener = function removeEventListener(type, listener) {\n    if (typeof listener === \"function\") {\n        listener._listener = undefined;\n        this.removeListener(type, listener);\n    }\n};\n/**\n * W3C Event\n *\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#interface-Event\n * @api private\n */ function Event(type, optionalProperties) {\n    Object.defineProperty(this, \"type\", {\n        writable: false,\n        value: type,\n        enumerable: true\n    });\n    if (optionalProperties) {\n        for(var f in optionalProperties){\n            if (optionalProperties.hasOwnProperty(f)) {\n                Object.defineProperty(this, f, {\n                    writable: false,\n                    value: optionalProperties[f],\n                    enumerable: true\n                });\n            }\n        }\n    }\n}\n/**\n * W3C MessageEvent\n *\n * @see http://www.w3.org/TR/webmessaging/#event-definitions\n * @api private\n */ function MessageEvent(type, eventInitDict) {\n    Object.defineProperty(this, \"type\", {\n        writable: false,\n        value: type,\n        enumerable: true\n    });\n    for(var f in eventInitDict){\n        if (eventInitDict.hasOwnProperty(f)) {\n            Object.defineProperty(this, f, {\n                writable: false,\n                value: eventInitDict[f],\n                enumerable: true\n            });\n        }\n    }\n}\n/**\n * Returns a new object of headers that does not include any authorization and cookie headers\n *\n * @param {Object} headers An object of headers ({[headerName]: headerValue})\n * @return {Object} a new object of headers\n * @api private\n */ function removeUnsafeHeaders(headers) {\n    var safe = {};\n    for(var key in headers){\n        if (reUnsafeHeader.test(key)) {\n            continue;\n        }\n        safe[key] = headers[key];\n    }\n    return safe;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXZlbnRzb3VyY2UvbGliL2V2ZW50c291cmNlLmpzIiwibWFwcGluZ3MiOiJBQUFBLElBQUlBLFFBQVFDLDZDQUFvQjtBQUNoQyxJQUFJQyxTQUFTRCxtQkFBT0EsQ0FBQztBQUNyQixJQUFJRSxRQUFRRixtQkFBT0EsQ0FBQztBQUNwQixJQUFJRyxPQUFPSCxtQkFBT0EsQ0FBQztBQUNuQixJQUFJSSxPQUFPSixtQkFBT0EsQ0FBQztBQUVuQixJQUFJSyxlQUFlO0lBQ2pCO0lBQU87SUFBTztJQUFjO0lBQVE7SUFBTTtJQUMxQztJQUFzQjtJQUFrQjtJQUFjO0NBQ3ZEO0FBRUQsSUFBSUMsTUFBTTtJQUFDO0lBQUs7SUFBSztDQUFJO0FBQ3pCLElBQUlDLFFBQVE7QUFDWixJQUFJQyxRQUFRO0FBQ1osSUFBSUMsV0FBVztBQUNmLElBQUlDLGlCQUFpQjtBQUNyQiw0REFBNEQ7QUFDNUQsSUFBSUMsMkJBQTJCLE9BQU87QUFDdEMsc0ZBQXNGO0FBQ3RGLElBQUlDLGlCQUFpQjtBQUVyQixTQUFTQyxPQUFRQyxHQUFHO0lBQ2xCLE9BQU9SLElBQUlTLEtBQUssQ0FBQyxTQUFVQyxRQUFRLEVBQUVDLEtBQUs7UUFDeEMsT0FBT0gsR0FBRyxDQUFDRyxNQUFNLEtBQUtEO0lBQ3hCO0FBQ0Y7QUFFQTs7Ozs7O0VBTUUsR0FDRixTQUFTRSxZQUFhQyxHQUFHLEVBQUVDLG1CQUFtQjtJQUM1QyxJQUFJQyxhQUFhSCxZQUFZSSxVQUFVO0lBQ3ZDLElBQUlDLFVBQVVILHVCQUF1QkEsb0JBQW9CRyxPQUFPO0lBQ2hFLElBQUlDLGVBQWU7SUFDbkJDLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsY0FBYztRQUN4Q0MsS0FBSztZQUNILE9BQU9OO1FBQ1Q7SUFDRjtJQUVBSSxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLE9BQU87UUFDakNDLEtBQUs7WUFDSCxPQUFPUjtRQUNUO0lBQ0Y7SUFFQSxJQUFJUyxPQUFPLElBQUk7SUFDZkEs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QUFFaUgsVUFBVTtRQUFPekIsT0FBT1A7UUFBTXdCLFlBQVk7SUFBSztJQUNyRixJQUFLLElBQUlTLEtBQUtFLGNBQWU7UUFDM0IsSUFBSUEsY0FBY0QsY0FBYyxDQUFDRCxJQUFJO1lBQ25DbkgsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRWtILEdBQUc7Z0JBQUVELFVBQVU7Z0JBQU96QixPQUFPNEIsYUFBYSxDQUFDRixFQUFFO2dCQUFFVCxZQUFZO1lBQUs7UUFDOUY7SUFDRjtBQUNGO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU25GLG9CQUFxQnpCLE9BQU87SUFDbkMsSUFBSXdILE9BQU8sQ0FBQztJQUNaLElBQUssSUFBSUMsT0FBT3pILFFBQVM7UUFDdkIsSUFBSVgsZUFBZXFJLElBQUksQ0FBQ0QsTUFBTTtZQUM1QjtRQUNGO1FBRUFELElBQUksQ0FBQ0MsSUFBSSxHQUFHekgsT0FBTyxDQUFDeUgsSUFBSTtJQUMxQjtJQUVBLE9BQU9EO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZG1pc3Npb24tdXBsaWZ0Ly4vbm9kZV9tb2R1bGVzL2V2ZW50c291cmNlL2xpYi9ldmVudHNvdXJjZS5qcz9kZDJlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBwYXJzZSA9IHJlcXVpcmUoJ3VybCcpLnBhcnNlXG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJylcbnZhciBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJylcbnZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuXG52YXIgaHR0cHNPcHRpb25zID0gW1xuICAncGZ4JywgJ2tleScsICdwYXNzcGhyYXNlJywgJ2NlcnQnLCAnY2EnLCAnY2lwaGVycycsXG4gICdyZWplY3RVbmF1dGhvcml6ZWQnLCAnc2VjdXJlUHJvdG9jb2wnLCAnc2VydmVybmFtZScsICdjaGVja1NlcnZlcklkZW50aXR5J1xuXVxuXG52YXIgYm9tID0gWzIzOSwgMTg3LCAxOTFdXG52YXIgY29sb24gPSA1OFxudmFyIHNwYWNlID0gMzJcbnZhciBsaW5lRmVlZCA9IDEwXG52YXIgY2FycmlhZ2VSZXR1cm4gPSAxM1xuLy8gQmV5b25kIDI1NktCIHdlIGNvdWxkIG5vdCBvYnNlcnZlIGFueSBnYWluIGluIHBlcmZvcm1hbmNlXG52YXIgbWF4QnVmZmVyQWhlYWRBbGxvY2F0aW9uID0gMTAyNCAqIDI1NlxuLy8gSGVhZGVycyBtYXRjaGluZyB0aGUgcGF0dGVybiBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHJlZGlyZWN0aW5nIHRvIGRpZmZlcmVudCBvcmlnaW5cbnZhciByZVVuc2FmZUhlYWRlciA9IC9eKGNvb2tpZXxhdXRob3JpemF0aW9uKSQvaVxuXG5mdW5jdGlvbiBoYXNCb20gKGJ1Zikge1xuICByZXR1cm4gYm9tLmV2ZXJ5KGZ1bmN0aW9uIChjaGFyQ29kZSwgaW5kZXgpIHtcbiAgICByZXR1cm4gYnVmW2luZGV4XSA9PT0gY2hhckNvZGVcbiAgfSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEV2ZW50U291cmNlIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgdGhlIFVSTCB0byB3aGljaCB0byBjb25uZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gW2V2ZW50U291cmNlSW5pdERpY3RdIGV4dHJhIGluaXQgcGFyYW1zLiBTZWUgUkVBRE1FIGZvciBkZXRhaWxzLlxuICogQGFwaSBwdWJsaWNcbiAqKi9cbmZ1bmN0aW9uIEV2ZW50U291cmNlICh1cmwsIGV2ZW50U291cmNlSW5pdERpY3QpIHtcbiAgdmFyIHJlYWR5U3RhdGUgPSBFdmVudFNvdXJjZS5DT05ORUNUSU5HXG4gIHZhciBoZWFkZXJzID0gZXZlbnRTb3VyY2VJbml0RGljdCAmJiBldmVudFNvdXJjZUluaXREaWN0LmhlYWRlcnNcbiAgdmFyIGhhc05ld09yaWdpbiA9IGZhbHNlXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVhZHlTdGF0ZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZWFkeVN0YXRlXG4gICAgfVxuICB9KVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndXJsJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHVybFxuICAgIH1cbiAgfSlcblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5yZWNvbm5lY3RJbnRlcnZhbCA9IDEwMDBcbiAgc2VsZi5jb25uZWN0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlXG5cbiAgZnVuY3Rpb24gb25Db25uZWN0aW9uQ2xvc2VkIChtZXNzYWdlKSB7XG4gICAgaWYgKHJlYWR5U3RhdGUgPT09IEV2ZW50U291cmNlLkNMT1NFRCkgcmV0dXJuXG4gICAgcmVhZHlTdGF0ZSA9IEV2ZW50U291cmNlLkNPTk5FQ1RJTkdcbiAgICBfZW1pdCgnZXJyb3InLCBuZXcgRXZlbnQoJ2Vycm9yJywge21lc3NhZ2U6IG1lc3NhZ2V9KSlcblxuICAgIC8vIFRoZSB1cmwgbWF5IGhhdmUgYmVlbiBjaGFuZ2VkIGJ5IGEgdGVtcG9yYXJ5IHJlZGlyZWN0LiBJZiB0aGF0J3MgdGhlIGNhc2UsXG4gICAgLy8gcmV2ZXJ0IGl0IG5vdywgYW5kIGZsYWcgdGhhdCB3ZSBhcmUgbm8gbG9uZ2VyIHBvaW50aW5nIHRvIGEgbmV3IG9yaWdpblxuICAgIGlmIChyZWNvbm5lY3RVcmwpIHtcbiAgICAgIHVybCA9IHJlY29ubmVjdFVybFxuICAgICAgcmVjb25uZWN0VXJsID0gbnVsbFxuICAgICAgaGFzTmV3T3JpZ2luID0gZmFsc2VcbiAgICB9XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocmVhZHlTdGF0ZSAhPT0gRXZlbnRTb3VyY2UuQ09OTkVDVElORyB8fCBzZWxmLmNvbm5lY3Rpb25JblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgc2VsZi5jb25uZWN0aW9uSW5Qcm9ncmVzcyA9IHRydWVcbiAgICAgIGNvbm5lY3QoKVxuICAgIH0sIHNlbGYucmVjb25uZWN0SW50ZXJ2YWwpXG4gIH1cblxuICB2YXIgcmVxXG4gIHZhciBsYXN0RXZlbnRJZCA9ICcnXG4gIGlmIChoZWFkZXJzICYmIGhlYWRlcnNbJ0xhc3QtRXZlbnQtSUQnXSkge1xuICAgIGxhc3RFdmVudElkID0gaGVhZGVyc1snTGFzdC1FdmVudC1JRCddXG4gICAgZGVsZXRlIGhlYWRlcnNbJ0xhc3QtRXZlbnQtSUQnXVxuICB9XG5cbiAgdmFyIGRpc2NhcmRUcmFpbGluZ05ld2xpbmUgPSBmYWxzZVxuICB2YXIgZGF0YSA9ICcnXG4gIHZhciBldmVudE5hbWUgPSAnJ1xuXG4gIHZhciByZWNvbm5lY3RVcmwgPSBudWxsXG5cbiAgZnVuY3Rpb24gY29ubmVjdCAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBwYXJzZSh1cmwpXG4gICAgdmFyIGlzU2VjdXJlID0gb3B0aW9ucy5wcm90b2NvbCA9PT0gJ2h0dHBzOidcbiAgICBvcHRpb25zLmhlYWRlcnMgPSB7ICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlJywgJ0FjY2VwdCc6ICd0ZXh0L2V2ZW50LXN0cmVhbScgfVxuICAgIGlmIChsYXN0RXZlbnRJZCkgb3B0aW9ucy5oZWFkZXJzWydMYXN0LUV2ZW50LUlEJ10gPSBsYXN0RXZlbnRJZFxuICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICB2YXIgcmVxSGVhZGVycyA9IGhhc05ld09yaWdpbiA/IHJlbW92ZVVuc2FmZUhlYWRlcnMoaGVhZGVycykgOiBoZWFkZXJzXG4gICAgICBmb3IgKHZhciBpIGluIHJlcUhlYWRlcnMpIHtcbiAgICAgICAgdmFyIGhlYWRlciA9IHJlcUhlYWRlcnNbaV1cbiAgICAgICAgaWYgKGhlYWRlcikge1xuICAgICAgICAgIG9wdGlvbnMuaGVhZGVyc1tpXSA9IGhlYWRlclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5OiB0aGlzIHNob3VsZCBiZSBzcGVjaWZpZWQgYXMgYGV2ZW50U291cmNlSW5pdERpY3QuaHR0cHMucmVqZWN0VW5hdXRob3JpemVkYCxcbiAgICAvLyBidXQgZm9yIG5vdyBleGlzdHMgYXMgYSBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBsYXllclxuICAgIG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkID0gIShldmVudFNvdXJjZUluaXREaWN0ICYmICFldmVudFNvdXJjZUluaXREaWN0LnJlamVjdFVuYXV0aG9yaXplZClcblxuICAgIGlmIChldmVudFNvdXJjZUluaXREaWN0ICYmIGV2ZW50U291cmNlSW5pdERpY3QuY3JlYXRlQ29ubmVjdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zLmNyZWF0ZUNvbm5lY3Rpb24gPSBldmVudFNvdXJjZUluaXREaWN0LmNyZWF0ZUNvbm5lY3Rpb25cbiAgICB9XG5cbiAgICAvLyBJZiBzcGVjaWZ5IGh0dHAgcHJveHksIG1ha2UgdGhlIHJlcXVlc3QgdG8gc2VudCB0byB0aGUgcHJveHkgc2VydmVyLFxuICAgIC8vIGFuZCBpbmNsdWRlIHRoZSBvcmlnaW5hbCB1cmwgaW4gcGF0aCBhbmQgSG9zdCBoZWFkZXJzXG4gICAgdmFyIHVzZVByb3h5ID0gZXZlbnRTb3VyY2VJbml0RGljdCAmJiBldmVudFNvdXJjZUluaXREaWN0LnByb3h5XG4gICAgaWYgKHVzZVByb3h5KSB7XG4gICAgICB2YXIgcHJveHkgPSBwYXJzZShldmVudFNvdXJjZUluaXREaWN0LnByb3h5KVxuICAgICAgaXNTZWN1cmUgPSBwcm94eS5wcm90b2NvbCA9PT0gJ2h0dHBzOidcblxuICAgICAgb3B0aW9ucy5wcm90b2NvbCA9IGlzU2VjdXJlID8gJ2h0dHBzOicgOiAnaHR0cDonXG4gICAgICBvcHRpb25zLnBhdGggPSB1cmxcbiAgICAgIG9wdGlvbnMuaGVhZGVycy5Ib3N0ID0gb3B0aW9ucy5ob3N0XG4gICAgICBvcHRpb25zLmhvc3RuYW1lID0gcHJveHkuaG9zdG5hbWVcbiAgICAgIG9wdGlvbnMuaG9zdCA9IHByb3h5Lmhvc3RcbiAgICAgIG9wdGlvbnMucG9ydCA9IHByb3h5LnBvcnRcbiAgICB9XG5cbiAgICAvLyBJZiBodHRwcyBvcHRpb25zIGFyZSBzcGVjaWZpZWQsIG1lcmdlIHRoZW0gaW50byB0aGUgcmVxdWVzdCBvcHRpb25zXG4gICAgaWYgKGV2ZW50U291cmNlSW5pdERpY3QgJiYgZXZlbnRTb3VyY2VJbml0RGljdC5odHRwcykge1xuICAgICAgZm9yICh2YXIgb3B0TmFtZSBpbiBldmVudFNvdXJjZUluaXREaWN0Lmh0dHBzKSB7XG4gICAgICAgIGlmIChodHRwc09wdGlvbnMuaW5kZXhPZihvcHROYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wdGlvbiA9IGV2ZW50U291cmNlSW5pdERpY3QuaHR0cHNbb3B0TmFtZV1cbiAgICAgICAgaWYgKG9wdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3B0aW9uc1tvcHROYW1lXSA9IG9wdGlvblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGFzcyB0aGlzIG9uIHRvIHRoZSBYSFJcbiAgICBpZiAoZXZlbnRTb3VyY2VJbml0RGljdCAmJiBldmVudFNvdXJjZUluaXREaWN0LndpdGhDcmVkZW50aWFscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zLndpdGhDcmVkZW50aWFscyA9IGV2ZW50U291cmNlSW5pdERpY3Qud2l0aENyZWRlbnRpYWxzXG4gICAgfVxuXG4gICAgcmVxID0gKGlzU2VjdXJlID8gaHR0cHMgOiBodHRwKS5yZXF1ZXN0KG9wdGlvbnMsIGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIHNlbGYuY29ubmVjdGlvbkluUHJvZ3Jlc3MgPSBmYWxzZVxuICAgICAgLy8gSGFuZGxlIEhUVFAgZXJyb3JzXG4gICAgICBpZiAocmVzLnN0YXR1c0NvZGUgPT09IDUwMCB8fCByZXMuc3RhdHVzQ29kZSA9PT0gNTAyIHx8IHJlcy5zdGF0dXNDb2RlID09PSA1MDMgfHwgcmVzLnN0YXR1c0NvZGUgPT09IDUwNCkge1xuICAgICAgICBfZW1pdCgnZXJyb3InLCBuZXcgRXZlbnQoJ2Vycm9yJywge3N0YXR1czogcmVzLnN0YXR1c0NvZGUsIG1lc3NhZ2U6IHJlcy5zdGF0dXNNZXNzYWdlfSkpXG4gICAgICAgIG9uQ29ubmVjdGlvbkNsb3NlZCgpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBIYW5kbGUgSFRUUCByZWRpcmVjdHNcbiAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA9PT0gMzAxIHx8IHJlcy5zdGF0dXNDb2RlID09PSAzMDIgfHwgcmVzLnN0YXR1c0NvZGUgPT09IDMwNykge1xuICAgICAgICB2YXIgbG9jYXRpb24gPSByZXMuaGVhZGVycy5sb2NhdGlvblxuICAgICAgICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgICAgICAgLy8gU2VydmVyIHNlbnQgcmVkaXJlY3QgcmVzcG9uc2Ugd2l0aG91dCBMb2NhdGlvbiBoZWFkZXIuXG4gICAgICAgICAgX2VtaXQoJ2Vycm9yJywgbmV3IEV2ZW50KCdlcnJvcicsIHtzdGF0dXM6IHJlcy5zdGF0dXNDb2RlLCBtZXNzYWdlOiByZXMuc3RhdHVzTWVzc2FnZX0pKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2T3JpZ2luID0gbmV3IFVSTCh1cmwpLm9yaWdpblxuICAgICAgICB2YXIgbmV4dE9yaWdpbiA9IG5ldyBVUkwobG9jYXRpb24pLm9yaWdpblxuICAgICAgICBoYXNOZXdPcmlnaW4gPSBwcmV2T3JpZ2luICE9PSBuZXh0T3JpZ2luXG4gICAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA9PT0gMzA3KSByZWNvbm5lY3RVcmwgPSB1cmxcbiAgICAgICAgdXJsID0gbG9jYXRpb25cbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhjb25uZWN0KVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlICE9PSAyMDApIHtcbiAgICAgICAgX2VtaXQoJ2Vycm9yJywgbmV3IEV2ZW50KCdlcnJvcicsIHtzdGF0dXM6IHJlcy5zdGF0dXNDb2RlLCBtZXNzYWdlOiByZXMuc3RhdHVzTWVzc2FnZX0pKVxuICAgICAgICByZXR1cm4gc2VsZi5jbG9zZSgpXG4gICAgICB9XG5cbiAgICAgIHJlYWR5U3RhdGUgPSBFdmVudFNvdXJjZS5PUEVOXG4gICAgICByZXMub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdjbG9zZScpXG4gICAgICAgIHJlcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2VuZCcpXG4gICAgICAgIG9uQ29ubmVjdGlvbkNsb3NlZCgpXG4gICAgICB9KVxuXG4gICAgICByZXMub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVzLnJlbW92ZUFsbExpc3RlbmVycygnY2xvc2UnKVxuICAgICAgICByZXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdlbmQnKVxuICAgICAgICBvbkNvbm5lY3Rpb25DbG9zZWQoKVxuICAgICAgfSlcbiAgICAgIF9lbWl0KCdvcGVuJywgbmV3IEV2ZW50KCdvcGVuJykpXG5cbiAgICAgIC8vIHRleHQvZXZlbnQtc3RyZWFtIHBhcnNlciBhZGFwdGVkIGZyb20gd2Via2l0J3NcbiAgICAgIC8vIFNvdXJjZS9XZWJDb3JlL3BhZ2UvRXZlbnRTb3VyY2UuY3BwXG4gICAgICB2YXIgYnVmXG4gICAgICB2YXIgbmV3QnVmZmVyXG4gICAgICB2YXIgc3RhcnRpbmdQb3MgPSAwXG4gICAgICB2YXIgc3RhcnRpbmdGaWVsZExlbmd0aCA9IC0xXG4gICAgICB2YXIgbmV3QnVmZmVyU2l6ZSA9IDBcbiAgICAgIHZhciBieXRlc1VzZWQgPSAwXG5cbiAgICAgIHJlcy5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICBpZiAoIWJ1Zikge1xuICAgICAgICAgIGJ1ZiA9IGNodW5rXG4gICAgICAgICAgaWYgKGhhc0JvbShidWYpKSB7XG4gICAgICAgICAgICBidWYgPSBidWYuc2xpY2UoYm9tLmxlbmd0aClcbiAgICAgICAgICB9XG4gICAgICAgICAgYnl0ZXNVc2VkID0gYnVmLmxlbmd0aFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjaHVuay5sZW5ndGggPiBidWYubGVuZ3RoIC0gYnl0ZXNVc2VkKSB7XG4gICAgICAgICAgICBuZXdCdWZmZXJTaXplID0gKGJ1Zi5sZW5ndGggKiAyKSArIGNodW5rLmxlbmd0aFxuICAgICAgICAgICAgaWYgKG5ld0J1ZmZlclNpemUgPiBtYXhCdWZmZXJBaGVhZEFsbG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgbmV3QnVmZmVyU2l6ZSA9IGJ1Zi5sZW5ndGggKyBjaHVuay5sZW5ndGggKyBtYXhCdWZmZXJBaGVhZEFsbG9jYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0J1ZmZlciA9IEJ1ZmZlci5hbGxvYyhuZXdCdWZmZXJTaXplKVxuICAgICAgICAgICAgYnVmLmNvcHkobmV3QnVmZmVyLCAwLCAwLCBieXRlc1VzZWQpXG4gICAgICAgICAgICBidWYgPSBuZXdCdWZmZXJcbiAgICAgICAgICB9XG4gICAgICAgICAgY2h1bmsuY29weShidWYsIGJ5dGVzVXNlZClcbiAgICAgICAgICBieXRlc1VzZWQgKz0gY2h1bmsubGVuZ3RoXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9zID0gMFxuICAgICAgICB2YXIgbGVuZ3RoID0gYnl0ZXNVc2VkXG5cbiAgICAgICAgd2hpbGUgKHBvcyA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChkaXNjYXJkVHJhaWxpbmdOZXdsaW5lKSB7XG4gICAgICAgICAgICBpZiAoYnVmW3Bvc10gPT09IGxpbmVGZWVkKSB7XG4gICAgICAgICAgICAgICsrcG9zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNjYXJkVHJhaWxpbmdOZXdsaW5lID0gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbGluZUxlbmd0aCA9IC0xXG4gICAgICAgICAgdmFyIGZpZWxkTGVuZ3RoID0gc3RhcnRpbmdGaWVsZExlbmd0aFxuICAgICAgICAgIHZhciBjXG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRpbmdQb3M7IGxpbmVMZW5ndGggPCAwICYmIGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYyA9IGJ1ZltpXVxuICAgICAgICAgICAgaWYgKGMgPT09IGNvbG9uKSB7XG4gICAgICAgICAgICAgIGlmIChmaWVsZExlbmd0aCA8IDApIHtcbiAgICAgICAgICAgICAgICBmaWVsZExlbmd0aCA9IGkgLSBwb3NcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSBjYXJyaWFnZVJldHVybikge1xuICAgICAgICAgICAgICBkaXNjYXJkVHJhaWxpbmdOZXdsaW5lID0gdHJ1ZVxuICAgICAgICAgICAgICBsaW5lTGVuZ3RoID0gaSAtIHBvc1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSBsaW5lRmVlZCkge1xuICAgICAgICAgICAgICBsaW5lTGVuZ3RoID0gaSAtIHBvc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsaW5lTGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgc3RhcnRpbmdQb3MgPSBsZW5ndGggLSBwb3NcbiAgICAgICAgICAgIHN0YXJ0aW5nRmllbGRMZW5ndGggPSBmaWVsZExlbmd0aFxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRpbmdQb3MgPSAwXG4gICAgICAgICAgICBzdGFydGluZ0ZpZWxkTGVuZ3RoID0gLTFcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJzZUV2ZW50U3RyZWFtTGluZShidWYsIHBvcywgZmllbGRMZW5ndGgsIGxpbmVMZW5ndGgpXG5cbiAgICAgICAgICBwb3MgKz0gbGluZUxlbmd0aCArIDFcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3MgPT09IGxlbmd0aCkge1xuICAgICAgICAgIGJ1ZiA9IHZvaWQgMFxuICAgICAgICAgIGJ5dGVzVXNlZCA9IDBcbiAgICAgICAgfSBlbHNlIGlmIChwb3MgPiAwKSB7XG4gICAgICAgICAgYnVmID0gYnVmLnNsaWNlKHBvcywgYnl0ZXNVc2VkKVxuICAgICAgICAgIGJ5dGVzVXNlZCA9IGJ1Zi5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHNlbGYuY29ubmVjdGlvbkluUHJvZ3Jlc3MgPSBmYWxzZVxuICAgICAgb25Db25uZWN0aW9uQ2xvc2VkKGVyci5tZXNzYWdlKVxuICAgIH0pXG5cbiAgICBpZiAocmVxLnNldE5vRGVsYXkpIHJlcS5zZXROb0RlbGF5KHRydWUpXG4gICAgcmVxLmVuZCgpXG4gIH1cblxuICBjb25uZWN0KClcblxuICBmdW5jdGlvbiBfZW1pdCAoKSB7XG4gICAgaWYgKHNlbGYubGlzdGVuZXJzKGFyZ3VtZW50c1swXSkubGVuZ3RoID4gMCkge1xuICAgICAgc2VsZi5lbWl0LmFwcGx5KHNlbGYsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cblxuICB0aGlzLl9jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocmVhZHlTdGF0ZSA9PT0gRXZlbnRTb3VyY2UuQ0xPU0VEKSByZXR1cm5cbiAgICByZWFkeVN0YXRlID0gRXZlbnRTb3VyY2UuQ0xPU0VEXG4gICAgaWYgKHJlcS5hYm9ydCkgcmVxLmFib3J0KClcbiAgICBpZiAocmVxLnhociAmJiByZXEueGhyLmFib3J0KSByZXEueGhyLmFib3J0KClcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRXZlbnRTdHJlYW1MaW5lIChidWYsIHBvcywgZmllbGRMZW5ndGgsIGxpbmVMZW5ndGgpIHtcbiAgICBpZiAobGluZUxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgdHlwZSA9IGV2ZW50TmFtZSB8fCAnbWVzc2FnZSdcbiAgICAgICAgX2VtaXQodHlwZSwgbmV3IE1lc3NhZ2VFdmVudCh0eXBlLCB7XG4gICAgICAgICAgZGF0YTogZGF0YS5zbGljZSgwLCAtMSksIC8vIHJlbW92ZSB0cmFpbGluZyBuZXdsaW5lXG4gICAgICAgICAgbGFzdEV2ZW50SWQ6IGxhc3RFdmVudElkLFxuICAgICAgICAgIG9yaWdpbjogbmV3IFVSTCh1cmwpLm9yaWdpblxuICAgICAgICB9KSlcbiAgICAgICAgZGF0YSA9ICcnXG4gICAgICB9XG4gICAgICBldmVudE5hbWUgPSB2b2lkIDBcbiAgICB9IGVsc2UgaWYgKGZpZWxkTGVuZ3RoID4gMCkge1xuICAgICAgdmFyIG5vVmFsdWUgPSBmaWVsZExlbmd0aCA8IDBcbiAgICAgIHZhciBzdGVwID0gMFxuICAgICAgdmFyIGZpZWxkID0gYnVmLnNsaWNlKHBvcywgcG9zICsgKG5vVmFsdWUgPyBsaW5lTGVuZ3RoIDogZmllbGRMZW5ndGgpKS50b1N0cmluZygpXG5cbiAgICAgIGlmIChub1ZhbHVlKSB7XG4gICAgICAgIHN0ZXAgPSBsaW5lTGVuZ3RoXG4gICAgICB9IGVsc2UgaWYgKGJ1Zltwb3MgKyBmaWVsZExlbmd0aCArIDFdICE9PSBzcGFjZSkge1xuICAgICAgICBzdGVwID0gZmllbGRMZW5ndGggKyAxXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGVwID0gZmllbGRMZW5ndGggKyAyXG4gICAgICB9XG4gICAgICBwb3MgKz0gc3RlcFxuXG4gICAgICB2YXIgdmFsdWVMZW5ndGggPSBsaW5lTGVuZ3RoIC0gc3RlcFxuICAgICAgdmFyIHZhbHVlID0gYnVmLnNsaWNlKHBvcywgcG9zICsgdmFsdWVMZW5ndGgpLnRvU3RyaW5nKClcblxuICAgICAgaWYgKGZpZWxkID09PSAnZGF0YScpIHtcbiAgICAgICAgZGF0YSArPSB2YWx1ZSArICdcXG4nXG4gICAgICB9IGVsc2UgaWYgKGZpZWxkID09PSAnZXZlbnQnKSB7XG4gICAgICAgIGV2ZW50TmFtZSA9IHZhbHVlXG4gICAgICB9IGVsc2UgaWYgKGZpZWxkID09PSAnaWQnKSB7XG4gICAgICAgIGxhc3RFdmVudElkID0gdmFsdWVcbiAgICAgIH0gZWxzZSBpZiAoZmllbGQgPT09ICdyZXRyeScpIHtcbiAgICAgICAgdmFyIHJldHJ5ID0gcGFyc2VJbnQodmFsdWUsIDEwKVxuICAgICAgICBpZiAoIU51bWJlci5pc05hTihyZXRyeSkpIHtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdEludGVydmFsID0gcmV0cnlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50U291cmNlXG5cbnV0aWwuaW5oZXJpdHMoRXZlbnRTb3VyY2UsIGV2ZW50cy5FdmVudEVtaXR0ZXIpXG5FdmVudFNvdXJjZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFdmVudFNvdXJjZTsgLy8gbWFrZSBzdGFja3RyYWNlcyByZWFkYWJsZVxuXG5bJ29wZW4nLCAnZXJyb3InLCAnbWVzc2FnZSddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRTb3VyY2UucHJvdG90eXBlLCAnb24nICsgbWV0aG9kLCB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBsaXN0ZW5lclxuICAgICAqXG4gICAgICogQHJldHVybiB7TWl4ZWR9IHRoZSBzZXQgZnVuY3Rpb24gb3IgdW5kZWZpbmVkXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgdmFyIGxpc3RlbmVyID0gdGhpcy5saXN0ZW5lcnMobWV0aG9kKVswXVxuICAgICAgcmV0dXJuIGxpc3RlbmVyID8gKGxpc3RlbmVyLl9saXN0ZW5lciA/IGxpc3RlbmVyLl9saXN0ZW5lciA6IGxpc3RlbmVyKSA6IHVuZGVmaW5lZFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgdGhlIGxpc3RlbmVyXG4gICAgICogQHJldHVybiB7TWl4ZWR9IHRoZSBzZXQgZnVuY3Rpb24gb3IgdW5kZWZpbmVkXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQgKGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhtZXRob2QpXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIobWV0aG9kLCBsaXN0ZW5lcilcbiAgICB9XG4gIH0pXG59KVxuXG4vKipcbiAqIFJlYWR5IHN0YXRlc1xuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRTb3VyY2UsICdDT05ORUNUSU5HJywge2VudW1lcmFibGU6IHRydWUsIHZhbHVlOiAwfSlcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudFNvdXJjZSwgJ09QRU4nLCB7ZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IDF9KVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50U291cmNlLCAnQ0xPU0VEJywge2VudW1lcmFibGU6IHRydWUsIHZhbHVlOiAyfSlcblxuRXZlbnRTb3VyY2UucHJvdG90eXBlLkNPTk5FQ1RJTkcgPSAwXG5FdmVudFNvdXJjZS5wcm90b3R5cGUuT1BFTiA9IDFcbkV2ZW50U291cmNlLnByb3RvdHlwZS5DTE9TRUQgPSAyXG5cbi8qKlxuICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLCBpZiBvbmUgaXMgbWFkZSwgYW5kIHNldHMgdGhlIHJlYWR5U3RhdGUgYXR0cmlidXRlIHRvIDIgKGNsb3NlZClcbiAqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFNvdXJjZS9jbG9zZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRTb3VyY2UucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9jbG9zZSgpXG59XG5cbi8qKlxuICogRW11bGF0ZXMgdGhlIFczQyBCcm93c2VyIGJhc2VkIFdlYlNvY2tldCBpbnRlcmZhY2UgdXNpbmcgYWRkRXZlbnRMaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIG91dCBmb3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIGNhbGxiYWNrXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXJcbiAqIEBzZWUgaHR0cDovL2Rldi53My5vcmcvaHRtbDUvd2Vic29ja2V0cy8jdGhlLXdlYnNvY2tldC1pbnRlcmZhY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50U291cmNlLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lciAodHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIHN0b3JlIGEgcmVmZXJlbmNlIHNvIHdlIGNhbiByZXR1cm4gdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGFnYWluXG4gICAgbGlzdGVuZXIuX2xpc3RlbmVyID0gbGlzdGVuZXJcbiAgICB0aGlzLm9uKHR5cGUsIGxpc3RlbmVyKVxuICB9XG59XG5cbi8qKlxuICogRW11bGF0ZXMgdGhlIFczQyBCcm93c2VyIGJhc2VkIFdlYlNvY2tldCBpbnRlcmZhY2UgdXNpbmcgZGlzcGF0Y2hFdmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBBbiBldmVudCB0byBiZSBkaXNwYXRjaGVkXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9kaXNwYXRjaEV2ZW50XG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudFNvdXJjZS5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQgKGV2ZW50KSB7XG4gIGlmICghZXZlbnQudHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVU5TUEVDSUZJRURfRVZFTlRfVFlQRV9FUlInKVxuICB9XG4gIC8vIGlmIGV2ZW50IGlzIGluc3RhbmNlIG9mIGFuIEN1c3RvbUV2ZW50IChvciBoYXMgJ2RldGFpbHMnIHByb3BlcnR5KSxcbiAgLy8gc2VuZCB0aGUgZGV0YWlsIG9iamVjdCBhcyB0aGUgcGF5bG9hZCBmb3IgdGhlIGV2ZW50XG4gIHRoaXMuZW1pdChldmVudC50eXBlLCBldmVudC5kZXRhaWwpXG59XG5cbi8qKlxuICogRW11bGF0ZXMgdGhlIFczQyBCcm93c2VyIGJhc2VkIFdlYlNvY2tldCBpbnRlcmZhY2UgdXNpbmcgcmVtb3ZlRXZlbnRMaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gcmVtb3ZlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBjYWxsYmFja1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyXG4gKiBAc2VlIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3dlYnNvY2tldHMvI3RoZS13ZWJzb2NrZXQtaW50ZXJmYWNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudFNvdXJjZS5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIgKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBsaXN0ZW5lci5fbGlzdGVuZXIgPSB1bmRlZmluZWRcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKVxuICB9XG59XG5cbi8qKlxuICogVzNDIEV2ZW50XG4gKlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2ludGVyZmFjZS1FdmVudFxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEV2ZW50ICh0eXBlLCBvcHRpb25hbFByb3BlcnRpZXMpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywgeyB3cml0YWJsZTogZmFsc2UsIHZhbHVlOiB0eXBlLCBlbnVtZXJhYmxlOiB0cnVlIH0pXG4gIGlmIChvcHRpb25hbFByb3BlcnRpZXMpIHtcbiAgICBmb3IgKHZhciBmIGluIG9wdGlvbmFsUHJvcGVydGllcykge1xuICAgICAgaWYgKG9wdGlvbmFsUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShmKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgZiwgeyB3cml0YWJsZTogZmFsc2UsIHZhbHVlOiBvcHRpb25hbFByb3BlcnRpZXNbZl0sIGVudW1lcmFibGU6IHRydWUgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBXM0MgTWVzc2FnZUV2ZW50XG4gKlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi93ZWJtZXNzYWdpbmcvI2V2ZW50LWRlZmluaXRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gTWVzc2FnZUV2ZW50ICh0eXBlLCBldmVudEluaXREaWN0KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHsgd3JpdGFibGU6IGZhbHNlLCB2YWx1ZTogdHlwZSwgZW51bWVyYWJsZTogdHJ1ZSB9KVxuICBmb3IgKHZhciBmIGluIGV2ZW50SW5pdERpY3QpIHtcbiAgICBpZiAoZXZlbnRJbml0RGljdC5oYXNPd25Qcm9wZXJ0eShmKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGYsIHsgd3JpdGFibGU6IGZhbHNlLCB2YWx1ZTogZXZlbnRJbml0RGljdFtmXSwgZW51bWVyYWJsZTogdHJ1ZSB9KVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgb2JqZWN0IG9mIGhlYWRlcnMgdGhhdCBkb2VzIG5vdCBpbmNsdWRlIGFueSBhdXRob3JpemF0aW9uIGFuZCBjb29raWUgaGVhZGVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzIEFuIG9iamVjdCBvZiBoZWFkZXJzICh7W2hlYWRlck5hbWVdOiBoZWFkZXJWYWx1ZX0pXG4gKiBAcmV0dXJuIHtPYmplY3R9IGEgbmV3IG9iamVjdCBvZiBoZWFkZXJzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlVW5zYWZlSGVhZGVycyAoaGVhZGVycykge1xuICB2YXIgc2FmZSA9IHt9XG4gIGZvciAodmFyIGtleSBpbiBoZWFkZXJzKSB7XG4gICAgaWYgKHJlVW5zYWZlSGVhZGVyLnRlc3Qoa2V5KSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBzYWZlW2tleV0gPSBoZWFkZXJzW2tleV1cbiAgfVxuXG4gIHJldHVybiBzYWZlXG59XG4iXSwibmFtZXMiOlsicGFyc2UiLCJyZXF1aXJlIiwiZXZlbnRzIiwiaHR0cHMiLCJodHRwIiwidXRpbCIsImh0dHBzT3B0aW9ucyIsImJvbSIsImNvbG9uIiwic3BhY2UiLCJsaW5lRmVlZCIsImNhcnJpYWdlUmV0dXJuIiwibWF4QnVmZmVyQWhlYWRBbGxvY2F0aW9uIiwicmVVbnNhZmVIZWFkZXIiLCJoYXNCb20iLCJidWYiLCJldmVyeSIsImNoYXJDb2RlIiwiaW5kZXgiLCJFdmVudFNvdXJjZSIsInVybCIsImV2ZW50U291cmNlSW5pdERpY3QiLCJyZWFkeVN0YXRlIiwiQ09OTkVDVElORyIsImhlYWRlcnMiLCJoYXNOZXdPcmlnaW4iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsInNlbGYiLCJyZWNvbm5lY3RJbnRlcnZhbCIsImNvbm5lY3Rpb25JblByb2dyZXNzIiwib25Db25uZWN0aW9uQ2xvc2VkIiwibWVzc2FnZSIsIkNMT1NFRCIsIl9lbWl0IiwiRXZlbnQiLCJyZWNvbm5lY3RVcmwiLCJzZXRUaW1lb3V0IiwiY29ubmVjdCIsInJlcSIsImxhc3RFdmVudElkIiwiZGlzY2FyZFRyYWlsaW5nTmV3bGluZSIsImRhdGEiLCJldmVudE5hbWUiLCJvcHRpb25zIiwiaXNTZWN1cmUiLCJwcm90b2NvbCIsInJlcUhlYWRlcnMiLCJyZW1vdmVVbnNhZmVIZWFkZXJzIiwiaSIsImhlYWRlciIsInJlamVjdFVuYXV0aG9yaXplZCIsImNyZWF0ZUNvbm5lY3Rpb24iLCJ1bmRlZmluZWQiLCJ1c2VQcm94eSIsInByb3h5IiwicGF0aCIsIkhvc3QiLCJob3N0IiwiaG9zdG5hbWUiLCJwb3J0Iiwib3B0TmFtZSIsImluZGV4T2YiLCJvcHRpb24iLCJ3aXRoQ3JlZGVudGlhbHMiLCJyZXF1ZXN0IiwicmVzIiwic3RhdHVzQ29kZSIsInN0YXR1cyIsInN0YXR1c01lc3NhZ2UiLCJsb2NhdGlvbiIsInByZXZPcmlnaW4iLCJVUkwiLCJvcmlnaW4iLCJuZXh0T3JpZ2luIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiY2xvc2UiLCJPUEVOIiwib24iLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJuZXdCdWZmZXIiLCJzdGFydGluZ1BvcyIsInN0YXJ0aW5nRmllbGRMZW5ndGgiLCJuZXdCdWZmZXJTaXplIiwiYnl0ZXNVc2VkIiwiY2h1bmsiLCJzbGljZSIsImxlbmd0aCIsIkJ1ZmZlciIsImFsbG9jIiwiY29weSIsInBvcyIsImxpbmVMZW5ndGgiLCJmaWVsZExlbmd0aCIsImMiLCJwYXJzZUV2ZW50U3RyZWFtTGluZSIsImVyciIsInNldE5vRGVsYXkiLCJlbmQiLCJsaXN0ZW5lcnMiLCJhcmd1bWVudHMiLCJlbWl0IiwiYXBwbHkiLCJfY2xvc2UiLCJhYm9ydCIsInhociIsInR5cGUiLCJNZXNzYWdlRXZlbnQiLCJub1ZhbHVlIiwic3RlcCIsImZpZWxkIiwidG9TdHJpbmciLCJ2YWx1ZUxlbmd0aCIsInZhbHVlIiwicmV0cnkiLCJwYXJzZUludCIsIk51bWJlciIsImlzTmFOIiwibW9kdWxlIiwiZXhwb3J0cyIsImluaGVyaXRzIiwiRXZlbnRFbWl0dGVyIiwicHJvdG90eXBlIiwiY29uc3RydWN0b3IiLCJmb3JFYWNoIiwibWV0aG9kIiwibGlzdGVuZXIiLCJfbGlzdGVuZXIiLCJzZXQiLCJhZGRFdmVudExpc3RlbmVyIiwiZW51bWVyYWJsZSIsImRpc3BhdGNoRXZlbnQiLCJldmVudCIsIkVycm9yIiwiZGV0YWlsIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwib3B0aW9uYWxQcm9wZXJ0aWVzIiwid3JpdGFibGUiLCJmIiwiaGFzT3duUHJvcGVydHkiLCJldmVudEluaXREaWN0Iiwic2FmZSIsImtleSIsInRlc3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/eventsource/lib/eventsource.js\n");

/***/ })

};
;