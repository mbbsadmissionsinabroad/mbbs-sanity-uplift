"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/embla-carousel";
exports.ids = ["vendor-chunks/embla-carousel"];
exports.modules = {

/***/ "(ssr)/./node_modules/embla-carousel/esm/embla-carousel.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/embla-carousel/esm/embla-carousel.esm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ EmblaCarousel)\n/* harmony export */ });\nfunction isNumber(subject) {\n    return typeof subject === \"number\";\n}\nfunction isString(subject) {\n    return typeof subject === \"string\";\n}\nfunction isBoolean(subject) {\n    return typeof subject === \"boolean\";\n}\nfunction isObject(subject) {\n    return Object.prototype.toString.call(subject) === \"[object Object]\";\n}\nfunction mathAbs(n) {\n    return Math.abs(n);\n}\nfunction mathSign(n) {\n    return Math.sign(n);\n}\nfunction deltaAbs(valueB, valueA) {\n    return mathAbs(valueB - valueA);\n}\nfunction factorAbs(valueB, valueA) {\n    if (valueB === 0 || valueA === 0) return 0;\n    if (mathAbs(valueB) <= mathAbs(valueA)) return 0;\n    const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA));\n    return mathAbs(diff / valueB);\n}\nfunction roundToTwoDecimals(num) {\n    return Math.round(num * 100) / 100;\n}\nfunction arrayKeys(array) {\n    return objectKeys(array).map(Number);\n}\nfunction arrayLast(array) {\n    return array[arrayLastIndex(array)];\n}\nfunction arrayLastIndex(array) {\n    return Math.max(0, array.length - 1);\n}\nfunction arrayIsLastIndex(array, index) {\n    return index === arrayLastIndex(array);\n}\nfunction arrayFromNumber(n, startAt = 0) {\n    return Array.from(Array(n), (_, i)=>startAt + i);\n}\nfunction objectKeys(object) {\n    return Object.keys(object);\n}\nfunction objectsMergeDeep(objectA, objectB) {\n    return [\n        objectA,\n        objectB\n    ].reduce((mergedObjects, currentObject)=>{\n        objectKeys(currentObject).forEach((key)=>{\n            const valueA = mergedObjects[key];\n            const valueB = currentObject[key];\n            const areObjects = isObject(valueA) && isObject(valueB);\n            mergedObjects[key] = areObjects ? objectsMergeDeep(valueA, valueB) : valueB;\n        });\n        return mergedObjects;\n    }, {});\n}\nfunction isMouseEvent(evt, ownerWindow) {\n    return typeof ownerWindow.MouseEvent !== \"undefined\" && evt instanceof ownerWindow.MouseEvent;\n}\nfunction Alignment(align, viewSize) {\n    const predefined = {\n        start,\n        center,\n        end\n    };\n    function start() {\n        return 0;\n    }\n    function center(n) {\n        return end(n) / 2;\n    }\n    function end(n) {\n        return viewSize - n;\n    }\n    function measure(n, index) {\n        if (isString(align)) return predefined[align](n);\n        return align(viewSize, n, index);\n    }\n    const self = {\n        measure\n    };\n    return self;\n}\nfunction EventStore() {\n    let listeners = [];\n    function add(node, type, handler, options = {\n        passive: true\n    }) {\n        let removeListener;\n        if (\"addEventListener\" in node) {\n            node.addEventListener(type, handler, options);\n            removeListener = ()=>node.removeEventListener(type, handler, options);\n        } else {\n            const legacyMediaQueryList = node;\n            legacyMediaQueryList.addListener(handler);\n            removeListener = ()=>legacyMediaQueryList.removeListener(handler);\n        }\n        listeners.push(removeListener);\n        return self;\n    }\n    function clear() {\n        listeners = listeners.filter((remove)=>remove());\n    }\n    const self = {\n        add,\n        clear\n    };\n    return self;\n}\nfunction Animations(ownerDocument, ownerWindow, update, render) {\n    const documentVisibleHandler = EventStore();\n    const fixedTimeStep = 1000 / 60;\n    let lastTimeStamp = null;\n    let accumulatedTime = 0;\n    let animationId = 0;\n    function init() {\n        documentVisibleHandler.add(ownerDocument, \"visibilitychange\", ()=>{\n            if (ownerDocument.hidden) reset();\n        });\n    }\n    function destroy() {\n        stop();\n        documentVisibleHandler.clear();\n    }\n    function animate(timeStamp) {\n        if (!animationId) return;\n        if (!lastTimeStamp) lastTimeStamp = timeStamp;\n        const timeElapsed = timeStamp - lastTimeStamp;\n        lastTimeStamp = timeStamp;\n        accumulatedTime += timeElapsed;\n        while(accumulatedTime >= fixedTimeStep){\n            update();\n            accumulatedTime -= fixedTimeStep;\n        }\n        const alpha = accumulatedTime / fixedTimeStep;\n        render(alpha);\n        if (animationId) {\n            animationId = ownerWindow.requestAnimationFrame(animate);\n        }\n    }\n    function start() {\n        if (animationId) return;\n        animationId = ownerWindow.requestAnimationFrame(animate);\n    }\n    function stop() {\n        ownerWindow.cancelAnimationFrame(animationId);\n        lastTimeStamp = null;\n        accumulatedTime = 0;\n        animationId = 0;\n    }\n    function reset() {\n        lastTimeStamp = null;\n        accumulatedTime = 0;\n    }\n    const self = {\n        init,\n        destroy,\n        start,\n        stop,\n        update,\n        render\n    };\n    return self;\n}\nfunction Axis(axis, contentDirection) {\n    const isRightToLeft = contentDirection === \"rtl\";\n    const isVertical = axis === \"y\";\n    const scroll = isVertical ? \"y\" : \"x\";\n    const cross = isVertical ? \"x\" : \"y\";\n    const sign = !isVertical && isRightToLeft ? -1 : 1;\n    const startEdge = getStartEdge();\n    const endEdge = getEndEdge();\n    function measureSize(nodeRect) {\n        const { height, width } = nodeRect;\n        return isVertical ? height : width;\n    }\n    function getStartEdge() {\n        if (isVertical) return \"top\";\n        return isRightToLeft ? \"right\" : \"left\";\n    }\n    function getEndEdge() {\n        if (isVertical) return \"bottom\";\n        return isRightToLeft ? \"left\" : \"right\";\n    }\n    function direction(n) {\n        return n * sign;\n    }\n    const self = {\n        scroll,\n        cross,\n        startEdge,\n        endEdge,\n        measureSize,\n        direction\n    };\n    return self;\n}\nfunction Limit(min = 0, max = 0) {\n    const length = mathAbs(min - max);\n    function reachedMin(n) {\n        return n < min;\n    }\n    function reachedMax(n) {\n        return n > max;\n    }\n    function reachedAny(n) {\n        return reachedMin(n) || reachedMax(n);\n    }\n    function constrain(n) {\n        if (!reachedAny(n)) return n;\n        return reachedMin(n) ? min : max;\n    }\n    function removeOffset(n) {\n        if (!length) return n;\n        return n - length * Math.ceil((n - max) / length);\n    }\n    const self = {\n        length,\n        max,\n        min,\n        constrain,\n        reachedAny,\n        reachedMax,\n        reachedMin,\n        removeOffset\n    };\n    return self;\n}\nfunction Counter(max, start, loop) {\n    const { constrain } = Limit(0, max);\n    const loopEnd = max + 1;\n    let counter = withinLimit(start);\n    function withinLimit(n) {\n        return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd);\n    }\n    function get() {\n        return counter;\n    }\n    function set(n) {\n        counter = withinLimit(n);\n        return self;\n    }\n    function add(n) {\n        return clone().set(get() + n);\n    }\n    function clone() {\n        return Counter(max, get(), loop);\n    }\n    const self = {\n        get,\n        set,\n        add,\n        clone\n    };\n    return self;\n}\nfunction DragHandler(axis, rootNode, ownerDocument, ownerWindow, target, dragTracker, location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, baseFriction, watchDrag) {\n    const { cross: crossAxis, direction } = axis;\n    const focusNodes = [\n        \"INPUT\",\n        \"SELECT\",\n        \"TEXTAREA\"\n    ];\n    const nonPassiveEvent = {\n        passive: false\n    };\n    const initEvents = EventStore();\n    const dragEvents = EventStore();\n    const goToNextThreshold = Limit(50, 225).constrain(percentOfView.measure(20));\n    const snapForceBoost = {\n        mouse: 300,\n        touch: 400\n    };\n    const freeForceBoost = {\n        mouse: 500,\n        touch: 600\n    };\n    const baseSpeed = dragFree ? 43 : 25;\n    let isMoving = false;\n    let startScroll = 0;\n    let startCross = 0;\n    let pointerIsDown = false;\n    let preventScroll = false;\n    let preventClick = false;\n    let isMouse = false;\n    function init(emblaApi) {\n        if (!watchDrag) return;\n        function downIfAllowed(evt) {\n            if (isBoolean(watchDrag) || watchDrag(emblaApi, evt)) down(evt);\n        }\n        const node = rootNode;\n        initEvents.add(node, \"dragstart\", (evt)=>evt.preventDefault(), nonPassiveEvent).add(node, \"touchmove\", ()=>undefined, nonPassiveEvent).add(node, \"touchend\", ()=>undefined).add(node, \"touchstart\", downIfAllowed).add(node, \"mousedown\", downIfAllowed).add(node, \"touchcancel\", up).add(node, \"contextmenu\", up).add(node, \"click\", click, true);\n    }\n    function destroy() {\n        initEvents.clear();\n        dragEvents.clear();\n    }\n    function addDragEvents() {\n        const node = isMouse ? ownerDocument : rootNode;\n        dragEvents.add(node, \"touchmove\", move, nonPassiveEvent).add(node, \"touchend\", up).add(node, \"mousemove\", move, nonPassiveEvent).add(node, \"mouseup\", up);\n    }\n    function isFocusNode(node) {\n        const nodeName = node.nodeName || \"\";\n        return focusNodes.includes(nodeName);\n    }\n    function forceBoost() {\n        const boost = dragFree ? freeForceBoost : snapForceBoost;\n        const type = isMouse ? \"mouse\" : \"touch\";\n        return boost[type];\n    }\n    function allowedForce(force, targetChanged) {\n        const next = index.add(mathSign(force) * -1);\n        const baseForce = scrollTarget.byDistance(force, !dragFree).distance;\n        if (dragFree || mathAbs(force) < goToNextThreshold) return baseForce;\n        if (skipSnaps && targetChanged) return baseForce * 0.5;\n        return scrollTarget.byIndex(next.get(), 0).distance;\n    }\n    function down(evt) {\n        const isMouseEvt = isMouseEvent(evt, ownerWindow);\n        isMouse = isMouseEvt;\n        preventClick = dragFree && isMouseEvt && !evt.buttons && isMoving;\n        isMoving = deltaAbs(target.get(), location.get()) >= 2;\n        if (isMouseEvt && evt.button !== 0) return;\n        if (isFocusNode(evt.target)) return;\n        pointerIsDown = true;\n        dragTracker.pointerDown(evt);\n        scrollBody.useFriction(0).useDuration(0);\n        target.set(location);\n        addDragEvents();\n        startScroll = dragTracker.readPoint(evt);\n        startCross = dragTracker.readPoint(evt, crossAxis);\n        eventHandler.emit(\"pointerDown\");\n    }\n    function move(evt) {\n        const isTouchEvt = !isMouseEvent(evt, ownerWindow);\n        if (isTouchEvt && evt.touches.length >= 2) return up(evt);\n        const lastScroll = dragTracker.readPoint(evt);\n        const lastCross = dragTracker.readPoint(evt, crossAxis);\n        const diffScroll = deltaAbs(lastScroll, startScroll);\n        const diffCross = deltaAbs(lastCross, startCross);\n        if (!preventScroll && !isMouse) {\n            if (!evt.cancelable) return up(evt);\n            preventScroll = diffScroll > diffCross;\n            if (!preventScroll) return up(evt);\n        }\n        const diff = dragTracker.pointerMove(evt);\n        if (diffScroll > dragThreshold) preventClick = true;\n        scrollBody.useFriction(0.3).useDuration(0.75);\n        animation.start();\n        target.add(direction(diff));\n        evt.preventDefault();\n    }\n    function up(evt) {\n        const currentLocation = scrollTarget.byDistance(0, false);\n        const targetChanged = currentLocation.index !== index.get();\n        const rawForce = dragTracker.pointerUp(evt) * forceBoost();\n        const force = allowedForce(direction(rawForce), targetChanged);\n        const forceFactor = factorAbs(rawForce, force);\n        const speed = baseSpeed - 10 * forceFactor;\n        const friction = baseFriction + forceFactor / 50;\n        preventScroll = false;\n        pointerIsDown = false;\n        dragEvents.clear();\n        scrollBody.useDuration(speed).useFriction(friction);\n        scrollTo.distance(force, !dragFree);\n        isMouse = false;\n        eventHandler.emit(\"pointerUp\");\n    }\n    function click(evt) {\n        if (preventClick) {\n            evt.stopPropagation();\n            evt.preventDefault();\n            preventClick = false;\n        }\n    }\n    function pointerDown() {\n        return pointerIsDown;\n    }\n    const self = {\n        init,\n        destroy,\n        pointerDown\n    };\n    return self;\n}\nfunction DragTracker(axis, ownerWindow) {\n    const logInterval = 170;\n    let startEvent;\n    let lastEvent;\n    function readTime(evt) {\n        return evt.timeStamp;\n    }\n    function readPoint(evt, evtAxis) {\n        const property = evtAxis || axis.scroll;\n        const coord = `client${property === \"x\" ? \"X\" : \"Y\"}`;\n        return (isMouseEvent(evt, ownerWindow) ? evt : evt.touches[0])[coord];\n    }\n    function pointerDown(evt) {\n        startEvent = evt;\n        lastEvent = evt;\n        return readPoint(evt);\n    }\n    function pointerMove(evt) {\n        const diff = readPoint(evt) - readPoint(lastEvent);\n        const expired = readTime(evt) - readTime(startEvent) > logInterval;\n        lastEvent = evt;\n        if (expired) startEvent = evt;\n        return diff;\n    }\n    function pointerUp(evt) {\n        if (!startEvent || !lastEvent) return 0;\n        const diffDrag = readPoint(lastEvent) - readPoint(startEvent);\n        const diffTime = readTime(evt) - readTime(startEvent);\n        const expired = readTime(evt) - readTime(lastEvent) > logInterval;\n        const force = diffDrag / diffTime;\n        const isFlick = diffTime && !expired && mathAbs(force) > 0.1;\n        return isFlick ? force : 0;\n    }\n    const self = {\n        pointerDown,\n        pointerMove,\n        pointerUp,\n        readPoint\n    };\n    return self;\n}\nfunction NodeRects() {\n    function measure(node) {\n        const { offsetTop, offsetLeft, offsetWidth, offsetHeight } = node;\n        const offset = {\n            top: offsetTop,\n            right: offsetLeft + offsetWidth,\n            bottom: offsetTop + offsetHeight,\n            left: offsetLeft,\n            width: offsetWidth,\n            height: offsetHeight\n        };\n        return offset;\n    }\n    const self = {\n        measure\n    };\n    return self;\n}\nfunction PercentOfView(viewSize) {\n    function measure(n) {\n        return viewSize * (n / 100);\n    }\n    const self = {\n        measure\n    };\n    return self;\n}\nfunction ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects) {\n    const observeNodes = [\n        container\n    ].concat(slides);\n    let resizeObserver;\n    let containerSize;\n    let slideSizes = [];\n    let destroyed = false;\n    function readSize(node) {\n        return axis.measureSize(nodeRects.measure(node));\n    }\n    function init(emblaApi) {\n        if (!watchResize) return;\n        containerSize = readSize(container);\n        slideSizes = slides.map(readSize);\n        function defaultCallback(entries) {\n            for (const entry of entries){\n                if (destroyed) return;\n                const isContainer = entry.target === container;\n                const slideIndex = slides.indexOf(entry.target);\n                const lastSize = isContainer ? containerSize : slideSizes[slideIndex];\n                const newSize = readSize(isContainer ? container : slides[slideIndex]);\n                const diffSize = mathAbs(newSize - lastSize);\n                if (diffSize >= 0.5) {\n                    emblaApi.reInit();\n                    eventHandler.emit(\"resize\");\n                    break;\n                }\n            }\n        }\n        resizeObserver = new ResizeObserver((entries)=>{\n            if (isBoolean(watchResize) || watchResize(emblaApi, entries)) {\n                defaultCallback(entries);\n            }\n        });\n        ownerWindow.requestAnimationFrame(()=>{\n            observeNodes.forEach((node)=>resizeObserver.observe(node));\n        });\n    }\n    function destroy() {\n        destroyed = true;\n        if (resizeObserver) resizeObserver.disconnect();\n    }\n    const self = {\n        init,\n        destroy\n    };\n    return self;\n}\nfunction ScrollBody(location, offsetLocation, previousLocation, target, baseDuration, baseFriction) {\n    let scrollVelocity = 0;\n    let scrollDirection = 0;\n    let scrollDuration = baseDuration;\n    let scrollFriction = baseFriction;\n    let rawLocation = location.get();\n    let rawLocationPrevious = 0;\n    function seek() {\n        const displacement = target.get() - location.get();\n        const isInstant = !scrollDuration;\n        let scrollDistance = 0;\n        if (isInstant) {\n            scrollVelocity = 0;\n            previousLocation.set(target);\n            location.set(target);\n            scrollDistance = displacement;\n        } else {\n            previousLocation.set(location);\n            scrollVelocity += displacement / scrollDuration;\n            scrollVelocity *= scrollFriction;\n            rawLocation += scrollVelocity;\n            location.add(scrollVelocity);\n            scrollDistance = rawLocation - rawLocationPrevious;\n        }\n        scrollDirection = mathSign(scrollDistance);\n        rawLocationPrevious = rawLocation;\n        return self;\n    }\n    function settled() {\n        const diff = target.get() - offsetLocation.get();\n        return mathAbs(diff) < 0.001;\n    }\n    function duration() {\n        return scrollDuration;\n    }\n    function direction() {\n        return scrollDirection;\n    }\n    function velocity() {\n        return scrollVelocity;\n    }\n    function useBaseDuration() {\n        return useDuration(baseDuration);\n    }\n    function useBaseFriction() {\n        return useFriction(baseFriction);\n    }\n    function useDuration(n) {\n        scrollDuration = n;\n        return self;\n    }\n    function useFriction(n) {\n        scrollFriction = n;\n        return self;\n    }\n    const self = {\n        direction,\n        duration,\n        velocity,\n        seek,\n        settled,\n        useBaseFriction,\n        useBaseDuration,\n        useFriction,\n        useDuration\n    };\n    return self;\n}\nfunction ScrollBounds(limit, location, target, scrollBody, percentOfView) {\n    const pullBackThreshold = percentOfView.measure(10);\n    const edgeOffsetTolerance = percentOfView.measure(50);\n    const frictionLimit = Limit(0.1, 0.99);\n    let disabled = false;\n    function shouldConstrain() {\n        if (disabled) return false;\n        if (!limit.reachedAny(target.get())) return false;\n        if (!limit.reachedAny(location.get())) return false;\n        return true;\n    }\n    function constrain(pointerDown) {\n        if (!shouldConstrain()) return;\n        const edge = limit.reachedMin(location.get()) ? \"min\" : \"max\";\n        const diffToEdge = mathAbs(limit[edge] - location.get());\n        const diffToTarget = target.get() - location.get();\n        const friction = frictionLimit.constrain(diffToEdge / edgeOffsetTolerance);\n        target.subtract(diffToTarget * friction);\n        if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {\n            target.set(limit.constrain(target.get()));\n            scrollBody.useDuration(25).useBaseFriction();\n        }\n    }\n    function toggleActive(active) {\n        disabled = !active;\n    }\n    const self = {\n        shouldConstrain,\n        constrain,\n        toggleActive\n    };\n    return self;\n}\nfunction ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance) {\n    const scrollBounds = Limit(-contentSize + viewSize, 0);\n    const snapsBounded = measureBounded();\n    const scrollContainLimit = findScrollContainLimit();\n    const snapsContained = measureContained();\n    function usePixelTolerance(bound, snap) {\n        return deltaAbs(bound, snap) < 1;\n    }\n    function findScrollContainLimit() {\n        const startSnap = snapsBounded[0];\n        const endSnap = arrayLast(snapsBounded);\n        const min = snapsBounded.lastIndexOf(startSnap);\n        const max = snapsBounded.indexOf(endSnap) + 1;\n        return Limit(min, max);\n    }\n    function measureBounded() {\n        return snapsAligned.map((snapAligned, index)=>{\n            const { min, max } = scrollBounds;\n            const snap = scrollBounds.constrain(snapAligned);\n            const isFirst = !index;\n            const isLast = arrayIsLastIndex(snapsAligned, index);\n            if (isFirst) return max;\n            if (isLast) return min;\n            if (usePixelTolerance(min, snap)) return min;\n            if (usePixelTolerance(max, snap)) return max;\n            return snap;\n        }).map((scrollBound)=>parseFloat(scrollBound.toFixed(3)));\n    }\n    function measureContained() {\n        if (contentSize <= viewSize + pixelTolerance) return [\n            scrollBounds.max\n        ];\n        if (containScroll === \"keepSnaps\") return snapsBounded;\n        const { min, max } = scrollContainLimit;\n        return snapsBounded.slice(min, max);\n    }\n    const self = {\n        snapsContained,\n        scrollContainLimit\n    };\n    return self;\n}\nfunction ScrollLimit(contentSize, scrollSnaps, loop) {\n    const max = scrollSnaps[0];\n    const min = loop ? max - contentSize : arrayLast(scrollSnaps);\n    const limit = Limit(min, max);\n    const self = {\n        limit\n    };\n    return self;\n}\nfunction ScrollLooper(contentSize, limit, location, vectors) {\n    const jointSafety = 0.1;\n    const min = limit.min + jointSafety;\n    const max = limit.max + jointSafety;\n    const { reachedMin, reachedMax } = Limit(min, max);\n    function shouldLoop(direction) {\n        if (direction === 1) return reachedMax(location.get());\n        if (direction === -1) return reachedMin(location.get());\n        return false;\n    }\n    function loop(direction) {\n        if (!shouldLoop(direction)) return;\n        const loopDistance = contentSize * (direction * -1);\n        vectors.forEach((v)=>v.add(loopDistance));\n    }\n    const self = {\n        loop\n    };\n    return self;\n}\nfunction ScrollProgress(limit) {\n    const { max, length } = limit;\n    function get(n) {\n        const currentLocation = n - max;\n        return length ? currentLocation / -length : 0;\n    }\n    const self = {\n        get\n    };\n    return self;\n}\nfunction ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll) {\n    const { startEdge, endEdge } = axis;\n    const { groupSlides } = slidesToScroll;\n    const alignments = measureSizes().map(alignment.measure);\n    const snaps = measureUnaligned();\n    const snapsAligned = measureAligned();\n    function measureSizes() {\n        return groupSlides(slideRects).map((rects)=>arrayLast(rects)[endEdge] - rects[0][startEdge]).map(mathAbs);\n    }\n    function measureUnaligned() {\n        return slideRects.map((rect)=>containerRect[startEdge] - rect[startEdge]).map((snap)=>-mathAbs(snap));\n    }\n    function measureAligned() {\n        return groupSlides(snaps).map((g)=>g[0]).map((snap, index)=>snap + alignments[index]);\n    }\n    const self = {\n        snaps,\n        snapsAligned\n    };\n    return self;\n}\nfunction SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes) {\n    const { groupSlides } = slidesToScroll;\n    const { min, max } = scrollContainLimit;\n    const slideRegistry = createSlideRegistry();\n    function createSlideRegistry() {\n        const groupedSlideIndexes = groupSlides(slideIndexes);\n        const doNotContain = !containSnaps || containScroll === \"keepSnaps\";\n        if (scrollSnaps.length === 1) return [\n            slideIndexes\n        ];\n        if (doNotContain) return groupedSlideIndexes;\n        return groupedSlideIndexes.slice(min, max).map((group, index, groups)=>{\n            const isFirst = !index;\n            const isLast = arrayIsLastIndex(groups, index);\n            if (isFirst) {\n                const range = arrayLast(groups[0]) + 1;\n                return arrayFromNumber(range);\n            }\n            if (isLast) {\n                const range = arrayLastIndex(slideIndexes) - arrayLast(groups)[0] + 1;\n                return arrayFromNumber(range, arrayLast(groups)[0]);\n            }\n            return group;\n        });\n    }\n    const self = {\n        slideRegistry\n    };\n    return self;\n}\nfunction ScrollTarget(loop, scrollSnaps, contentSize, limit, targetVector) {\n    const { reachedAny, removeOffset, constrain } = limit;\n    function minDistance(distances) {\n        return distances.concat().sort((a, b)=>mathAbs(a) - mathAbs(b))[0];\n    }\n    function findTargetSnap(target) {\n        const distance = loop ? removeOffset(target) : constrain(target);\n        const ascDiffsToSnaps = scrollSnaps.map((snap, index)=>({\n                diff: shortcut(snap - distance, 0),\n                index\n            })).sort((d1, d2)=>mathAbs(d1.diff) - mathAbs(d2.diff));\n        const { index } = ascDiffsToSnaps[0];\n        return {\n            index,\n            distance\n        };\n    }\n    function shortcut(target, direction) {\n        const targets = [\n            target,\n            target + contentSize,\n            target - contentSize\n        ];\n        if (!loop) return target;\n        if (!direction) return minDistance(targets);\n        const matchingTargets = targets.filter((t)=>mathSign(t) === direction);\n        if (matchingTargets.length) return minDistance(matchingTargets);\n        return arrayLast(targets) - contentSize;\n    }\n    function byIndex(index, direction) {\n        const diffToSnap = scrollSnaps[index] - targetVector.get();\n        const distance = shortcut(diffToSnap, direction);\n        return {\n            index,\n            distance\n        };\n    }\n    function byDistance(distance, snap) {\n        const target = targetVector.get() + distance;\n        const { index, distance: targetSnapDistance } = findTargetSnap(target);\n        const reachedBound = !loop && reachedAny(target);\n        if (!snap || reachedBound) return {\n            index,\n            distance\n        };\n        const diffToSnap = scrollSnaps[index] - targetSnapDistance;\n        const snapDistance = distance + shortcut(diffToSnap, 0);\n        return {\n            index,\n            distance: snapDistance\n        };\n    }\n    const self = {\n        byDistance,\n        byIndex,\n        shortcut\n    };\n    return self;\n}\nfunction ScrollTo(animation, indexCurrent, indexPrevious, scrollBody, scrollTarget, targetVector, eventHandler) {\n    function scrollTo(target) {\n        const distanceDiff = target.distance;\n        const indexDiff = target.index !== indexCurrent.get();\n        targetVector.add(distanceDiff);\n        if (distanceDiff) {\n            if (scrollBody.duration()) {\n                animation.start();\n            } else {\n                animation.update();\n                animation.render(1);\n                animation.update();\n            }\n        }\n        if (indexDiff) {\n            indexPrevious.set(indexCurrent.get());\n            indexCurrent.set(target.index);\n            eventHandler.emit(\"select\");\n        }\n    }\n    function distance(n, snap) {\n        const target = scrollTarget.byDistance(n, snap);\n        scrollTo(target);\n    }\n    function index(n, direction) {\n        const targetIndex = indexCurrent.clone().set(n);\n        const target = scrollTarget.byIndex(targetIndex.get(), direction);\n        scrollTo(target);\n    }\n    const self = {\n        distance,\n        index\n    };\n    return self;\n}\nfunction SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus) {\n    const focusListenerOptions = {\n        passive: true,\n        capture: true\n    };\n    let lastTabPressTime = 0;\n    function init(emblaApi) {\n        if (!watchFocus) return;\n        function defaultCallback(index) {\n            const nowTime = new Date().getTime();\n            const diffTime = nowTime - lastTabPressTime;\n            if (diffTime > 10) return;\n            eventHandler.emit(\"slideFocusStart\");\n            root.scrollLeft = 0;\n            const group = slideRegistry.findIndex((group)=>group.includes(index));\n            if (!isNumber(group)) return;\n            scrollBody.useDuration(0);\n            scrollTo.index(group, 0);\n            eventHandler.emit(\"slideFocus\");\n        }\n        eventStore.add(document, \"keydown\", registerTabPress, false);\n        slides.forEach((slide, slideIndex)=>{\n            eventStore.add(slide, \"focus\", (evt)=>{\n                if (isBoolean(watchFocus) || watchFocus(emblaApi, evt)) {\n                    defaultCallback(slideIndex);\n                }\n            }, focusListenerOptions);\n        });\n    }\n    function registerTabPress(event) {\n        if (event.code === \"Tab\") lastTabPressTime = new Date().getTime();\n    }\n    const self = {\n        init\n    };\n    return self;\n}\nfunction Vector1D(initialValue) {\n    let value = initialValue;\n    function get() {\n        return value;\n    }\n    function set(n) {\n        value = normalizeInput(n);\n    }\n    function add(n) {\n        value += normalizeInput(n);\n    }\n    function subtract(n) {\n        value -= normalizeInput(n);\n    }\n    function normalizeInput(n) {\n        return isNumber(n) ? n : n.get();\n    }\n    const self = {\n        get,\n        set,\n        add,\n        subtract\n    };\n    return self;\n}\nfunction Translate(axis, container) {\n    const translate = axis.scroll === \"x\" ? x : y;\n    const containerStyle = container.style;\n    let previousTarget = null;\n    let disabled = false;\n    function x(n) {\n        return `translate3d(${n}px,0px,0px)`;\n    }\n    function y(n) {\n        return `translate3d(0px,${n}px,0px)`;\n    }\n    function to(target) {\n        if (disabled) return;\n        const newTarget = roundToTwoDecimals(axis.direction(target));\n        if (newTarget === previousTarget) return;\n        containerStyle.transform = translate(newTarget);\n        previousTarget = newTarget;\n    }\n    function toggleActive(active) {\n        disabled = !active;\n    }\n    function clear() {\n        if (disabled) return;\n        containerStyle.transform = \"\";\n        if (!container.getAttribute(\"style\")) container.removeAttribute(\"style\");\n    }\n    const self = {\n        clear,\n        to,\n        toggleActive\n    };\n    return self;\n}\nfunction SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, location, slides) {\n    const roundingSafety = 0.5;\n    const ascItems = arrayKeys(slideSizesWithGaps);\n    const descItems = arrayKeys(slideSizesWithGaps).reverse();\n    const loopPoints = startPoints().concat(endPoints());\n    function removeSlideSizes(indexes, from) {\n        return indexes.reduce((a, i)=>{\n            return a - slideSizesWithGaps[i];\n        }, from);\n    }\n    function slidesInGap(indexes, gap) {\n        return indexes.reduce((a, i)=>{\n            const remainingGap = removeSlideSizes(a, gap);\n            return remainingGap > 0 ? a.concat([\n                i\n            ]) : a;\n        }, []);\n    }\n    function findSlideBounds(offset) {\n        return snaps.map((snap, index)=>({\n                start: snap - slideSizes[index] + roundingSafety + offset,\n                end: snap + viewSize - roundingSafety + offset\n            }));\n    }\n    function findLoopPoints(indexes, offset, isEndEdge) {\n        const slideBounds = findSlideBounds(offset);\n        return indexes.map((index)=>{\n            const initial = isEndEdge ? 0 : -contentSize;\n            const altered = isEndEdge ? contentSize : 0;\n            const boundEdge = isEndEdge ? \"end\" : \"start\";\n            const loopPoint = slideBounds[index][boundEdge];\n            return {\n                index,\n                loopPoint,\n                slideLocation: Vector1D(-1),\n                translate: Translate(axis, slides[index]),\n                target: ()=>location.get() > loopPoint ? initial : altered\n            };\n        });\n    }\n    function startPoints() {\n        const gap = scrollSnaps[0];\n        const indexes = slidesInGap(descItems, gap);\n        return findLoopPoints(indexes, contentSize, false);\n    }\n    function endPoints() {\n        const gap = viewSize - scrollSnaps[0] - 1;\n        const indexes = slidesInGap(ascItems, gap);\n        return findLoopPoints(indexes, -contentSize, true);\n    }\n    function canLoop() {\n        return loopPoints.every(({ index })=>{\n            const otherIndexes = ascItems.filter((i)=>i !== index);\n            return removeSlideSizes(otherIndexes, viewSize) <= 0.1;\n        });\n    }\n    function loop() {\n        loopPoints.forEach((loopPoint)=>{\n            const { target, translate, slideLocation } = loopPoint;\n            const shiftLocation = target();\n            if (shiftLocation === slideLocation.get()) return;\n            translate.to(shiftLocation);\n            slideLocation.set(shiftLocation);\n        });\n    }\n    function clear() {\n        loopPoints.forEach((loopPoint)=>loopPoint.translate.clear());\n    }\n    const self = {\n        canLoop,\n        clear,\n        loop,\n        loopPoints\n    };\n    return self;\n}\nfunction SlidesHandler(container, eventHandler, watchSlides) {\n    let mutationObserver;\n    let destroyed = false;\n    function init(emblaApi) {\n        if (!watchSlides) return;\n        function defaultCallback(mutations) {\n            for (const mutation of mutations){\n                if (mutation.type === \"childList\") {\n                    emblaApi.reInit();\n                    eventHandler.emit(\"slidesChanged\");\n                    break;\n                }\n            }\n        }\n        mutationObserver = new MutationObserver((mutations)=>{\n            if (destroyed) return;\n            if (isBoolean(watchSlides) || watchSlides(emblaApi, mutations)) {\n                defaultCallback(mutations);\n            }\n        });\n        mutationObserver.observe(container, {\n            childList: true\n        });\n    }\n    function destroy() {\n        if (mutationObserver) mutationObserver.disconnect();\n        destroyed = true;\n    }\n    const self = {\n        init,\n        destroy\n    };\n    return self;\n}\nfunction SlidesInView(container, slides, eventHandler, threshold) {\n    const intersectionEntryMap = {};\n    let inViewCache = null;\n    let notInViewCache = null;\n    let intersectionObserver;\n    let destroyed = false;\n    function init() {\n        intersectionObserver = new IntersectionObserver((entries)=>{\n            if (destroyed) return;\n            entries.forEach((entry)=>{\n                const index = slides.indexOf(entry.target);\n                intersectionEntryMap[index] = entry;\n            });\n            inViewCache = null;\n            notInViewCache = null;\n            eventHandler.emit(\"slidesInView\");\n        }, {\n            root: container.parentElement,\n            threshold\n        });\n        slides.forEach((slide)=>intersectionObserver.observe(slide));\n    }\n    function destroy() {\n        if (intersectionObserver) intersectionObserver.disconnect();\n        destroyed = true;\n    }\n    function createInViewList(inView) {\n        return objectKeys(intersectionEntryMap).reduce((list, slideIndex)=>{\n            const index = parseInt(slideIndex);\n            const { isIntersecting } = intersectionEntryMap[index];\n            const inViewMatch = inView && isIntersecting;\n            const notInViewMatch = !inView && !isIntersecting;\n            if (inViewMatch || notInViewMatch) list.push(index);\n            return list;\n        }, []);\n    }\n    function get(inView = true) {\n        if (inView && inViewCache) return inViewCache;\n        if (!inView && notInViewCache) return notInViewCache;\n        const slideIndexes = createInViewList(inView);\n        if (inView) inViewCache = slideIndexes;\n        if (!inView) notInViewCache = slideIndexes;\n        return slideIndexes;\n    }\n    const self = {\n        init,\n        destroy,\n        get\n    };\n    return self;\n}\nfunction SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow) {\n    const { measureSize, startEdge, endEdge } = axis;\n    const withEdgeGap = slideRects[0] && readEdgeGap;\n    const startGap = measureStartGap();\n    const endGap = measureEndGap();\n    const slideSizes = slideRects.map(measureSize);\n    const slideSizesWithGaps = measureWithGaps();\n    function measureStartGap() {\n        if (!withEdgeGap) return 0;\n        const slideRect = slideRects[0];\n        return mathAbs(containerRect[startEdge] - slideRect[startEdge]);\n    }\n    function measureEndGap() {\n        if (!withEdgeGap) return 0;\n        const style = ownerWindow.getComputedStyle(arrayLast(slides));\n        return parseFloat(style.getPropertyValue(`margin-${endEdge}`));\n    }\n    function measureWithGaps() {\n        return slideRects.map((rect, index, rects)=>{\n            const isFirst = !index;\n            const isLast = arrayIsLastIndex(rects, index);\n            if (isFirst) return slideSizes[index] + startGap;\n            if (isLast) return slideSizes[index] + endGap;\n            return rects[index + 1][startEdge] - rect[startEdge];\n        }).map(mathAbs);\n    }\n    const self = {\n        slideSizes,\n        slideSizesWithGaps,\n        startGap,\n        endGap\n    };\n    return self;\n}\nfunction SlidesToScroll(axis, viewSize, slidesToScroll, loop, containerRect, slideRects, startGap, endGap, pixelTolerance) {\n    const { startEdge, endEdge, direction } = axis;\n    const groupByNumber = isNumber(slidesToScroll);\n    function byNumber(array, groupSize) {\n        return arrayKeys(array).filter((i)=>i % groupSize === 0).map((i)=>array.slice(i, i + groupSize));\n    }\n    function bySize(array) {\n        if (!array.length) return [];\n        return arrayKeys(array).reduce((groups, rectB, index)=>{\n            const rectA = arrayLast(groups) || 0;\n            const isFirst = rectA === 0;\n            const isLast = rectB === arrayLastIndex(array);\n            const edgeA = containerRect[startEdge] - slideRects[rectA][startEdge];\n            const edgeB = containerRect[startEdge] - slideRects[rectB][endEdge];\n            const gapA = !loop && isFirst ? direction(startGap) : 0;\n            const gapB = !loop && isLast ? direction(endGap) : 0;\n            const chunkSize = mathAbs(edgeB - gapB - (edgeA + gapA));\n            if (index && chunkSize > viewSize + pixelTolerance) groups.push(rectB);\n            if (isLast) groups.push(array.length);\n            return groups;\n        }, []).map((currentSize, index, groups)=>{\n            const previousSize = Math.max(groups[index - 1] || 0);\n            return array.slice(previousSize, currentSize);\n        });\n    }\n    function groupSlides(array) {\n        return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array);\n    }\n    const self = {\n        groupSlides\n    };\n    return self;\n}\nfunction Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler) {\n    // Options\n    const { align, axis: scrollAxis, direction, startIndex, loop, duration, dragFree, dragThreshold, inViewThreshold, slidesToScroll: groupSlides, skipSnaps, containScroll, watchResize, watchSlides, watchDrag, watchFocus } = options;\n    // Measurements\n    const pixelTolerance = 2;\n    const nodeRects = NodeRects();\n    const containerRect = nodeRects.measure(container);\n    const slideRects = slides.map(nodeRects.measure);\n    const axis = Axis(scrollAxis, direction);\n    const viewSize = axis.measureSize(containerRect);\n    const percentOfView = PercentOfView(viewSize);\n    const alignment = Alignment(align, viewSize);\n    const containSnaps = !loop && !!containScroll;\n    const readEdgeGap = loop || !!containScroll;\n    const { slideSizes, slideSizesWithGaps, startGap, endGap } = SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow);\n    const slidesToScroll = SlidesToScroll(axis, viewSize, groupSlides, loop, containerRect, slideRects, startGap, endGap, pixelTolerance);\n    const { snaps, snapsAligned } = ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll);\n    const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps);\n    const { snapsContained, scrollContainLimit } = ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance);\n    const scrollSnaps = containSnaps ? snapsContained : snapsAligned;\n    const { limit } = ScrollLimit(contentSize, scrollSnaps, loop);\n    // Indexes\n    const index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop);\n    const indexPrevious = index.clone();\n    const slideIndexes = arrayKeys(slides);\n    // Animation\n    const update = ({ dragHandler, scrollBody, scrollBounds, options: { loop } })=>{\n        if (!loop) scrollBounds.constrain(dragHandler.pointerDown());\n        scrollBody.seek();\n    };\n    const render = ({ scrollBody, translate, location, offsetLocation, previousLocation, scrollLooper, slideLooper, dragHandler, animation, eventHandler, scrollBounds, options: { loop } }, alpha)=>{\n        const shouldSettle = scrollBody.settled();\n        const withinBounds = !scrollBounds.shouldConstrain();\n        const hasSettled = loop ? shouldSettle : shouldSettle && withinBounds;\n        if (hasSettled && !dragHandler.pointerDown()) {\n            animation.stop();\n            eventHandler.emit(\"settle\");\n        }\n        if (!hasSettled) eventHandler.emit(\"scroll\");\n        const interpolatedLocation = location.get() * alpha + previousLocation.get() * (1 - alpha);\n        offsetLocation.set(interpolatedLocation);\n        if (loop) {\n            scrollLooper.loop(scrollBody.direction());\n            slideLooper.loop();\n        }\n        translate.to(offsetLocation.get());\n    };\n    const animation = Animations(ownerDocument, ownerWindow, ()=>update(engine), (alpha)=>render(engine, alpha));\n    // Shared\n    const friction = 0.68;\n    const startLocation = scrollSnaps[index.get()];\n    const location = Vector1D(startLocation);\n    const previousLocation = Vector1D(startLocation);\n    const offsetLocation = Vector1D(startLocation);\n    const target = Vector1D(startLocation);\n    const scrollBody = ScrollBody(location, offsetLocation, previousLocation, target, duration, friction);\n    const scrollTarget = ScrollTarget(loop, scrollSnaps, contentSize, limit, target);\n    const scrollTo = ScrollTo(animation, index, indexPrevious, scrollBody, scrollTarget, target, eventHandler);\n    const scrollProgress = ScrollProgress(limit);\n    const eventStore = EventStore();\n    const slidesInView = SlidesInView(container, slides, eventHandler, inViewThreshold);\n    const { slideRegistry } = SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes);\n    const slideFocus = SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus);\n    // Engine\n    const engine = {\n        ownerDocument,\n        ownerWindow,\n        eventHandler,\n        containerRect,\n        slideRects,\n        animation,\n        axis,\n        dragHandler: DragHandler(axis, root, ownerDocument, ownerWindow, target, DragTracker(axis, ownerWindow), location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, friction, watchDrag),\n        eventStore,\n        percentOfView,\n        index,\n        indexPrevious,\n        limit,\n        location,\n        offsetLocation,\n        previousLocation,\n        options,\n        resizeHandler: ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects),\n        scrollBody,\n        scrollBounds: ScrollBounds(limit, offsetLocation, target, scrollBody, percentOfView),\n        scrollLooper: ScrollLooper(contentSize, limit, offsetLocation, [\n            location,\n            offsetLocation,\n            previousLocation,\n            target\n        ]),\n        scrollProgress,\n        scrollSnapList: scrollSnaps.map(scrollProgress.get),\n        scrollSnaps,\n        scrollTarget,\n        scrollTo,\n        slideLooper: SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, offsetLocation, slides),\n        slideFocus,\n        slidesHandler: SlidesHandler(container, eventHandler, watchSlides),\n        slidesInView,\n        slideIndexes,\n        slideRegistry,\n        slidesToScroll,\n        target,\n        translate: Translate(axis, container)\n    };\n    return engine;\n}\nfunction EventHandler() {\n    let listeners = {};\n    let api;\n    function init(emblaApi) {\n        api = emblaApi;\n    }\n    function getListeners(evt) {\n        return listeners[evt] || [];\n    }\n    function emit(evt) {\n        getListeners(evt).forEach((e)=>e(api, evt));\n        return self;\n    }\n    function on(evt, cb) {\n        listeners[evt] = getListeners(evt).concat([\n            cb\n        ]);\n        return self;\n    }\n    function off(evt, cb) {\n        listeners[evt] = getListeners(evt).filter((e)=>e !== cb);\n        return self;\n    }\n    function clear() {\n        listeners = {};\n    }\n    const self = {\n        init,\n        emit,\n        off,\n        on,\n        clear\n    };\n    return self;\n}\nconst defaultOptions = {\n    align: \"center\",\n    axis: \"x\",\n    container: null,\n    slides: null,\n    containScroll: \"trimSnaps\",\n    direction: \"ltr\",\n    slidesToScroll: 1,\n    inViewThreshold: 0,\n    breakpoints: {},\n    dragFree: false,\n    dragThreshold: 10,\n    loop: false,\n    skipSnaps: false,\n    duration: 25,\n    startIndex: 0,\n    active: true,\n    watchDrag: true,\n    watchResize: true,\n    watchSlides: true,\n    watchFocus: true\n};\nfunction OptionsHandler(ownerWindow) {\n    function mergeOptions(optionsA, optionsB) {\n        return objectsMergeDeep(optionsA, optionsB || {});\n    }\n    function optionsAtMedia(options) {\n        const optionsAtMedia = options.breakpoints || {};\n        const matchedMediaOptions = objectKeys(optionsAtMedia).filter((media)=>ownerWindow.matchMedia(media).matches).map((media)=>optionsAtMedia[media]).reduce((a, mediaOption)=>mergeOptions(a, mediaOption), {});\n        return mergeOptions(options, matchedMediaOptions);\n    }\n    function optionsMediaQueries(optionsList) {\n        return optionsList.map((options)=>objectKeys(options.breakpoints || {})).reduce((acc, mediaQueries)=>acc.concat(mediaQueries), []).map(ownerWindow.matchMedia);\n    }\n    const self = {\n        mergeOptions,\n        optionsAtMedia,\n        optionsMediaQueries\n    };\n    return self;\n}\nfunction PluginsHandler(optionsHandler) {\n    let activePlugins = [];\n    function init(emblaApi, plugins) {\n        activePlugins = plugins.filter(({ options })=>optionsHandler.optionsAtMedia(options).active !== false);\n        activePlugins.forEach((plugin)=>plugin.init(emblaApi, optionsHandler));\n        return plugins.reduce((map, plugin)=>Object.assign(map, {\n                [plugin.name]: plugin\n            }), {});\n    }\n    function destroy() {\n        activePlugins = activePlugins.filter((plugin)=>plugin.destroy());\n    }\n    const self = {\n        init,\n        destroy\n    };\n    return self;\n}\nfunction EmblaCarousel(root, userOptions, userPlugins) {\n    const ownerDocument = root.ownerDocument;\n    const ownerWindow = ownerDocument.defaultView;\n    const optionsHandler = OptionsHandler(ownerWindow);\n    const pluginsHandler = PluginsHandler(optionsHandler);\n    const mediaHandlers = EventStore();\n    const eventHandler = EventHandler();\n    const { mergeOptions, optionsAtMedia, optionsMediaQueries } = optionsHandler;\n    const { on, off, emit } = eventHandler;\n    const reInit = reActivate;\n    let destroyed = false;\n    let engine;\n    let optionsBase = mergeOptions(defaultOptions, EmblaCarousel.globalOptions);\n    let options = mergeOptions(optionsBase);\n    let pluginList = [];\n    let pluginApis;\n    let container;\n    let slides;\n    function storeElements() {\n        const { container: userContainer, slides: userSlides } = options;\n        const customContainer = isString(userContainer) ? root.querySelector(userContainer) : userContainer;\n        container = customContainer || root.children[0];\n        const customSlides = isString(userSlides) ? container.querySelectorAll(userSlides) : userSlides;\n        slides = [].slice.call(customSlides || container.children);\n    }\n    function createEngine(options) {\n        const engine = Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler);\n        if (options.loop && !engine.slideLooper.canLoop()) {\n            const optionsWithoutLoop = Object.assign({}, options, {\n                loop: false\n            });\n            return createEngine(optionsWithoutLoop);\n        }\n        return engine;\n    }\n    function activate(withOptions, withPlugins) {\n        if (destroyed) return;\n        optionsBase = mergeOptions(optionsBase, withOptions);\n        options = optionsAtMedia(optionsBase);\n        pluginList = withPlugins || pluginList;\n        storeElements();\n        engine = createEngine(options);\n        optionsMediaQueries([\n            optionsBase,\n            ...pluginList.map(({ options })=>options)\n        ]).forEach((query)=>mediaHandlers.add(query, \"change\", reActivate));\n        if (!options.active) return;\n        engine.translate.to(engine.location.get());\n        engine.animation.init();\n        engine.slidesInView.init();\n        engine.slideFocus.init(self);\n        engine.eventHandler.init(self);\n        engine.resizeHandler.init(self);\n        engine.slidesHandler.init(self);\n        if (engine.options.loop) engine.slideLooper.loop();\n        if (container.offsetParent && slides.length) engine.dragHandler.init(self);\n        pluginApis = pluginsHandler.init(self, pluginList);\n    }\n    function reActivate(withOptions, withPlugins) {\n        const startIndex = selectedScrollSnap();\n        deActivate();\n        activate(mergeOptions({\n            startIndex\n        }, withOptions), withPlugins);\n        eventHandler.emit(\"reInit\");\n    }\n    function deActivate() {\n        engine.dragHandler.destroy();\n        engine.eventStore.clear();\n        engine.translate.clear();\n        engine.slideLooper.clear();\n        engine.resizeHandler.destroy();\n        engine.slidesHandler.destroy();\n        engine.slidesInView.destroy();\n        engine.animation.destroy();\n        pluginsHandler.destroy();\n        mediaHandlers.clear();\n    }\n    function destroy() {\n        if (destroyed) return;\n        destroyed = true;\n        mediaHandlers.clear();\n        deActivate();\n        eventHandler.emit(\"destroy\");\n        eventHandler.clear();\n    }\n    function scrollTo(index, jump, direction) {\n        if (!options.active || destroyed) return;\n        engine.scrollBody.useBaseFriction().useDuration(jump === true ? 0 : options.duration);\n        engine.scrollTo.index(index, direction || 0);\n    }\n    function scrollNext(jump) {\n        const next = engine.index.add(1).get();\n        scrollTo(next, jump, -1);\n    }\n    function scrollPrev(jump) {\n        const prev = engine.index.add(-1).get();\n        scrollTo(prev, jump, 1);\n    }\n    function canScrollNext() {\n        const next = engine.index.add(1).get();\n        return next !== selectedScrollSnap();\n    }\n    function canScrollPrev() {\n        const prev = engine.index.add(-1).get();\n        return prev !== selectedScrollSnap();\n    }\n    function scrollSnapList() {\n        return engine.scrollSnapList;\n    }\n    function scrollProgress() {\n        return engine.scrollProgress.get(engine.location.get());\n    }\n    function selectedScrollSnap() {\n        return engine.index.get();\n    }\n    function previousScrollSnap() {\n        return engine.indexPrevious.get();\n    }\n    function slidesInView() {\n        return engine.slidesInView.get();\n    }\n    function slidesNotInView() {\n        return engine.slidesInView.get(false);\n    }\n    function plugins() {\n        return pluginApis;\n    }\n    function internalEngine() {\n        return engine;\n    }\n    function rootNode() {\n        return root;\n    }\n    function containerNode() {\n        return container;\n    }\n    function slideNodes() {\n        return slides;\n    }\n    const self = {\n        canScrollNext,\n        canScrollPrev,\n        containerNode,\n        internalEngine,\n        destroy,\n        off,\n        on,\n        emit,\n        plugins,\n        previousScrollSnap,\n        reInit,\n        rootNode,\n        scrollNext,\n        scrollPrev,\n        scrollProgress,\n        scrollSnapList,\n        scrollTo,\n        selectedScrollSnap,\n        slideNodes,\n        slidesInView,\n        slidesNotInView\n    };\n    activate(userOptions, userPlugins);\n    setTimeout(()=>eventHandler.emit(\"init\"), 0);\n    return self;\n}\nEmblaCarousel.globalOptions = undefined;\n //# sourceMappingURL=embla-carousel.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZW1ibGEtY2Fyb3VzZWwvZXNtL2VtYmxhLWNhcm91c2VsLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsU0FBU0EsU0FBU0MsT0FBTztJQUN2QixPQUFPLE9BQU9BLFlBQVk7QUFDNUI7QUFDQSxTQUFTQyxTQUFTRCxPQUFPO0lBQ3ZCLE9BQU8sT0FBT0EsWUFBWTtBQUM1QjtBQUNBLFNBQVNFLFVBQVVGLE9BQU87SUFDeEIsT0FBTyxPQUFPQSxZQUFZO0FBQzVCO0FBQ0EsU0FBU0csU0FBU0gsT0FBTztJQUN2QixPQUFPSSxPQUFPQyxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDUCxhQUFhO0FBQ3JEO0FBQ0EsU0FBU1EsUUFBUUMsQ0FBQztJQUNoQixPQUFPQyxLQUFLQyxHQUFHLENBQUNGO0FBQ2xCO0FBQ0EsU0FBU0csU0FBU0gsQ0FBQztJQUNqQixPQUFPQyxLQUFLRyxJQUFJLENBQUNKO0FBQ25CO0FBQ0EsU0FBU0ssU0FBU0MsTUFBTSxFQUFFQyxNQUFNO0lBQzlCLE9BQU9SLFFBQVFPLFNBQVNDO0FBQzFCO0FBQ0EsU0FBU0MsVUFBVUYsTUFBTSxFQUFFQyxNQUFNO0lBQy9CLElBQUlELFdBQVcsS0FBS0MsV0FBVyxHQUFHLE9BQU87SUFDekMsSUFBSVIsUUFBUU8sV0FBV1AsUUFBUVEsU0FBUyxPQUFPO0lBQy9DLE1BQU1FLE9BQU9KLFNBQVNOLFFBQVFPLFNBQVNQLFFBQVFRO0lBQy9DLE9BQU9SLFFBQVFVLE9BQU9IO0FBQ3hCO0FBQ0EsU0FBU0ksbUJBQW1CQyxHQUFHO0lBQzdCLE9BQU9WLEtBQUtXLEtBQUssQ0FBQ0QsTUFBTSxPQUFPO0FBQ2pDO0FBQ0EsU0FBU0UsVUFBVUMsS0FBSztJQUN0QixPQUFPQyxXQUFXRCxPQUFPRSxHQUFHLENBQUNDO0FBQy9CO0FBQ0EsU0FBU0MsVUFBVUosS0FBSztJQUN0QixPQUFPQSxLQUFLLENBQUNLLGVBQWVMLE9BQU87QUFDckM7QUFDQSxTQUFTSyxl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U0FBUzZVO1FBQ1AsT0FBTzVVO0lBQ1Q7SUFDQSxNQUFNOUssT0FBTztRQUNYb2Y7UUFDQUM7UUFDQUk7UUFDQUQ7UUFDQTFkO1FBQ0E4WjtRQUNBRjtRQUNBclQ7UUFDQTJVO1FBQ0FzQztRQUNBclQ7UUFDQTFIO1FBQ0EwYTtRQUNBQztRQUNBbEU7UUFDQUk7UUFDQXhXO1FBQ0FrYTtRQUNBWTtRQUNBekU7UUFDQXNFO0lBQ0Y7SUFDQWQsU0FBU3BCLGFBQWFDO0lBQ3RCcUMsV0FBVyxJQUFNNWEsYUFBYXNELElBQUksQ0FBQyxTQUFTO0lBQzVDLE9BQU9ySTtBQUNUO0FBQ0FvZCxjQUFjUSxhQUFhLEdBQUdoWDtBQUVNLENBQ3BDLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL2FkbWlzc2lvbi11cGxpZnQvLi9ub2RlX21vZHVsZXMvZW1ibGEtY2Fyb3VzZWwvZXNtL2VtYmxhLWNhcm91c2VsLmVzbS5qcz8yZDgwIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGlzTnVtYmVyKHN1YmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdWJqZWN0ID09PSAnbnVtYmVyJztcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nKHN1YmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdWJqZWN0ID09PSAnc3RyaW5nJztcbn1cbmZ1bmN0aW9uIGlzQm9vbGVhbihzdWJqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygc3ViamVjdCA9PT0gJ2Jvb2xlYW4nO1xufVxuZnVuY3Rpb24gaXNPYmplY3Qoc3ViamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN1YmplY3QpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cbmZ1bmN0aW9uIG1hdGhBYnMobikge1xuICByZXR1cm4gTWF0aC5hYnMobik7XG59XG5mdW5jdGlvbiBtYXRoU2lnbihuKSB7XG4gIHJldHVybiBNYXRoLnNpZ24obik7XG59XG5mdW5jdGlvbiBkZWx0YUFicyh2YWx1ZUIsIHZhbHVlQSkge1xuICByZXR1cm4gbWF0aEFicyh2YWx1ZUIgLSB2YWx1ZUEpO1xufVxuZnVuY3Rpb24gZmFjdG9yQWJzKHZhbHVlQiwgdmFsdWVBKSB7XG4gIGlmICh2YWx1ZUIgPT09IDAgfHwgdmFsdWVBID09PSAwKSByZXR1cm4gMDtcbiAgaWYgKG1hdGhBYnModmFsdWVCKSA8PSBtYXRoQWJzKHZhbHVlQSkpIHJldHVybiAwO1xuICBjb25zdCBkaWZmID0gZGVsdGFBYnMobWF0aEFicyh2YWx1ZUIpLCBtYXRoQWJzKHZhbHVlQSkpO1xuICByZXR1cm4gbWF0aEFicyhkaWZmIC8gdmFsdWVCKTtcbn1cbmZ1bmN0aW9uIHJvdW5kVG9Ud29EZWNpbWFscyhudW0pIHtcbiAgcmV0dXJuIE1hdGgucm91bmQobnVtICogMTAwKSAvIDEwMDtcbn1cbmZ1bmN0aW9uIGFycmF5S2V5cyhhcnJheSkge1xuICByZXR1cm4gb2JqZWN0S2V5cyhhcnJheSkubWFwKE51bWJlcik7XG59XG5mdW5jdGlvbiBhcnJheUxhc3QoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5W2FycmF5TGFzdEluZGV4KGFycmF5KV07XG59XG5mdW5jdGlvbiBhcnJheUxhc3RJbmRleChhcnJheSkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gMSk7XG59XG5mdW5jdGlvbiBhcnJheUlzTGFzdEluZGV4KGFycmF5LCBpbmRleCkge1xuICByZXR1cm4gaW5kZXggPT09IGFycmF5TGFzdEluZGV4KGFycmF5KTtcbn1cbmZ1bmN0aW9uIGFycmF5RnJvbU51bWJlcihuLCBzdGFydEF0ID0gMCkge1xuICByZXR1cm4gQXJyYXkuZnJvbShBcnJheShuKSwgKF8sIGkpID0+IHN0YXJ0QXQgKyBpKTtcbn1cbmZ1bmN0aW9uIG9iamVjdEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpO1xufVxuZnVuY3Rpb24gb2JqZWN0c01lcmdlRGVlcChvYmplY3RBLCBvYmplY3RCKSB7XG4gIHJldHVybiBbb2JqZWN0QSwgb2JqZWN0Ql0ucmVkdWNlKChtZXJnZWRPYmplY3RzLCBjdXJyZW50T2JqZWN0KSA9PiB7XG4gICAgb2JqZWN0S2V5cyhjdXJyZW50T2JqZWN0KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZUEgPSBtZXJnZWRPYmplY3RzW2tleV07XG4gICAgICBjb25zdCB2YWx1ZUIgPSBjdXJyZW50T2JqZWN0W2tleV07XG4gICAgICBjb25zdCBhcmVPYmplY3RzID0gaXNPYmplY3QodmFsdWVBKSAmJiBpc09iamVjdCh2YWx1ZUIpO1xuICAgICAgbWVyZ2VkT2JqZWN0c1trZXldID0gYXJlT2JqZWN0cyA/IG9iamVjdHNNZXJnZURlZXAodmFsdWVBLCB2YWx1ZUIpIDogdmFsdWVCO1xuICAgIH0pO1xuICAgIHJldHVybiBtZXJnZWRPYmplY3RzO1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBpc01vdXNlRXZlbnQoZXZ0LCBvd25lcldpbmRvdykge1xuICByZXR1cm4gdHlwZW9mIG93bmVyV2luZG93Lk1vdXNlRXZlbnQgIT09ICd1bmRlZmluZWQnICYmIGV2dCBpbnN0YW5jZW9mIG93bmVyV2luZG93Lk1vdXNlRXZlbnQ7XG59XG5cbmZ1bmN0aW9uIEFsaWdubWVudChhbGlnbiwgdmlld1NpemUpIHtcbiAgY29uc3QgcHJlZGVmaW5lZCA9IHtcbiAgICBzdGFydCxcbiAgICBjZW50ZXIsXG4gICAgZW5kXG4gIH07XG4gIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGZ1bmN0aW9uIGNlbnRlcihuKSB7XG4gICAgcmV0dXJuIGVuZChuKSAvIDI7XG4gIH1cbiAgZnVuY3Rpb24gZW5kKG4pIHtcbiAgICByZXR1cm4gdmlld1NpemUgLSBuO1xuICB9XG4gIGZ1bmN0aW9uIG1lYXN1cmUobiwgaW5kZXgpIHtcbiAgICBpZiAoaXNTdHJpbmcoYWxpZ24pKSByZXR1cm4gcHJlZGVmaW5lZFthbGlnbl0obik7XG4gICAgcmV0dXJuIGFsaWduKHZpZXdTaXplLCBuLCBpbmRleCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBtZWFzdXJlXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBFdmVudFN0b3JlKCkge1xuICBsZXQgbGlzdGVuZXJzID0gW107XG4gIGZ1bmN0aW9uIGFkZChub2RlLCB0eXBlLCBoYW5kbGVyLCBvcHRpb25zID0ge1xuICAgIHBhc3NpdmU6IHRydWVcbiAgfSkge1xuICAgIGxldCByZW1vdmVMaXN0ZW5lcjtcbiAgICBpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIG5vZGUpIHtcbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyID0gKCkgPT4gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsZWdhY3lNZWRpYVF1ZXJ5TGlzdCA9IG5vZGU7XG4gICAgICBsZWdhY3lNZWRpYVF1ZXJ5TGlzdC5hZGRMaXN0ZW5lcihoYW5kbGVyKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyID0gKCkgPT4gbGVnYWN5TWVkaWFRdWVyeUxpc3QucmVtb3ZlTGlzdGVuZXIoaGFuZGxlcik7XG4gICAgfVxuICAgIGxpc3RlbmVycy5wdXNoKHJlbW92ZUxpc3RlbmVyKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKHJlbW92ZSA9PiByZW1vdmUoKSk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBhZGQsXG4gICAgY2xlYXJcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbnMob3duZXJEb2N1bWVudCwgb3duZXJXaW5kb3csIHVwZGF0ZSwgcmVuZGVyKSB7XG4gIGNvbnN0IGRvY3VtZW50VmlzaWJsZUhhbmRsZXIgPSBFdmVudFN0b3JlKCk7XG4gIGNvbnN0IGZpeGVkVGltZVN0ZXAgPSAxMDAwIC8gNjA7XG4gIGxldCBsYXN0VGltZVN0YW1wID0gbnVsbDtcbiAgbGV0IGFjY3VtdWxhdGVkVGltZSA9IDA7XG4gIGxldCBhbmltYXRpb25JZCA9IDA7XG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgZG9jdW1lbnRWaXNpYmxlSGFuZGxlci5hZGQob3duZXJEb2N1bWVudCwgJ3Zpc2liaWxpdHljaGFuZ2UnLCAoKSA9PiB7XG4gICAgICBpZiAob3duZXJEb2N1bWVudC5oaWRkZW4pIHJlc2V0KCk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBzdG9wKCk7XG4gICAgZG9jdW1lbnRWaXNpYmxlSGFuZGxlci5jbGVhcigpO1xuICB9XG4gIGZ1bmN0aW9uIGFuaW1hdGUodGltZVN0YW1wKSB7XG4gICAgaWYgKCFhbmltYXRpb25JZCkgcmV0dXJuO1xuICAgIGlmICghbGFzdFRpbWVTdGFtcCkgbGFzdFRpbWVTdGFtcCA9IHRpbWVTdGFtcDtcbiAgICBjb25zdCB0aW1lRWxhcHNlZCA9IHRpbWVTdGFtcCAtIGxhc3RUaW1lU3RhbXA7XG4gICAgbGFzdFRpbWVTdGFtcCA9IHRpbWVTdGFtcDtcbiAgICBhY2N1bXVsYXRlZFRpbWUgKz0gdGltZUVsYXBzZWQ7XG4gICAgd2hpbGUgKGFjY3VtdWxhdGVkVGltZSA+PSBmaXhlZFRpbWVTdGVwKSB7XG4gICAgICB1cGRhdGUoKTtcbiAgICAgIGFjY3VtdWxhdGVkVGltZSAtPSBmaXhlZFRpbWVTdGVwO1xuICAgIH1cbiAgICBjb25zdCBhbHBoYSA9IGFjY3VtdWxhdGVkVGltZSAvIGZpeGVkVGltZVN0ZXA7XG4gICAgcmVuZGVyKGFscGhhKTtcbiAgICBpZiAoYW5pbWF0aW9uSWQpIHtcbiAgICAgIGFuaW1hdGlvbklkID0gb3duZXJXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICBpZiAoYW5pbWF0aW9uSWQpIHJldHVybjtcbiAgICBhbmltYXRpb25JZCA9IG93bmVyV2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgfVxuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgIG93bmVyV2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbklkKTtcbiAgICBsYXN0VGltZVN0YW1wID0gbnVsbDtcbiAgICBhY2N1bXVsYXRlZFRpbWUgPSAwO1xuICAgIGFuaW1hdGlvbklkID0gMDtcbiAgfVxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBsYXN0VGltZVN0YW1wID0gbnVsbDtcbiAgICBhY2N1bXVsYXRlZFRpbWUgPSAwO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgaW5pdCxcbiAgICBkZXN0cm95LFxuICAgIHN0YXJ0LFxuICAgIHN0b3AsXG4gICAgdXBkYXRlLFxuICAgIHJlbmRlclxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gQXhpcyhheGlzLCBjb250ZW50RGlyZWN0aW9uKSB7XG4gIGNvbnN0IGlzUmlnaHRUb0xlZnQgPSBjb250ZW50RGlyZWN0aW9uID09PSAncnRsJztcbiAgY29uc3QgaXNWZXJ0aWNhbCA9IGF4aXMgPT09ICd5JztcbiAgY29uc3Qgc2Nyb2xsID0gaXNWZXJ0aWNhbCA/ICd5JyA6ICd4JztcbiAgY29uc3QgY3Jvc3MgPSBpc1ZlcnRpY2FsID8gJ3gnIDogJ3knO1xuICBjb25zdCBzaWduID0gIWlzVmVydGljYWwgJiYgaXNSaWdodFRvTGVmdCA/IC0xIDogMTtcbiAgY29uc3Qgc3RhcnRFZGdlID0gZ2V0U3RhcnRFZGdlKCk7XG4gIGNvbnN0IGVuZEVkZ2UgPSBnZXRFbmRFZGdlKCk7XG4gIGZ1bmN0aW9uIG1lYXN1cmVTaXplKG5vZGVSZWN0KSB7XG4gICAgY29uc3Qge1xuICAgICAgaGVpZ2h0LFxuICAgICAgd2lkdGhcbiAgICB9ID0gbm9kZVJlY3Q7XG4gICAgcmV0dXJuIGlzVmVydGljYWwgPyBoZWlnaHQgOiB3aWR0aDtcbiAgfVxuICBmdW5jdGlvbiBnZXRTdGFydEVkZ2UoKSB7XG4gICAgaWYgKGlzVmVydGljYWwpIHJldHVybiAndG9wJztcbiAgICByZXR1cm4gaXNSaWdodFRvTGVmdCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RW5kRWRnZSgpIHtcbiAgICBpZiAoaXNWZXJ0aWNhbCkgcmV0dXJuICdib3R0b20nO1xuICAgIHJldHVybiBpc1JpZ2h0VG9MZWZ0ID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgfVxuICBmdW5jdGlvbiBkaXJlY3Rpb24obikge1xuICAgIHJldHVybiBuICogc2lnbjtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIHNjcm9sbCxcbiAgICBjcm9zcyxcbiAgICBzdGFydEVkZ2UsXG4gICAgZW5kRWRnZSxcbiAgICBtZWFzdXJlU2l6ZSxcbiAgICBkaXJlY3Rpb25cbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIExpbWl0KG1pbiA9IDAsIG1heCA9IDApIHtcbiAgY29uc3QgbGVuZ3RoID0gbWF0aEFicyhtaW4gLSBtYXgpO1xuICBmdW5jdGlvbiByZWFjaGVkTWluKG4pIHtcbiAgICByZXR1cm4gbiA8IG1pbjtcbiAgfVxuICBmdW5jdGlvbiByZWFjaGVkTWF4KG4pIHtcbiAgICByZXR1cm4gbiA+IG1heDtcbiAgfVxuICBmdW5jdGlvbiByZWFjaGVkQW55KG4pIHtcbiAgICByZXR1cm4gcmVhY2hlZE1pbihuKSB8fCByZWFjaGVkTWF4KG4pO1xuICB9XG4gIGZ1bmN0aW9uIGNvbnN0cmFpbihuKSB7XG4gICAgaWYgKCFyZWFjaGVkQW55KG4pKSByZXR1cm4gbjtcbiAgICByZXR1cm4gcmVhY2hlZE1pbihuKSA/IG1pbiA6IG1heDtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVPZmZzZXQobikge1xuICAgIGlmICghbGVuZ3RoKSByZXR1cm4gbjtcbiAgICByZXR1cm4gbiAtIGxlbmd0aCAqIE1hdGguY2VpbCgobiAtIG1heCkgLyBsZW5ndGgpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgbGVuZ3RoLFxuICAgIG1heCxcbiAgICBtaW4sXG4gICAgY29uc3RyYWluLFxuICAgIHJlYWNoZWRBbnksXG4gICAgcmVhY2hlZE1heCxcbiAgICByZWFjaGVkTWluLFxuICAgIHJlbW92ZU9mZnNldFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gQ291bnRlcihtYXgsIHN0YXJ0LCBsb29wKSB7XG4gIGNvbnN0IHtcbiAgICBjb25zdHJhaW5cbiAgfSA9IExpbWl0KDAsIG1heCk7XG4gIGNvbnN0IGxvb3BFbmQgPSBtYXggKyAxO1xuICBsZXQgY291bnRlciA9IHdpdGhpbkxpbWl0KHN0YXJ0KTtcbiAgZnVuY3Rpb24gd2l0aGluTGltaXQobikge1xuICAgIHJldHVybiAhbG9vcCA/IGNvbnN0cmFpbihuKSA6IG1hdGhBYnMoKGxvb3BFbmQgKyBuKSAlIGxvb3BFbmQpO1xuICB9XG4gIGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfVxuICBmdW5jdGlvbiBzZXQobikge1xuICAgIGNvdW50ZXIgPSB3aXRoaW5MaW1pdChuKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBmdW5jdGlvbiBhZGQobikge1xuICAgIHJldHVybiBjbG9uZSgpLnNldChnZXQoKSArIG4pO1xuICB9XG4gIGZ1bmN0aW9uIGNsb25lKCkge1xuICAgIHJldHVybiBDb3VudGVyKG1heCwgZ2V0KCksIGxvb3ApO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgZ2V0LFxuICAgIHNldCxcbiAgICBhZGQsXG4gICAgY2xvbmVcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIERyYWdIYW5kbGVyKGF4aXMsIHJvb3ROb2RlLCBvd25lckRvY3VtZW50LCBvd25lcldpbmRvdywgdGFyZ2V0LCBkcmFnVHJhY2tlciwgbG9jYXRpb24sIGFuaW1hdGlvbiwgc2Nyb2xsVG8sIHNjcm9sbEJvZHksIHNjcm9sbFRhcmdldCwgaW5kZXgsIGV2ZW50SGFuZGxlciwgcGVyY2VudE9mVmlldywgZHJhZ0ZyZWUsIGRyYWdUaHJlc2hvbGQsIHNraXBTbmFwcywgYmFzZUZyaWN0aW9uLCB3YXRjaERyYWcpIHtcbiAgY29uc3Qge1xuICAgIGNyb3NzOiBjcm9zc0F4aXMsXG4gICAgZGlyZWN0aW9uXG4gIH0gPSBheGlzO1xuICBjb25zdCBmb2N1c05vZGVzID0gWydJTlBVVCcsICdTRUxFQ1QnLCAnVEVYVEFSRUEnXTtcbiAgY29uc3Qgbm9uUGFzc2l2ZUV2ZW50ID0ge1xuICAgIHBhc3NpdmU6IGZhbHNlXG4gIH07XG4gIGNvbnN0IGluaXRFdmVudHMgPSBFdmVudFN0b3JlKCk7XG4gIGNvbnN0IGRyYWdFdmVudHMgPSBFdmVudFN0b3JlKCk7XG4gIGNvbnN0IGdvVG9OZXh0VGhyZXNob2xkID0gTGltaXQoNTAsIDIyNSkuY29uc3RyYWluKHBlcmNlbnRPZlZpZXcubWVhc3VyZSgyMCkpO1xuICBjb25zdCBzbmFwRm9yY2VCb29zdCA9IHtcbiAgICBtb3VzZTogMzAwLFxuICAgIHRvdWNoOiA0MDBcbiAgfTtcbiAgY29uc3QgZnJlZUZvcmNlQm9vc3QgPSB7XG4gICAgbW91c2U6IDUwMCxcbiAgICB0b3VjaDogNjAwXG4gIH07XG4gIGNvbnN0IGJhc2VTcGVlZCA9IGRyYWdGcmVlID8gNDMgOiAyNTtcbiAgbGV0IGlzTW92aW5nID0gZmFsc2U7XG4gIGxldCBzdGFydFNjcm9sbCA9IDA7XG4gIGxldCBzdGFydENyb3NzID0gMDtcbiAgbGV0IHBvaW50ZXJJc0Rvd24gPSBmYWxzZTtcbiAgbGV0IHByZXZlbnRTY3JvbGwgPSBmYWxzZTtcbiAgbGV0IHByZXZlbnRDbGljayA9IGZhbHNlO1xuICBsZXQgaXNNb3VzZSA9IGZhbHNlO1xuICBmdW5jdGlvbiBpbml0KGVtYmxhQXBpKSB7XG4gICAgaWYgKCF3YXRjaERyYWcpIHJldHVybjtcbiAgICBmdW5jdGlvbiBkb3duSWZBbGxvd2VkKGV2dCkge1xuICAgICAgaWYgKGlzQm9vbGVhbih3YXRjaERyYWcpIHx8IHdhdGNoRHJhZyhlbWJsYUFwaSwgZXZ0KSkgZG93bihldnQpO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0gcm9vdE5vZGU7XG4gICAgaW5pdEV2ZW50cy5hZGQobm9kZSwgJ2RyYWdzdGFydCcsIGV2dCA9PiBldnQucHJldmVudERlZmF1bHQoKSwgbm9uUGFzc2l2ZUV2ZW50KS5hZGQobm9kZSwgJ3RvdWNobW92ZScsICgpID0+IHVuZGVmaW5lZCwgbm9uUGFzc2l2ZUV2ZW50KS5hZGQobm9kZSwgJ3RvdWNoZW5kJywgKCkgPT4gdW5kZWZpbmVkKS5hZGQobm9kZSwgJ3RvdWNoc3RhcnQnLCBkb3duSWZBbGxvd2VkKS5hZGQobm9kZSwgJ21vdXNlZG93bicsIGRvd25JZkFsbG93ZWQpLmFkZChub2RlLCAndG91Y2hjYW5jZWwnLCB1cCkuYWRkKG5vZGUsICdjb250ZXh0bWVudScsIHVwKS5hZGQobm9kZSwgJ2NsaWNrJywgY2xpY2ssIHRydWUpO1xuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaW5pdEV2ZW50cy5jbGVhcigpO1xuICAgIGRyYWdFdmVudHMuY2xlYXIoKTtcbiAgfVxuICBmdW5jdGlvbiBhZGREcmFnRXZlbnRzKCkge1xuICAgIGNvbnN0IG5vZGUgPSBpc01vdXNlID8gb3duZXJEb2N1bWVudCA6IHJvb3ROb2RlO1xuICAgIGRyYWdFdmVudHMuYWRkKG5vZGUsICd0b3VjaG1vdmUnLCBtb3ZlLCBub25QYXNzaXZlRXZlbnQpLmFkZChub2RlLCAndG91Y2hlbmQnLCB1cCkuYWRkKG5vZGUsICdtb3VzZW1vdmUnLCBtb3ZlLCBub25QYXNzaXZlRXZlbnQpLmFkZChub2RlLCAnbW91c2V1cCcsIHVwKTtcbiAgfVxuICBmdW5jdGlvbiBpc0ZvY3VzTm9kZShub2RlKSB7XG4gICAgY29uc3Qgbm9kZU5hbWUgPSBub2RlLm5vZGVOYW1lIHx8ICcnO1xuICAgIHJldHVybiBmb2N1c05vZGVzLmluY2x1ZGVzKG5vZGVOYW1lKTtcbiAgfVxuICBmdW5jdGlvbiBmb3JjZUJvb3N0KCkge1xuICAgIGNvbnN0IGJvb3N0ID0gZHJhZ0ZyZWUgPyBmcmVlRm9yY2VCb29zdCA6IHNuYXBGb3JjZUJvb3N0O1xuICAgIGNvbnN0IHR5cGUgPSBpc01vdXNlID8gJ21vdXNlJyA6ICd0b3VjaCc7XG4gICAgcmV0dXJuIGJvb3N0W3R5cGVdO1xuICB9XG4gIGZ1bmN0aW9uIGFsbG93ZWRGb3JjZShmb3JjZSwgdGFyZ2V0Q2hhbmdlZCkge1xuICAgIGNvbnN0IG5leHQgPSBpbmRleC5hZGQobWF0aFNpZ24oZm9yY2UpICogLTEpO1xuICAgIGNvbnN0IGJhc2VGb3JjZSA9IHNjcm9sbFRhcmdldC5ieURpc3RhbmNlKGZvcmNlLCAhZHJhZ0ZyZWUpLmRpc3RhbmNlO1xuICAgIGlmIChkcmFnRnJlZSB8fCBtYXRoQWJzKGZvcmNlKSA8IGdvVG9OZXh0VGhyZXNob2xkKSByZXR1cm4gYmFzZUZvcmNlO1xuICAgIGlmIChza2lwU25hcHMgJiYgdGFyZ2V0Q2hhbmdlZCkgcmV0dXJuIGJhc2VGb3JjZSAqIDAuNTtcbiAgICByZXR1cm4gc2Nyb2xsVGFyZ2V0LmJ5SW5kZXgobmV4dC5nZXQoKSwgMCkuZGlzdGFuY2U7XG4gIH1cbiAgZnVuY3Rpb24gZG93bihldnQpIHtcbiAgICBjb25zdCBpc01vdXNlRXZ0ID0gaXNNb3VzZUV2ZW50KGV2dCwgb3duZXJXaW5kb3cpO1xuICAgIGlzTW91c2UgPSBpc01vdXNlRXZ0O1xuICAgIHByZXZlbnRDbGljayA9IGRyYWdGcmVlICYmIGlzTW91c2VFdnQgJiYgIWV2dC5idXR0b25zICYmIGlzTW92aW5nO1xuICAgIGlzTW92aW5nID0gZGVsdGFBYnModGFyZ2V0LmdldCgpLCBsb2NhdGlvbi5nZXQoKSkgPj0gMjtcbiAgICBpZiAoaXNNb3VzZUV2dCAmJiBldnQuYnV0dG9uICE9PSAwKSByZXR1cm47XG4gICAgaWYgKGlzRm9jdXNOb2RlKGV2dC50YXJnZXQpKSByZXR1cm47XG4gICAgcG9pbnRlcklzRG93biA9IHRydWU7XG4gICAgZHJhZ1RyYWNrZXIucG9pbnRlckRvd24oZXZ0KTtcbiAgICBzY3JvbGxCb2R5LnVzZUZyaWN0aW9uKDApLnVzZUR1cmF0aW9uKDApO1xuICAgIHRhcmdldC5zZXQobG9jYXRpb24pO1xuICAgIGFkZERyYWdFdmVudHMoKTtcbiAgICBzdGFydFNjcm9sbCA9IGRyYWdUcmFja2VyLnJlYWRQb2ludChldnQpO1xuICAgIHN0YXJ0Q3Jvc3MgPSBkcmFnVHJhY2tlci5yZWFkUG9pbnQoZXZ0LCBjcm9zc0F4aXMpO1xuICAgIGV2ZW50SGFuZGxlci5lbWl0KCdwb2ludGVyRG93bicpO1xuICB9XG4gIGZ1bmN0aW9uIG1vdmUoZXZ0KSB7XG4gICAgY29uc3QgaXNUb3VjaEV2dCA9ICFpc01vdXNlRXZlbnQoZXZ0LCBvd25lcldpbmRvdyk7XG4gICAgaWYgKGlzVG91Y2hFdnQgJiYgZXZ0LnRvdWNoZXMubGVuZ3RoID49IDIpIHJldHVybiB1cChldnQpO1xuICAgIGNvbnN0IGxhc3RTY3JvbGwgPSBkcmFnVHJhY2tlci5yZWFkUG9pbnQoZXZ0KTtcbiAgICBjb25zdCBsYXN0Q3Jvc3MgPSBkcmFnVHJhY2tlci5yZWFkUG9pbnQoZXZ0LCBjcm9zc0F4aXMpO1xuICAgIGNvbnN0IGRpZmZTY3JvbGwgPSBkZWx0YUFicyhsYXN0U2Nyb2xsLCBzdGFydFNjcm9sbCk7XG4gICAgY29uc3QgZGlmZkNyb3NzID0gZGVsdGFBYnMobGFzdENyb3NzLCBzdGFydENyb3NzKTtcbiAgICBpZiAoIXByZXZlbnRTY3JvbGwgJiYgIWlzTW91c2UpIHtcbiAgICAgIGlmICghZXZ0LmNhbmNlbGFibGUpIHJldHVybiB1cChldnQpO1xuICAgICAgcHJldmVudFNjcm9sbCA9IGRpZmZTY3JvbGwgPiBkaWZmQ3Jvc3M7XG4gICAgICBpZiAoIXByZXZlbnRTY3JvbGwpIHJldHVybiB1cChldnQpO1xuICAgIH1cbiAgICBjb25zdCBkaWZmID0gZHJhZ1RyYWNrZXIucG9pbnRlck1vdmUoZXZ0KTtcbiAgICBpZiAoZGlmZlNjcm9sbCA+IGRyYWdUaHJlc2hvbGQpIHByZXZlbnRDbGljayA9IHRydWU7XG4gICAgc2Nyb2xsQm9keS51c2VGcmljdGlvbigwLjMpLnVzZUR1cmF0aW9uKDAuNzUpO1xuICAgIGFuaW1hdGlvbi5zdGFydCgpO1xuICAgIHRhcmdldC5hZGQoZGlyZWN0aW9uKGRpZmYpKTtcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBmdW5jdGlvbiB1cChldnQpIHtcbiAgICBjb25zdCBjdXJyZW50TG9jYXRpb24gPSBzY3JvbGxUYXJnZXQuYnlEaXN0YW5jZSgwLCBmYWxzZSk7XG4gICAgY29uc3QgdGFyZ2V0Q2hhbmdlZCA9IGN1cnJlbnRMb2NhdGlvbi5pbmRleCAhPT0gaW5kZXguZ2V0KCk7XG4gICAgY29uc3QgcmF3Rm9yY2UgPSBkcmFnVHJhY2tlci5wb2ludGVyVXAoZXZ0KSAqIGZvcmNlQm9vc3QoKTtcbiAgICBjb25zdCBmb3JjZSA9IGFsbG93ZWRGb3JjZShkaXJlY3Rpb24ocmF3Rm9yY2UpLCB0YXJnZXRDaGFuZ2VkKTtcbiAgICBjb25zdCBmb3JjZUZhY3RvciA9IGZhY3RvckFicyhyYXdGb3JjZSwgZm9yY2UpO1xuICAgIGNvbnN0IHNwZWVkID0gYmFzZVNwZWVkIC0gMTAgKiBmb3JjZUZhY3RvcjtcbiAgICBjb25zdCBmcmljdGlvbiA9IGJhc2VGcmljdGlvbiArIGZvcmNlRmFjdG9yIC8gNTA7XG4gICAgcHJldmVudFNjcm9sbCA9IGZhbHNlO1xuICAgIHBvaW50ZXJJc0Rvd24gPSBmYWxzZTtcbiAgICBkcmFnRXZlbnRzLmNsZWFyKCk7XG4gICAgc2Nyb2xsQm9keS51c2VEdXJhdGlvbihzcGVlZCkudXNlRnJpY3Rpb24oZnJpY3Rpb24pO1xuICAgIHNjcm9sbFRvLmRpc3RhbmNlKGZvcmNlLCAhZHJhZ0ZyZWUpO1xuICAgIGlzTW91c2UgPSBmYWxzZTtcbiAgICBldmVudEhhbmRsZXIuZW1pdCgncG9pbnRlclVwJyk7XG4gIH1cbiAgZnVuY3Rpb24gY2xpY2soZXZ0KSB7XG4gICAgaWYgKHByZXZlbnRDbGljaykge1xuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBwcmV2ZW50Q2xpY2sgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlckRvd24oKSB7XG4gICAgcmV0dXJuIHBvaW50ZXJJc0Rvd247XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0LFxuICAgIGRlc3Ryb3ksXG4gICAgcG9pbnRlckRvd25cbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIERyYWdUcmFja2VyKGF4aXMsIG93bmVyV2luZG93KSB7XG4gIGNvbnN0IGxvZ0ludGVydmFsID0gMTcwO1xuICBsZXQgc3RhcnRFdmVudDtcbiAgbGV0IGxhc3RFdmVudDtcbiAgZnVuY3Rpb24gcmVhZFRpbWUoZXZ0KSB7XG4gICAgcmV0dXJuIGV2dC50aW1lU3RhbXA7XG4gIH1cbiAgZnVuY3Rpb24gcmVhZFBvaW50KGV2dCwgZXZ0QXhpcykge1xuICAgIGNvbnN0IHByb3BlcnR5ID0gZXZ0QXhpcyB8fCBheGlzLnNjcm9sbDtcbiAgICBjb25zdCBjb29yZCA9IGBjbGllbnQke3Byb3BlcnR5ID09PSAneCcgPyAnWCcgOiAnWSd9YDtcbiAgICByZXR1cm4gKGlzTW91c2VFdmVudChldnQsIG93bmVyV2luZG93KSA/IGV2dCA6IGV2dC50b3VjaGVzWzBdKVtjb29yZF07XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlckRvd24oZXZ0KSB7XG4gICAgc3RhcnRFdmVudCA9IGV2dDtcbiAgICBsYXN0RXZlbnQgPSBldnQ7XG4gICAgcmV0dXJuIHJlYWRQb2ludChldnQpO1xuICB9XG4gIGZ1bmN0aW9uIHBvaW50ZXJNb3ZlKGV2dCkge1xuICAgIGNvbnN0IGRpZmYgPSByZWFkUG9pbnQoZXZ0KSAtIHJlYWRQb2ludChsYXN0RXZlbnQpO1xuICAgIGNvbnN0IGV4cGlyZWQgPSByZWFkVGltZShldnQpIC0gcmVhZFRpbWUoc3RhcnRFdmVudCkgPiBsb2dJbnRlcnZhbDtcbiAgICBsYXN0RXZlbnQgPSBldnQ7XG4gICAgaWYgKGV4cGlyZWQpIHN0YXJ0RXZlbnQgPSBldnQ7XG4gICAgcmV0dXJuIGRpZmY7XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlclVwKGV2dCkge1xuICAgIGlmICghc3RhcnRFdmVudCB8fCAhbGFzdEV2ZW50KSByZXR1cm4gMDtcbiAgICBjb25zdCBkaWZmRHJhZyA9IHJlYWRQb2ludChsYXN0RXZlbnQpIC0gcmVhZFBvaW50KHN0YXJ0RXZlbnQpO1xuICAgIGNvbnN0IGRpZmZUaW1lID0gcmVhZFRpbWUoZXZ0KSAtIHJlYWRUaW1lKHN0YXJ0RXZlbnQpO1xuICAgIGNvbnN0IGV4cGlyZWQgPSByZWFkVGltZShldnQpIC0gcmVhZFRpbWUobGFzdEV2ZW50KSA+IGxvZ0ludGVydmFsO1xuICAgIGNvbnN0IGZvcmNlID0gZGlmZkRyYWcgLyBkaWZmVGltZTtcbiAgICBjb25zdCBpc0ZsaWNrID0gZGlmZlRpbWUgJiYgIWV4cGlyZWQgJiYgbWF0aEFicyhmb3JjZSkgPiAwLjE7XG4gICAgcmV0dXJuIGlzRmxpY2sgPyBmb3JjZSA6IDA7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBwb2ludGVyRG93bixcbiAgICBwb2ludGVyTW92ZSxcbiAgICBwb2ludGVyVXAsXG4gICAgcmVhZFBvaW50XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBOb2RlUmVjdHMoKSB7XG4gIGZ1bmN0aW9uIG1lYXN1cmUobm9kZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9mZnNldFRvcCxcbiAgICAgIG9mZnNldExlZnQsXG4gICAgICBvZmZzZXRXaWR0aCxcbiAgICAgIG9mZnNldEhlaWdodFxuICAgIH0gPSBub2RlO1xuICAgIGNvbnN0IG9mZnNldCA9IHtcbiAgICAgIHRvcDogb2Zmc2V0VG9wLFxuICAgICAgcmlnaHQ6IG9mZnNldExlZnQgKyBvZmZzZXRXaWR0aCxcbiAgICAgIGJvdHRvbTogb2Zmc2V0VG9wICsgb2Zmc2V0SGVpZ2h0LFxuICAgICAgbGVmdDogb2Zmc2V0TGVmdCxcbiAgICAgIHdpZHRoOiBvZmZzZXRXaWR0aCxcbiAgICAgIGhlaWdodDogb2Zmc2V0SGVpZ2h0XG4gICAgfTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgbWVhc3VyZVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gUGVyY2VudE9mVmlldyh2aWV3U2l6ZSkge1xuICBmdW5jdGlvbiBtZWFzdXJlKG4pIHtcbiAgICByZXR1cm4gdmlld1NpemUgKiAobiAvIDEwMCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBtZWFzdXJlXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBSZXNpemVIYW5kbGVyKGNvbnRhaW5lciwgZXZlbnRIYW5kbGVyLCBvd25lcldpbmRvdywgc2xpZGVzLCBheGlzLCB3YXRjaFJlc2l6ZSwgbm9kZVJlY3RzKSB7XG4gIGNvbnN0IG9ic2VydmVOb2RlcyA9IFtjb250YWluZXJdLmNvbmNhdChzbGlkZXMpO1xuICBsZXQgcmVzaXplT2JzZXJ2ZXI7XG4gIGxldCBjb250YWluZXJTaXplO1xuICBsZXQgc2xpZGVTaXplcyA9IFtdO1xuICBsZXQgZGVzdHJveWVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIHJlYWRTaXplKG5vZGUpIHtcbiAgICByZXR1cm4gYXhpcy5tZWFzdXJlU2l6ZShub2RlUmVjdHMubWVhc3VyZShub2RlKSk7XG4gIH1cbiAgZnVuY3Rpb24gaW5pdChlbWJsYUFwaSkge1xuICAgIGlmICghd2F0Y2hSZXNpemUpIHJldHVybjtcbiAgICBjb250YWluZXJTaXplID0gcmVhZFNpemUoY29udGFpbmVyKTtcbiAgICBzbGlkZVNpemVzID0gc2xpZGVzLm1hcChyZWFkU2l6ZSk7XG4gICAgZnVuY3Rpb24gZGVmYXVsdENhbGxiYWNrKGVudHJpZXMpIHtcbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGlzQ29udGFpbmVyID0gZW50cnkudGFyZ2V0ID09PSBjb250YWluZXI7XG4gICAgICAgIGNvbnN0IHNsaWRlSW5kZXggPSBzbGlkZXMuaW5kZXhPZihlbnRyeS50YXJnZXQpO1xuICAgICAgICBjb25zdCBsYXN0U2l6ZSA9IGlzQ29udGFpbmVyID8gY29udGFpbmVyU2l6ZSA6IHNsaWRlU2l6ZXNbc2xpZGVJbmRleF07XG4gICAgICAgIGNvbnN0IG5ld1NpemUgPSByZWFkU2l6ZShpc0NvbnRhaW5lciA/IGNvbnRhaW5lciA6IHNsaWRlc1tzbGlkZUluZGV4XSk7XG4gICAgICAgIGNvbnN0IGRpZmZTaXplID0gbWF0aEFicyhuZXdTaXplIC0gbGFzdFNpemUpO1xuICAgICAgICBpZiAoZGlmZlNpemUgPj0gMC41KSB7XG4gICAgICAgICAgZW1ibGFBcGkucmVJbml0KCk7XG4gICAgICAgICAgZXZlbnRIYW5kbGVyLmVtaXQoJ3Jlc2l6ZScpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgaWYgKGlzQm9vbGVhbih3YXRjaFJlc2l6ZSkgfHwgd2F0Y2hSZXNpemUoZW1ibGFBcGksIGVudHJpZXMpKSB7XG4gICAgICAgIGRlZmF1bHRDYWxsYmFjayhlbnRyaWVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBvd25lcldpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgb2JzZXJ2ZU5vZGVzLmZvckVhY2gobm9kZSA9PiByZXNpemVPYnNlcnZlci5vYnNlcnZlKG5vZGUpKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGRlc3Ryb3llZCA9IHRydWU7XG4gICAgaWYgKHJlc2l6ZU9ic2VydmVyKSByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0LFxuICAgIGRlc3Ryb3lcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNjcm9sbEJvZHkobG9jYXRpb24sIG9mZnNldExvY2F0aW9uLCBwcmV2aW91c0xvY2F0aW9uLCB0YXJnZXQsIGJhc2VEdXJhdGlvbiwgYmFzZUZyaWN0aW9uKSB7XG4gIGxldCBzY3JvbGxWZWxvY2l0eSA9IDA7XG4gIGxldCBzY3JvbGxEaXJlY3Rpb24gPSAwO1xuICBsZXQgc2Nyb2xsRHVyYXRpb24gPSBiYXNlRHVyYXRpb247XG4gIGxldCBzY3JvbGxGcmljdGlvbiA9IGJhc2VGcmljdGlvbjtcbiAgbGV0IHJhd0xvY2F0aW9uID0gbG9jYXRpb24uZ2V0KCk7XG4gIGxldCByYXdMb2NhdGlvblByZXZpb3VzID0gMDtcbiAgZnVuY3Rpb24gc2VlaygpIHtcbiAgICBjb25zdCBkaXNwbGFjZW1lbnQgPSB0YXJnZXQuZ2V0KCkgLSBsb2NhdGlvbi5nZXQoKTtcbiAgICBjb25zdCBpc0luc3RhbnQgPSAhc2Nyb2xsRHVyYXRpb247XG4gICAgbGV0IHNjcm9sbERpc3RhbmNlID0gMDtcbiAgICBpZiAoaXNJbnN0YW50KSB7XG4gICAgICBzY3JvbGxWZWxvY2l0eSA9IDA7XG4gICAgICBwcmV2aW91c0xvY2F0aW9uLnNldCh0YXJnZXQpO1xuICAgICAgbG9jYXRpb24uc2V0KHRhcmdldCk7XG4gICAgICBzY3JvbGxEaXN0YW5jZSA9IGRpc3BsYWNlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldmlvdXNMb2NhdGlvbi5zZXQobG9jYXRpb24pO1xuICAgICAgc2Nyb2xsVmVsb2NpdHkgKz0gZGlzcGxhY2VtZW50IC8gc2Nyb2xsRHVyYXRpb247XG4gICAgICBzY3JvbGxWZWxvY2l0eSAqPSBzY3JvbGxGcmljdGlvbjtcbiAgICAgIHJhd0xvY2F0aW9uICs9IHNjcm9sbFZlbG9jaXR5O1xuICAgICAgbG9jYXRpb24uYWRkKHNjcm9sbFZlbG9jaXR5KTtcbiAgICAgIHNjcm9sbERpc3RhbmNlID0gcmF3TG9jYXRpb24gLSByYXdMb2NhdGlvblByZXZpb3VzO1xuICAgIH1cbiAgICBzY3JvbGxEaXJlY3Rpb24gPSBtYXRoU2lnbihzY3JvbGxEaXN0YW5jZSk7XG4gICAgcmF3TG9jYXRpb25QcmV2aW91cyA9IHJhd0xvY2F0aW9uO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGZ1bmN0aW9uIHNldHRsZWQoKSB7XG4gICAgY29uc3QgZGlmZiA9IHRhcmdldC5nZXQoKSAtIG9mZnNldExvY2F0aW9uLmdldCgpO1xuICAgIHJldHVybiBtYXRoQWJzKGRpZmYpIDwgMC4wMDE7XG4gIH1cbiAgZnVuY3Rpb24gZHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHNjcm9sbER1cmF0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIGRpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gc2Nyb2xsRGlyZWN0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIHZlbG9jaXR5KCkge1xuICAgIHJldHVybiBzY3JvbGxWZWxvY2l0eTtcbiAgfVxuICBmdW5jdGlvbiB1c2VCYXNlRHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHVzZUR1cmF0aW9uKGJhc2VEdXJhdGlvbik7XG4gIH1cbiAgZnVuY3Rpb24gdXNlQmFzZUZyaWN0aW9uKCkge1xuICAgIHJldHVybiB1c2VGcmljdGlvbihiYXNlRnJpY3Rpb24pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUR1cmF0aW9uKG4pIHtcbiAgICBzY3JvbGxEdXJhdGlvbiA9IG47XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZnVuY3Rpb24gdXNlRnJpY3Rpb24obikge1xuICAgIHNjcm9sbEZyaWN0aW9uID0gbjtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGRpcmVjdGlvbixcbiAgICBkdXJhdGlvbixcbiAgICB2ZWxvY2l0eSxcbiAgICBzZWVrLFxuICAgIHNldHRsZWQsXG4gICAgdXNlQmFzZUZyaWN0aW9uLFxuICAgIHVzZUJhc2VEdXJhdGlvbixcbiAgICB1c2VGcmljdGlvbixcbiAgICB1c2VEdXJhdGlvblxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsQm91bmRzKGxpbWl0LCBsb2NhdGlvbiwgdGFyZ2V0LCBzY3JvbGxCb2R5LCBwZXJjZW50T2ZWaWV3KSB7XG4gIGNvbnN0IHB1bGxCYWNrVGhyZXNob2xkID0gcGVyY2VudE9mVmlldy5tZWFzdXJlKDEwKTtcbiAgY29uc3QgZWRnZU9mZnNldFRvbGVyYW5jZSA9IHBlcmNlbnRPZlZpZXcubWVhc3VyZSg1MCk7XG4gIGNvbnN0IGZyaWN0aW9uTGltaXQgPSBMaW1pdCgwLjEsIDAuOTkpO1xuICBsZXQgZGlzYWJsZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gc2hvdWxkQ29uc3RyYWluKCkge1xuICAgIGlmIChkaXNhYmxlZCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghbGltaXQucmVhY2hlZEFueSh0YXJnZXQuZ2V0KCkpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFsaW1pdC5yZWFjaGVkQW55KGxvY2F0aW9uLmdldCgpKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIGNvbnN0cmFpbihwb2ludGVyRG93bikge1xuICAgIGlmICghc2hvdWxkQ29uc3RyYWluKCkpIHJldHVybjtcbiAgICBjb25zdCBlZGdlID0gbGltaXQucmVhY2hlZE1pbihsb2NhdGlvbi5nZXQoKSkgPyAnbWluJyA6ICdtYXgnO1xuICAgIGNvbnN0IGRpZmZUb0VkZ2UgPSBtYXRoQWJzKGxpbWl0W2VkZ2VdIC0gbG9jYXRpb24uZ2V0KCkpO1xuICAgIGNvbnN0IGRpZmZUb1RhcmdldCA9IHRhcmdldC5nZXQoKSAtIGxvY2F0aW9uLmdldCgpO1xuICAgIGNvbnN0IGZyaWN0aW9uID0gZnJpY3Rpb25MaW1pdC5jb25zdHJhaW4oZGlmZlRvRWRnZSAvIGVkZ2VPZmZzZXRUb2xlcmFuY2UpO1xuICAgIHRhcmdldC5zdWJ0cmFjdChkaWZmVG9UYXJnZXQgKiBmcmljdGlvbik7XG4gICAgaWYgKCFwb2ludGVyRG93biAmJiBtYXRoQWJzKGRpZmZUb1RhcmdldCkgPCBwdWxsQmFja1RocmVzaG9sZCkge1xuICAgICAgdGFyZ2V0LnNldChsaW1pdC5jb25zdHJhaW4odGFyZ2V0LmdldCgpKSk7XG4gICAgICBzY3JvbGxCb2R5LnVzZUR1cmF0aW9uKDI1KS51c2VCYXNlRnJpY3Rpb24oKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdG9nZ2xlQWN0aXZlKGFjdGl2ZSkge1xuICAgIGRpc2FibGVkID0gIWFjdGl2ZTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIHNob3VsZENvbnN0cmFpbixcbiAgICBjb25zdHJhaW4sXG4gICAgdG9nZ2xlQWN0aXZlXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxDb250YWluKHZpZXdTaXplLCBjb250ZW50U2l6ZSwgc25hcHNBbGlnbmVkLCBjb250YWluU2Nyb2xsLCBwaXhlbFRvbGVyYW5jZSkge1xuICBjb25zdCBzY3JvbGxCb3VuZHMgPSBMaW1pdCgtY29udGVudFNpemUgKyB2aWV3U2l6ZSwgMCk7XG4gIGNvbnN0IHNuYXBzQm91bmRlZCA9IG1lYXN1cmVCb3VuZGVkKCk7XG4gIGNvbnN0IHNjcm9sbENvbnRhaW5MaW1pdCA9IGZpbmRTY3JvbGxDb250YWluTGltaXQoKTtcbiAgY29uc3Qgc25hcHNDb250YWluZWQgPSBtZWFzdXJlQ29udGFpbmVkKCk7XG4gIGZ1bmN0aW9uIHVzZVBpeGVsVG9sZXJhbmNlKGJvdW5kLCBzbmFwKSB7XG4gICAgcmV0dXJuIGRlbHRhQWJzKGJvdW5kLCBzbmFwKSA8IDE7XG4gIH1cbiAgZnVuY3Rpb24gZmluZFNjcm9sbENvbnRhaW5MaW1pdCgpIHtcbiAgICBjb25zdCBzdGFydFNuYXAgPSBzbmFwc0JvdW5kZWRbMF07XG4gICAgY29uc3QgZW5kU25hcCA9IGFycmF5TGFzdChzbmFwc0JvdW5kZWQpO1xuICAgIGNvbnN0IG1pbiA9IHNuYXBzQm91bmRlZC5sYXN0SW5kZXhPZihzdGFydFNuYXApO1xuICAgIGNvbnN0IG1heCA9IHNuYXBzQm91bmRlZC5pbmRleE9mKGVuZFNuYXApICsgMTtcbiAgICByZXR1cm4gTGltaXQobWluLCBtYXgpO1xuICB9XG4gIGZ1bmN0aW9uIG1lYXN1cmVCb3VuZGVkKCkge1xuICAgIHJldHVybiBzbmFwc0FsaWduZWQubWFwKChzbmFwQWxpZ25lZCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWluLFxuICAgICAgICBtYXhcbiAgICAgIH0gPSBzY3JvbGxCb3VuZHM7XG4gICAgICBjb25zdCBzbmFwID0gc2Nyb2xsQm91bmRzLmNvbnN0cmFpbihzbmFwQWxpZ25lZCk7XG4gICAgICBjb25zdCBpc0ZpcnN0ID0gIWluZGV4O1xuICAgICAgY29uc3QgaXNMYXN0ID0gYXJyYXlJc0xhc3RJbmRleChzbmFwc0FsaWduZWQsIGluZGV4KTtcbiAgICAgIGlmIChpc0ZpcnN0KSByZXR1cm4gbWF4O1xuICAgICAgaWYgKGlzTGFzdCkgcmV0dXJuIG1pbjtcbiAgICAgIGlmICh1c2VQaXhlbFRvbGVyYW5jZShtaW4sIHNuYXApKSByZXR1cm4gbWluO1xuICAgICAgaWYgKHVzZVBpeGVsVG9sZXJhbmNlKG1heCwgc25hcCkpIHJldHVybiBtYXg7XG4gICAgICByZXR1cm4gc25hcDtcbiAgICB9KS5tYXAoc2Nyb2xsQm91bmQgPT4gcGFyc2VGbG9hdChzY3JvbGxCb3VuZC50b0ZpeGVkKDMpKSk7XG4gIH1cbiAgZnVuY3Rpb24gbWVhc3VyZUNvbnRhaW5lZCgpIHtcbiAgICBpZiAoY29udGVudFNpemUgPD0gdmlld1NpemUgKyBwaXhlbFRvbGVyYW5jZSkgcmV0dXJuIFtzY3JvbGxCb3VuZHMubWF4XTtcbiAgICBpZiAoY29udGFpblNjcm9sbCA9PT0gJ2tlZXBTbmFwcycpIHJldHVybiBzbmFwc0JvdW5kZWQ7XG4gICAgY29uc3Qge1xuICAgICAgbWluLFxuICAgICAgbWF4XG4gICAgfSA9IHNjcm9sbENvbnRhaW5MaW1pdDtcbiAgICByZXR1cm4gc25hcHNCb3VuZGVkLnNsaWNlKG1pbiwgbWF4KTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIHNuYXBzQ29udGFpbmVkLFxuICAgIHNjcm9sbENvbnRhaW5MaW1pdFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsTGltaXQoY29udGVudFNpemUsIHNjcm9sbFNuYXBzLCBsb29wKSB7XG4gIGNvbnN0IG1heCA9IHNjcm9sbFNuYXBzWzBdO1xuICBjb25zdCBtaW4gPSBsb29wID8gbWF4IC0gY29udGVudFNpemUgOiBhcnJheUxhc3Qoc2Nyb2xsU25hcHMpO1xuICBjb25zdCBsaW1pdCA9IExpbWl0KG1pbiwgbWF4KTtcbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBsaW1pdFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsTG9vcGVyKGNvbnRlbnRTaXplLCBsaW1pdCwgbG9jYXRpb24sIHZlY3RvcnMpIHtcbiAgY29uc3Qgam9pbnRTYWZldHkgPSAwLjE7XG4gIGNvbnN0IG1pbiA9IGxpbWl0Lm1pbiArIGpvaW50U2FmZXR5O1xuICBjb25zdCBtYXggPSBsaW1pdC5tYXggKyBqb2ludFNhZmV0eTtcbiAgY29uc3Qge1xuICAgIHJlYWNoZWRNaW4sXG4gICAgcmVhY2hlZE1heFxuICB9ID0gTGltaXQobWluLCBtYXgpO1xuICBmdW5jdGlvbiBzaG91bGRMb29wKGRpcmVjdGlvbikge1xuICAgIGlmIChkaXJlY3Rpb24gPT09IDEpIHJldHVybiByZWFjaGVkTWF4KGxvY2F0aW9uLmdldCgpKTtcbiAgICBpZiAoZGlyZWN0aW9uID09PSAtMSkgcmV0dXJuIHJlYWNoZWRNaW4obG9jYXRpb24uZ2V0KCkpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBsb29wKGRpcmVjdGlvbikge1xuICAgIGlmICghc2hvdWxkTG9vcChkaXJlY3Rpb24pKSByZXR1cm47XG4gICAgY29uc3QgbG9vcERpc3RhbmNlID0gY29udGVudFNpemUgKiAoZGlyZWN0aW9uICogLTEpO1xuICAgIHZlY3RvcnMuZm9yRWFjaCh2ID0+IHYuYWRkKGxvb3BEaXN0YW5jZSkpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgbG9vcFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsUHJvZ3Jlc3MobGltaXQpIHtcbiAgY29uc3Qge1xuICAgIG1heCxcbiAgICBsZW5ndGhcbiAgfSA9IGxpbWl0O1xuICBmdW5jdGlvbiBnZXQobikge1xuICAgIGNvbnN0IGN1cnJlbnRMb2NhdGlvbiA9IG4gLSBtYXg7XG4gICAgcmV0dXJuIGxlbmd0aCA/IGN1cnJlbnRMb2NhdGlvbiAvIC1sZW5ndGggOiAwO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgZ2V0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxTbmFwcyhheGlzLCBhbGlnbm1lbnQsIGNvbnRhaW5lclJlY3QsIHNsaWRlUmVjdHMsIHNsaWRlc1RvU2Nyb2xsKSB7XG4gIGNvbnN0IHtcbiAgICBzdGFydEVkZ2UsXG4gICAgZW5kRWRnZVxuICB9ID0gYXhpcztcbiAgY29uc3Qge1xuICAgIGdyb3VwU2xpZGVzXG4gIH0gPSBzbGlkZXNUb1Njcm9sbDtcbiAgY29uc3QgYWxpZ25tZW50cyA9IG1lYXN1cmVTaXplcygpLm1hcChhbGlnbm1lbnQubWVhc3VyZSk7XG4gIGNvbnN0IHNuYXBzID0gbWVhc3VyZVVuYWxpZ25lZCgpO1xuICBjb25zdCBzbmFwc0FsaWduZWQgPSBtZWFzdXJlQWxpZ25lZCgpO1xuICBmdW5jdGlvbiBtZWFzdXJlU2l6ZXMoKSB7XG4gICAgcmV0dXJuIGdyb3VwU2xpZGVzKHNsaWRlUmVjdHMpLm1hcChyZWN0cyA9PiBhcnJheUxhc3QocmVjdHMpW2VuZEVkZ2VdIC0gcmVjdHNbMF1bc3RhcnRFZGdlXSkubWFwKG1hdGhBYnMpO1xuICB9XG4gIGZ1bmN0aW9uIG1lYXN1cmVVbmFsaWduZWQoKSB7XG4gICAgcmV0dXJuIHNsaWRlUmVjdHMubWFwKHJlY3QgPT4gY29udGFpbmVyUmVjdFtzdGFydEVkZ2VdIC0gcmVjdFtzdGFydEVkZ2VdKS5tYXAoc25hcCA9PiAtbWF0aEFicyhzbmFwKSk7XG4gIH1cbiAgZnVuY3Rpb24gbWVhc3VyZUFsaWduZWQoKSB7XG4gICAgcmV0dXJuIGdyb3VwU2xpZGVzKHNuYXBzKS5tYXAoZyA9PiBnWzBdKS5tYXAoKHNuYXAsIGluZGV4KSA9PiBzbmFwICsgYWxpZ25tZW50c1tpbmRleF0pO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgc25hcHMsXG4gICAgc25hcHNBbGlnbmVkXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTbGlkZVJlZ2lzdHJ5KGNvbnRhaW5TbmFwcywgY29udGFpblNjcm9sbCwgc2Nyb2xsU25hcHMsIHNjcm9sbENvbnRhaW5MaW1pdCwgc2xpZGVzVG9TY3JvbGwsIHNsaWRlSW5kZXhlcykge1xuICBjb25zdCB7XG4gICAgZ3JvdXBTbGlkZXNcbiAgfSA9IHNsaWRlc1RvU2Nyb2xsO1xuICBjb25zdCB7XG4gICAgbWluLFxuICAgIG1heFxuICB9ID0gc2Nyb2xsQ29udGFpbkxpbWl0O1xuICBjb25zdCBzbGlkZVJlZ2lzdHJ5ID0gY3JlYXRlU2xpZGVSZWdpc3RyeSgpO1xuICBmdW5jdGlvbiBjcmVhdGVTbGlkZVJlZ2lzdHJ5KCkge1xuICAgIGNvbnN0IGdyb3VwZWRTbGlkZUluZGV4ZXMgPSBncm91cFNsaWRlcyhzbGlkZUluZGV4ZXMpO1xuICAgIGNvbnN0IGRvTm90Q29udGFpbiA9ICFjb250YWluU25hcHMgfHwgY29udGFpblNjcm9sbCA9PT0gJ2tlZXBTbmFwcyc7XG4gICAgaWYgKHNjcm9sbFNuYXBzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIFtzbGlkZUluZGV4ZXNdO1xuICAgIGlmIChkb05vdENvbnRhaW4pIHJldHVybiBncm91cGVkU2xpZGVJbmRleGVzO1xuICAgIHJldHVybiBncm91cGVkU2xpZGVJbmRleGVzLnNsaWNlKG1pbiwgbWF4KS5tYXAoKGdyb3VwLCBpbmRleCwgZ3JvdXBzKSA9PiB7XG4gICAgICBjb25zdCBpc0ZpcnN0ID0gIWluZGV4O1xuICAgICAgY29uc3QgaXNMYXN0ID0gYXJyYXlJc0xhc3RJbmRleChncm91cHMsIGluZGV4KTtcbiAgICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gYXJyYXlMYXN0KGdyb3Vwc1swXSkgKyAxO1xuICAgICAgICByZXR1cm4gYXJyYXlGcm9tTnVtYmVyKHJhbmdlKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xhc3QpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBhcnJheUxhc3RJbmRleChzbGlkZUluZGV4ZXMpIC0gYXJyYXlMYXN0KGdyb3VwcylbMF0gKyAxO1xuICAgICAgICByZXR1cm4gYXJyYXlGcm9tTnVtYmVyKHJhbmdlLCBhcnJheUxhc3QoZ3JvdXBzKVswXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBzbGlkZVJlZ2lzdHJ5XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxUYXJnZXQobG9vcCwgc2Nyb2xsU25hcHMsIGNvbnRlbnRTaXplLCBsaW1pdCwgdGFyZ2V0VmVjdG9yKSB7XG4gIGNvbnN0IHtcbiAgICByZWFjaGVkQW55LFxuICAgIHJlbW92ZU9mZnNldCxcbiAgICBjb25zdHJhaW5cbiAgfSA9IGxpbWl0O1xuICBmdW5jdGlvbiBtaW5EaXN0YW5jZShkaXN0YW5jZXMpIHtcbiAgICByZXR1cm4gZGlzdGFuY2VzLmNvbmNhdCgpLnNvcnQoKGEsIGIpID0+IG1hdGhBYnMoYSkgLSBtYXRoQWJzKGIpKVswXTtcbiAgfVxuICBmdW5jdGlvbiBmaW5kVGFyZ2V0U25hcCh0YXJnZXQpIHtcbiAgICBjb25zdCBkaXN0YW5jZSA9IGxvb3AgPyByZW1vdmVPZmZzZXQodGFyZ2V0KSA6IGNvbnN0cmFpbih0YXJnZXQpO1xuICAgIGNvbnN0IGFzY0RpZmZzVG9TbmFwcyA9IHNjcm9sbFNuYXBzLm1hcCgoc25hcCwgaW5kZXgpID0+ICh7XG4gICAgICBkaWZmOiBzaG9ydGN1dChzbmFwIC0gZGlzdGFuY2UsIDApLFxuICAgICAgaW5kZXhcbiAgICB9KSkuc29ydCgoZDEsIGQyKSA9PiBtYXRoQWJzKGQxLmRpZmYpIC0gbWF0aEFicyhkMi5kaWZmKSk7XG4gICAgY29uc3Qge1xuICAgICAgaW5kZXhcbiAgICB9ID0gYXNjRGlmZnNUb1NuYXBzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICBpbmRleCxcbiAgICAgIGRpc3RhbmNlXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBzaG9ydGN1dCh0YXJnZXQsIGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHRhcmdldHMgPSBbdGFyZ2V0LCB0YXJnZXQgKyBjb250ZW50U2l6ZSwgdGFyZ2V0IC0gY29udGVudFNpemVdO1xuICAgIGlmICghbG9vcCkgcmV0dXJuIHRhcmdldDtcbiAgICBpZiAoIWRpcmVjdGlvbikgcmV0dXJuIG1pbkRpc3RhbmNlKHRhcmdldHMpO1xuICAgIGNvbnN0IG1hdGNoaW5nVGFyZ2V0cyA9IHRhcmdldHMuZmlsdGVyKHQgPT4gbWF0aFNpZ24odCkgPT09IGRpcmVjdGlvbik7XG4gICAgaWYgKG1hdGNoaW5nVGFyZ2V0cy5sZW5ndGgpIHJldHVybiBtaW5EaXN0YW5jZShtYXRjaGluZ1RhcmdldHMpO1xuICAgIHJldHVybiBhcnJheUxhc3QodGFyZ2V0cykgLSBjb250ZW50U2l6ZTtcbiAgfVxuICBmdW5jdGlvbiBieUluZGV4KGluZGV4LCBkaXJlY3Rpb24pIHtcbiAgICBjb25zdCBkaWZmVG9TbmFwID0gc2Nyb2xsU25hcHNbaW5kZXhdIC0gdGFyZ2V0VmVjdG9yLmdldCgpO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gc2hvcnRjdXQoZGlmZlRvU25hcCwgZGlyZWN0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5kZXgsXG4gICAgICBkaXN0YW5jZVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gYnlEaXN0YW5jZShkaXN0YW5jZSwgc25hcCkge1xuICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldFZlY3Rvci5nZXQoKSArIGRpc3RhbmNlO1xuICAgIGNvbnN0IHtcbiAgICAgIGluZGV4LFxuICAgICAgZGlzdGFuY2U6IHRhcmdldFNuYXBEaXN0YW5jZVxuICAgIH0gPSBmaW5kVGFyZ2V0U25hcCh0YXJnZXQpO1xuICAgIGNvbnN0IHJlYWNoZWRCb3VuZCA9ICFsb29wICYmIHJlYWNoZWRBbnkodGFyZ2V0KTtcbiAgICBpZiAoIXNuYXAgfHwgcmVhY2hlZEJvdW5kKSByZXR1cm4ge1xuICAgICAgaW5kZXgsXG4gICAgICBkaXN0YW5jZVxuICAgIH07XG4gICAgY29uc3QgZGlmZlRvU25hcCA9IHNjcm9sbFNuYXBzW2luZGV4XSAtIHRhcmdldFNuYXBEaXN0YW5jZTtcbiAgICBjb25zdCBzbmFwRGlzdGFuY2UgPSBkaXN0YW5jZSArIHNob3J0Y3V0KGRpZmZUb1NuYXAsIDApO1xuICAgIHJldHVybiB7XG4gICAgICBpbmRleCxcbiAgICAgIGRpc3RhbmNlOiBzbmFwRGlzdGFuY2VcbiAgICB9O1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgYnlEaXN0YW5jZSxcbiAgICBieUluZGV4LFxuICAgIHNob3J0Y3V0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxUbyhhbmltYXRpb24sIGluZGV4Q3VycmVudCwgaW5kZXhQcmV2aW91cywgc2Nyb2xsQm9keSwgc2Nyb2xsVGFyZ2V0LCB0YXJnZXRWZWN0b3IsIGV2ZW50SGFuZGxlcikge1xuICBmdW5jdGlvbiBzY3JvbGxUbyh0YXJnZXQpIHtcbiAgICBjb25zdCBkaXN0YW5jZURpZmYgPSB0YXJnZXQuZGlzdGFuY2U7XG4gICAgY29uc3QgaW5kZXhEaWZmID0gdGFyZ2V0LmluZGV4ICE9PSBpbmRleEN1cnJlbnQuZ2V0KCk7XG4gICAgdGFyZ2V0VmVjdG9yLmFkZChkaXN0YW5jZURpZmYpO1xuICAgIGlmIChkaXN0YW5jZURpZmYpIHtcbiAgICAgIGlmIChzY3JvbGxCb2R5LmR1cmF0aW9uKCkpIHtcbiAgICAgICAgYW5pbWF0aW9uLnN0YXJ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmltYXRpb24udXBkYXRlKCk7XG4gICAgICAgIGFuaW1hdGlvbi5yZW5kZXIoMSk7XG4gICAgICAgIGFuaW1hdGlvbi51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluZGV4RGlmZikge1xuICAgICAgaW5kZXhQcmV2aW91cy5zZXQoaW5kZXhDdXJyZW50LmdldCgpKTtcbiAgICAgIGluZGV4Q3VycmVudC5zZXQodGFyZ2V0LmluZGV4KTtcbiAgICAgIGV2ZW50SGFuZGxlci5lbWl0KCdzZWxlY3QnKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZGlzdGFuY2Uobiwgc25hcCkge1xuICAgIGNvbnN0IHRhcmdldCA9IHNjcm9sbFRhcmdldC5ieURpc3RhbmNlKG4sIHNuYXApO1xuICAgIHNjcm9sbFRvKHRhcmdldCk7XG4gIH1cbiAgZnVuY3Rpb24gaW5kZXgobiwgZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgdGFyZ2V0SW5kZXggPSBpbmRleEN1cnJlbnQuY2xvbmUoKS5zZXQobik7XG4gICAgY29uc3QgdGFyZ2V0ID0gc2Nyb2xsVGFyZ2V0LmJ5SW5kZXgodGFyZ2V0SW5kZXguZ2V0KCksIGRpcmVjdGlvbik7XG4gICAgc2Nyb2xsVG8odGFyZ2V0KTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGRpc3RhbmNlLFxuICAgIGluZGV4XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTbGlkZUZvY3VzKHJvb3QsIHNsaWRlcywgc2xpZGVSZWdpc3RyeSwgc2Nyb2xsVG8sIHNjcm9sbEJvZHksIGV2ZW50U3RvcmUsIGV2ZW50SGFuZGxlciwgd2F0Y2hGb2N1cykge1xuICBjb25zdCBmb2N1c0xpc3RlbmVyT3B0aW9ucyA9IHtcbiAgICBwYXNzaXZlOiB0cnVlLFxuICAgIGNhcHR1cmU6IHRydWVcbiAgfTtcbiAgbGV0IGxhc3RUYWJQcmVzc1RpbWUgPSAwO1xuICBmdW5jdGlvbiBpbml0KGVtYmxhQXBpKSB7XG4gICAgaWYgKCF3YXRjaEZvY3VzKSByZXR1cm47XG4gICAgZnVuY3Rpb24gZGVmYXVsdENhbGxiYWNrKGluZGV4KSB7XG4gICAgICBjb25zdCBub3dUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICBjb25zdCBkaWZmVGltZSA9IG5vd1RpbWUgLSBsYXN0VGFiUHJlc3NUaW1lO1xuICAgICAgaWYgKGRpZmZUaW1lID4gMTApIHJldHVybjtcbiAgICAgIGV2ZW50SGFuZGxlci5lbWl0KCdzbGlkZUZvY3VzU3RhcnQnKTtcbiAgICAgIHJvb3Quc2Nyb2xsTGVmdCA9IDA7XG4gICAgICBjb25zdCBncm91cCA9IHNsaWRlUmVnaXN0cnkuZmluZEluZGV4KGdyb3VwID0+IGdyb3VwLmluY2x1ZGVzKGluZGV4KSk7XG4gICAgICBpZiAoIWlzTnVtYmVyKGdyb3VwKSkgcmV0dXJuO1xuICAgICAgc2Nyb2xsQm9keS51c2VEdXJhdGlvbigwKTtcbiAgICAgIHNjcm9sbFRvLmluZGV4KGdyb3VwLCAwKTtcbiAgICAgIGV2ZW50SGFuZGxlci5lbWl0KCdzbGlkZUZvY3VzJyk7XG4gICAgfVxuICAgIGV2ZW50U3RvcmUuYWRkKGRvY3VtZW50LCAna2V5ZG93bicsIHJlZ2lzdGVyVGFiUHJlc3MsIGZhbHNlKTtcbiAgICBzbGlkZXMuZm9yRWFjaCgoc2xpZGUsIHNsaWRlSW5kZXgpID0+IHtcbiAgICAgIGV2ZW50U3RvcmUuYWRkKHNsaWRlLCAnZm9jdXMnLCBldnQgPT4ge1xuICAgICAgICBpZiAoaXNCb29sZWFuKHdhdGNoRm9jdXMpIHx8IHdhdGNoRm9jdXMoZW1ibGFBcGksIGV2dCkpIHtcbiAgICAgICAgICBkZWZhdWx0Q2FsbGJhY2soc2xpZGVJbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGZvY3VzTGlzdGVuZXJPcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiByZWdpc3RlclRhYlByZXNzKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmNvZGUgPT09ICdUYWInKSBsYXN0VGFiUHJlc3NUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBWZWN0b3IxRChpbml0aWFsVmFsdWUpIHtcbiAgbGV0IHZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHNldChuKSB7XG4gICAgdmFsdWUgPSBub3JtYWxpemVJbnB1dChuKTtcbiAgfVxuICBmdW5jdGlvbiBhZGQobikge1xuICAgIHZhbHVlICs9IG5vcm1hbGl6ZUlucHV0KG4pO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnRyYWN0KG4pIHtcbiAgICB2YWx1ZSAtPSBub3JtYWxpemVJbnB1dChuKTtcbiAgfVxuICBmdW5jdGlvbiBub3JtYWxpemVJbnB1dChuKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKG4pID8gbiA6IG4uZ2V0KCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBnZXQsXG4gICAgc2V0LFxuICAgIGFkZCxcbiAgICBzdWJ0cmFjdFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gVHJhbnNsYXRlKGF4aXMsIGNvbnRhaW5lcikge1xuICBjb25zdCB0cmFuc2xhdGUgPSBheGlzLnNjcm9sbCA9PT0gJ3gnID8geCA6IHk7XG4gIGNvbnN0IGNvbnRhaW5lclN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xuICBsZXQgcHJldmlvdXNUYXJnZXQgPSBudWxsO1xuICBsZXQgZGlzYWJsZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24geChuKSB7XG4gICAgcmV0dXJuIGB0cmFuc2xhdGUzZCgke259cHgsMHB4LDBweClgO1xuICB9XG4gIGZ1bmN0aW9uIHkobikge1xuICAgIHJldHVybiBgdHJhbnNsYXRlM2QoMHB4LCR7bn1weCwwcHgpYDtcbiAgfVxuICBmdW5jdGlvbiB0byh0YXJnZXQpIHtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcbiAgICBjb25zdCBuZXdUYXJnZXQgPSByb3VuZFRvVHdvRGVjaW1hbHMoYXhpcy5kaXJlY3Rpb24odGFyZ2V0KSk7XG4gICAgaWYgKG5ld1RhcmdldCA9PT0gcHJldmlvdXNUYXJnZXQpIHJldHVybjtcbiAgICBjb250YWluZXJTdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2xhdGUobmV3VGFyZ2V0KTtcbiAgICBwcmV2aW91c1RhcmdldCA9IG5ld1RhcmdldDtcbiAgfVxuICBmdW5jdGlvbiB0b2dnbGVBY3RpdmUoYWN0aXZlKSB7XG4gICAgZGlzYWJsZWQgPSAhYWN0aXZlO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGlmIChkaXNhYmxlZCkgcmV0dXJuO1xuICAgIGNvbnRhaW5lclN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuICAgIGlmICghY29udGFpbmVyLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSkgY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGNsZWFyLFxuICAgIHRvLFxuICAgIHRvZ2dsZUFjdGl2ZVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2xpZGVMb29wZXIoYXhpcywgdmlld1NpemUsIGNvbnRlbnRTaXplLCBzbGlkZVNpemVzLCBzbGlkZVNpemVzV2l0aEdhcHMsIHNuYXBzLCBzY3JvbGxTbmFwcywgbG9jYXRpb24sIHNsaWRlcykge1xuICBjb25zdCByb3VuZGluZ1NhZmV0eSA9IDAuNTtcbiAgY29uc3QgYXNjSXRlbXMgPSBhcnJheUtleXMoc2xpZGVTaXplc1dpdGhHYXBzKTtcbiAgY29uc3QgZGVzY0l0ZW1zID0gYXJyYXlLZXlzKHNsaWRlU2l6ZXNXaXRoR2FwcykucmV2ZXJzZSgpO1xuICBjb25zdCBsb29wUG9pbnRzID0gc3RhcnRQb2ludHMoKS5jb25jYXQoZW5kUG9pbnRzKCkpO1xuICBmdW5jdGlvbiByZW1vdmVTbGlkZVNpemVzKGluZGV4ZXMsIGZyb20pIHtcbiAgICByZXR1cm4gaW5kZXhlcy5yZWR1Y2UoKGEsIGkpID0+IHtcbiAgICAgIHJldHVybiBhIC0gc2xpZGVTaXplc1dpdGhHYXBzW2ldO1xuICAgIH0sIGZyb20pO1xuICB9XG4gIGZ1bmN0aW9uIHNsaWRlc0luR2FwKGluZGV4ZXMsIGdhcCkge1xuICAgIHJldHVybiBpbmRleGVzLnJlZHVjZSgoYSwgaSkgPT4ge1xuICAgICAgY29uc3QgcmVtYWluaW5nR2FwID0gcmVtb3ZlU2xpZGVTaXplcyhhLCBnYXApO1xuICAgICAgcmV0dXJuIHJlbWFpbmluZ0dhcCA+IDAgPyBhLmNvbmNhdChbaV0pIDogYTtcbiAgICB9LCBbXSk7XG4gIH1cbiAgZnVuY3Rpb24gZmluZFNsaWRlQm91bmRzKG9mZnNldCkge1xuICAgIHJldHVybiBzbmFwcy5tYXAoKHNuYXAsIGluZGV4KSA9PiAoe1xuICAgICAgc3RhcnQ6IHNuYXAgLSBzbGlkZVNpemVzW2luZGV4XSArIHJvdW5kaW5nU2FmZXR5ICsgb2Zmc2V0LFxuICAgICAgZW5kOiBzbmFwICsgdmlld1NpemUgLSByb3VuZGluZ1NhZmV0eSArIG9mZnNldFxuICAgIH0pKTtcbiAgfVxuICBmdW5jdGlvbiBmaW5kTG9vcFBvaW50cyhpbmRleGVzLCBvZmZzZXQsIGlzRW5kRWRnZSkge1xuICAgIGNvbnN0IHNsaWRlQm91bmRzID0gZmluZFNsaWRlQm91bmRzKG9mZnNldCk7XG4gICAgcmV0dXJuIGluZGV4ZXMubWFwKGluZGV4ID0+IHtcbiAgICAgIGNvbnN0IGluaXRpYWwgPSBpc0VuZEVkZ2UgPyAwIDogLWNvbnRlbnRTaXplO1xuICAgICAgY29uc3QgYWx0ZXJlZCA9IGlzRW5kRWRnZSA/IGNvbnRlbnRTaXplIDogMDtcbiAgICAgIGNvbnN0IGJvdW5kRWRnZSA9IGlzRW5kRWRnZSA/ICdlbmQnIDogJ3N0YXJ0JztcbiAgICAgIGNvbnN0IGxvb3BQb2ludCA9IHNsaWRlQm91bmRzW2luZGV4XVtib3VuZEVkZ2VdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGxvb3BQb2ludCxcbiAgICAgICAgc2xpZGVMb2NhdGlvbjogVmVjdG9yMUQoLTEpLFxuICAgICAgICB0cmFuc2xhdGU6IFRyYW5zbGF0ZShheGlzLCBzbGlkZXNbaW5kZXhdKSxcbiAgICAgICAgdGFyZ2V0OiAoKSA9PiBsb2NhdGlvbi5nZXQoKSA+IGxvb3BQb2ludCA/IGluaXRpYWwgOiBhbHRlcmVkXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0UG9pbnRzKCkge1xuICAgIGNvbnN0IGdhcCA9IHNjcm9sbFNuYXBzWzBdO1xuICAgIGNvbnN0IGluZGV4ZXMgPSBzbGlkZXNJbkdhcChkZXNjSXRlbXMsIGdhcCk7XG4gICAgcmV0dXJuIGZpbmRMb29wUG9pbnRzKGluZGV4ZXMsIGNvbnRlbnRTaXplLCBmYWxzZSk7XG4gIH1cbiAgZnVuY3Rpb24gZW5kUG9pbnRzKCkge1xuICAgIGNvbnN0IGdhcCA9IHZpZXdTaXplIC0gc2Nyb2xsU25hcHNbMF0gLSAxO1xuICAgIGNvbnN0IGluZGV4ZXMgPSBzbGlkZXNJbkdhcChhc2NJdGVtcywgZ2FwKTtcbiAgICByZXR1cm4gZmluZExvb3BQb2ludHMoaW5kZXhlcywgLWNvbnRlbnRTaXplLCB0cnVlKTtcbiAgfVxuICBmdW5jdGlvbiBjYW5Mb29wKCkge1xuICAgIHJldHVybiBsb29wUG9pbnRzLmV2ZXJ5KCh7XG4gICAgICBpbmRleFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IG90aGVySW5kZXhlcyA9IGFzY0l0ZW1zLmZpbHRlcihpID0+IGkgIT09IGluZGV4KTtcbiAgICAgIHJldHVybiByZW1vdmVTbGlkZVNpemVzKG90aGVySW5kZXhlcywgdmlld1NpemUpIDw9IDAuMTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBsb29wKCkge1xuICAgIGxvb3BQb2ludHMuZm9yRWFjaChsb29wUG9pbnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0YXJnZXQsXG4gICAgICAgIHRyYW5zbGF0ZSxcbiAgICAgICAgc2xpZGVMb2NhdGlvblxuICAgICAgfSA9IGxvb3BQb2ludDtcbiAgICAgIGNvbnN0IHNoaWZ0TG9jYXRpb24gPSB0YXJnZXQoKTtcbiAgICAgIGlmIChzaGlmdExvY2F0aW9uID09PSBzbGlkZUxvY2F0aW9uLmdldCgpKSByZXR1cm47XG4gICAgICB0cmFuc2xhdGUudG8oc2hpZnRMb2NhdGlvbik7XG4gICAgICBzbGlkZUxvY2F0aW9uLnNldChzaGlmdExvY2F0aW9uKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBsb29wUG9pbnRzLmZvckVhY2gobG9vcFBvaW50ID0+IGxvb3BQb2ludC50cmFuc2xhdGUuY2xlYXIoKSk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBjYW5Mb29wLFxuICAgIGNsZWFyLFxuICAgIGxvb3AsXG4gICAgbG9vcFBvaW50c1xuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2xpZGVzSGFuZGxlcihjb250YWluZXIsIGV2ZW50SGFuZGxlciwgd2F0Y2hTbGlkZXMpIHtcbiAgbGV0IG11dGF0aW9uT2JzZXJ2ZXI7XG4gIGxldCBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gaW5pdChlbWJsYUFwaSkge1xuICAgIGlmICghd2F0Y2hTbGlkZXMpIHJldHVybjtcbiAgICBmdW5jdGlvbiBkZWZhdWx0Q2FsbGJhY2sobXV0YXRpb25zKSB7XG4gICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xuICAgICAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgICBlbWJsYUFwaS5yZUluaXQoKTtcbiAgICAgICAgICBldmVudEhhbmRsZXIuZW1pdCgnc2xpZGVzQ2hhbmdlZCcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgaWYgKGlzQm9vbGVhbih3YXRjaFNsaWRlcykgfHwgd2F0Y2hTbGlkZXMoZW1ibGFBcGksIG11dGF0aW9ucykpIHtcbiAgICAgICAgZGVmYXVsdENhbGxiYWNrKG11dGF0aW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKGNvbnRhaW5lciwge1xuICAgICAgY2hpbGRMaXN0OiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpZiAobXV0YXRpb25PYnNlcnZlcikgbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGluaXQsXG4gICAgZGVzdHJveVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2xpZGVzSW5WaWV3KGNvbnRhaW5lciwgc2xpZGVzLCBldmVudEhhbmRsZXIsIHRocmVzaG9sZCkge1xuICBjb25zdCBpbnRlcnNlY3Rpb25FbnRyeU1hcCA9IHt9O1xuICBsZXQgaW5WaWV3Q2FjaGUgPSBudWxsO1xuICBsZXQgbm90SW5WaWV3Q2FjaGUgPSBudWxsO1xuICBsZXQgaW50ZXJzZWN0aW9uT2JzZXJ2ZXI7XG4gIGxldCBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBpbnRlcnNlY3Rpb25PYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgIGlmIChkZXN0cm95ZWQpIHJldHVybjtcbiAgICAgIGVudHJpZXMuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gc2xpZGVzLmluZGV4T2YoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgaW50ZXJzZWN0aW9uRW50cnlNYXBbaW5kZXhdID0gZW50cnk7XG4gICAgICB9KTtcbiAgICAgIGluVmlld0NhY2hlID0gbnVsbDtcbiAgICAgIG5vdEluVmlld0NhY2hlID0gbnVsbDtcbiAgICAgIGV2ZW50SGFuZGxlci5lbWl0KCdzbGlkZXNJblZpZXcnKTtcbiAgICB9LCB7XG4gICAgICByb290OiBjb250YWluZXIucGFyZW50RWxlbWVudCxcbiAgICAgIHRocmVzaG9sZFxuICAgIH0pO1xuICAgIHNsaWRlcy5mb3JFYWNoKHNsaWRlID0+IGludGVyc2VjdGlvbk9ic2VydmVyLm9ic2VydmUoc2xpZGUpKTtcbiAgfVxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGlmIChpbnRlcnNlY3Rpb25PYnNlcnZlcikgaW50ZXJzZWN0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIGRlc3Ryb3llZCA9IHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlSW5WaWV3TGlzdChpblZpZXcpIHtcbiAgICByZXR1cm4gb2JqZWN0S2V5cyhpbnRlcnNlY3Rpb25FbnRyeU1hcCkucmVkdWNlKChsaXN0LCBzbGlkZUluZGV4KSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHBhcnNlSW50KHNsaWRlSW5kZXgpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBpc0ludGVyc2VjdGluZ1xuICAgICAgfSA9IGludGVyc2VjdGlvbkVudHJ5TWFwW2luZGV4XTtcbiAgICAgIGNvbnN0IGluVmlld01hdGNoID0gaW5WaWV3ICYmIGlzSW50ZXJzZWN0aW5nO1xuICAgICAgY29uc3Qgbm90SW5WaWV3TWF0Y2ggPSAhaW5WaWV3ICYmICFpc0ludGVyc2VjdGluZztcbiAgICAgIGlmIChpblZpZXdNYXRjaCB8fCBub3RJblZpZXdNYXRjaCkgbGlzdC5wdXNoKGluZGV4KTtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH0sIFtdKTtcbiAgfVxuICBmdW5jdGlvbiBnZXQoaW5WaWV3ID0gdHJ1ZSkge1xuICAgIGlmIChpblZpZXcgJiYgaW5WaWV3Q2FjaGUpIHJldHVybiBpblZpZXdDYWNoZTtcbiAgICBpZiAoIWluVmlldyAmJiBub3RJblZpZXdDYWNoZSkgcmV0dXJuIG5vdEluVmlld0NhY2hlO1xuICAgIGNvbnN0IHNsaWRlSW5kZXhlcyA9IGNyZWF0ZUluVmlld0xpc3QoaW5WaWV3KTtcbiAgICBpZiAoaW5WaWV3KSBpblZpZXdDYWNoZSA9IHNsaWRlSW5kZXhlcztcbiAgICBpZiAoIWluVmlldykgbm90SW5WaWV3Q2FjaGUgPSBzbGlkZUluZGV4ZXM7XG4gICAgcmV0dXJuIHNsaWRlSW5kZXhlcztcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGluaXQsXG4gICAgZGVzdHJveSxcbiAgICBnZXRcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNsaWRlU2l6ZXMoYXhpcywgY29udGFpbmVyUmVjdCwgc2xpZGVSZWN0cywgc2xpZGVzLCByZWFkRWRnZUdhcCwgb3duZXJXaW5kb3cpIHtcbiAgY29uc3Qge1xuICAgIG1lYXN1cmVTaXplLFxuICAgIHN0YXJ0RWRnZSxcbiAgICBlbmRFZGdlXG4gIH0gPSBheGlzO1xuICBjb25zdCB3aXRoRWRnZUdhcCA9IHNsaWRlUmVjdHNbMF0gJiYgcmVhZEVkZ2VHYXA7XG4gIGNvbnN0IHN0YXJ0R2FwID0gbWVhc3VyZVN0YXJ0R2FwKCk7XG4gIGNvbnN0IGVuZEdhcCA9IG1lYXN1cmVFbmRHYXAoKTtcbiAgY29uc3Qgc2xpZGVTaXplcyA9IHNsaWRlUmVjdHMubWFwKG1lYXN1cmVTaXplKTtcbiAgY29uc3Qgc2xpZGVTaXplc1dpdGhHYXBzID0gbWVhc3VyZVdpdGhHYXBzKCk7XG4gIGZ1bmN0aW9uIG1lYXN1cmVTdGFydEdhcCgpIHtcbiAgICBpZiAoIXdpdGhFZGdlR2FwKSByZXR1cm4gMDtcbiAgICBjb25zdCBzbGlkZVJlY3QgPSBzbGlkZVJlY3RzWzBdO1xuICAgIHJldHVybiBtYXRoQWJzKGNvbnRhaW5lclJlY3Rbc3RhcnRFZGdlXSAtIHNsaWRlUmVjdFtzdGFydEVkZ2VdKTtcbiAgfVxuICBmdW5jdGlvbiBtZWFzdXJlRW5kR2FwKCkge1xuICAgIGlmICghd2l0aEVkZ2VHYXApIHJldHVybiAwO1xuICAgIGNvbnN0IHN0eWxlID0gb3duZXJXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShhcnJheUxhc3Qoc2xpZGVzKSk7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShgbWFyZ2luLSR7ZW5kRWRnZX1gKSk7XG4gIH1cbiAgZnVuY3Rpb24gbWVhc3VyZVdpdGhHYXBzKCkge1xuICAgIHJldHVybiBzbGlkZVJlY3RzLm1hcCgocmVjdCwgaW5kZXgsIHJlY3RzKSA9PiB7XG4gICAgICBjb25zdCBpc0ZpcnN0ID0gIWluZGV4O1xuICAgICAgY29uc3QgaXNMYXN0ID0gYXJyYXlJc0xhc3RJbmRleChyZWN0cywgaW5kZXgpO1xuICAgICAgaWYgKGlzRmlyc3QpIHJldHVybiBzbGlkZVNpemVzW2luZGV4XSArIHN0YXJ0R2FwO1xuICAgICAgaWYgKGlzTGFzdCkgcmV0dXJuIHNsaWRlU2l6ZXNbaW5kZXhdICsgZW5kR2FwO1xuICAgICAgcmV0dXJuIHJlY3RzW2luZGV4ICsgMV1bc3RhcnRFZGdlXSAtIHJlY3Rbc3RhcnRFZGdlXTtcbiAgICB9KS5tYXAobWF0aEFicyk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBzbGlkZVNpemVzLFxuICAgIHNsaWRlU2l6ZXNXaXRoR2FwcyxcbiAgICBzdGFydEdhcCxcbiAgICBlbmRHYXBcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNsaWRlc1RvU2Nyb2xsKGF4aXMsIHZpZXdTaXplLCBzbGlkZXNUb1Njcm9sbCwgbG9vcCwgY29udGFpbmVyUmVjdCwgc2xpZGVSZWN0cywgc3RhcnRHYXAsIGVuZEdhcCwgcGl4ZWxUb2xlcmFuY2UpIHtcbiAgY29uc3Qge1xuICAgIHN0YXJ0RWRnZSxcbiAgICBlbmRFZGdlLFxuICAgIGRpcmVjdGlvblxuICB9ID0gYXhpcztcbiAgY29uc3QgZ3JvdXBCeU51bWJlciA9IGlzTnVtYmVyKHNsaWRlc1RvU2Nyb2xsKTtcbiAgZnVuY3Rpb24gYnlOdW1iZXIoYXJyYXksIGdyb3VwU2l6ZSkge1xuICAgIHJldHVybiBhcnJheUtleXMoYXJyYXkpLmZpbHRlcihpID0+IGkgJSBncm91cFNpemUgPT09IDApLm1hcChpID0+IGFycmF5LnNsaWNlKGksIGkgKyBncm91cFNpemUpKTtcbiAgfVxuICBmdW5jdGlvbiBieVNpemUoYXJyYXkpIHtcbiAgICBpZiAoIWFycmF5Lmxlbmd0aCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnJheUtleXMoYXJyYXkpLnJlZHVjZSgoZ3JvdXBzLCByZWN0QiwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHJlY3RBID0gYXJyYXlMYXN0KGdyb3VwcykgfHwgMDtcbiAgICAgIGNvbnN0IGlzRmlyc3QgPSByZWN0QSA9PT0gMDtcbiAgICAgIGNvbnN0IGlzTGFzdCA9IHJlY3RCID09PSBhcnJheUxhc3RJbmRleChhcnJheSk7XG4gICAgICBjb25zdCBlZGdlQSA9IGNvbnRhaW5lclJlY3Rbc3RhcnRFZGdlXSAtIHNsaWRlUmVjdHNbcmVjdEFdW3N0YXJ0RWRnZV07XG4gICAgICBjb25zdCBlZGdlQiA9IGNvbnRhaW5lclJlY3Rbc3RhcnRFZGdlXSAtIHNsaWRlUmVjdHNbcmVjdEJdW2VuZEVkZ2VdO1xuICAgICAgY29uc3QgZ2FwQSA9ICFsb29wICYmIGlzRmlyc3QgPyBkaXJlY3Rpb24oc3RhcnRHYXApIDogMDtcbiAgICAgIGNvbnN0IGdhcEIgPSAhbG9vcCAmJiBpc0xhc3QgPyBkaXJlY3Rpb24oZW5kR2FwKSA6IDA7XG4gICAgICBjb25zdCBjaHVua1NpemUgPSBtYXRoQWJzKGVkZ2VCIC0gZ2FwQiAtIChlZGdlQSArIGdhcEEpKTtcbiAgICAgIGlmIChpbmRleCAmJiBjaHVua1NpemUgPiB2aWV3U2l6ZSArIHBpeGVsVG9sZXJhbmNlKSBncm91cHMucHVzaChyZWN0Qik7XG4gICAgICBpZiAoaXNMYXN0KSBncm91cHMucHVzaChhcnJheS5sZW5ndGgpO1xuICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICB9LCBbXSkubWFwKChjdXJyZW50U2l6ZSwgaW5kZXgsIGdyb3VwcykgPT4ge1xuICAgICAgY29uc3QgcHJldmlvdXNTaXplID0gTWF0aC5tYXgoZ3JvdXBzW2luZGV4IC0gMV0gfHwgMCk7XG4gICAgICByZXR1cm4gYXJyYXkuc2xpY2UocHJldmlvdXNTaXplLCBjdXJyZW50U2l6ZSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ3JvdXBTbGlkZXMoYXJyYXkpIHtcbiAgICByZXR1cm4gZ3JvdXBCeU51bWJlciA/IGJ5TnVtYmVyKGFycmF5LCBzbGlkZXNUb1Njcm9sbCkgOiBieVNpemUoYXJyYXkpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgZ3JvdXBTbGlkZXNcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIEVuZ2luZShyb290LCBjb250YWluZXIsIHNsaWRlcywgb3duZXJEb2N1bWVudCwgb3duZXJXaW5kb3csIG9wdGlvbnMsIGV2ZW50SGFuZGxlcikge1xuICAvLyBPcHRpb25zXG4gIGNvbnN0IHtcbiAgICBhbGlnbixcbiAgICBheGlzOiBzY3JvbGxBeGlzLFxuICAgIGRpcmVjdGlvbixcbiAgICBzdGFydEluZGV4LFxuICAgIGxvb3AsXG4gICAgZHVyYXRpb24sXG4gICAgZHJhZ0ZyZWUsXG4gICAgZHJhZ1RocmVzaG9sZCxcbiAgICBpblZpZXdUaHJlc2hvbGQsXG4gICAgc2xpZGVzVG9TY3JvbGw6IGdyb3VwU2xpZGVzLFxuICAgIHNraXBTbmFwcyxcbiAgICBjb250YWluU2Nyb2xsLFxuICAgIHdhdGNoUmVzaXplLFxuICAgIHdhdGNoU2xpZGVzLFxuICAgIHdhdGNoRHJhZyxcbiAgICB3YXRjaEZvY3VzXG4gIH0gPSBvcHRpb25zO1xuICAvLyBNZWFzdXJlbWVudHNcbiAgY29uc3QgcGl4ZWxUb2xlcmFuY2UgPSAyO1xuICBjb25zdCBub2RlUmVjdHMgPSBOb2RlUmVjdHMoKTtcbiAgY29uc3QgY29udGFpbmVyUmVjdCA9IG5vZGVSZWN0cy5tZWFzdXJlKGNvbnRhaW5lcik7XG4gIGNvbnN0IHNsaWRlUmVjdHMgPSBzbGlkZXMubWFwKG5vZGVSZWN0cy5tZWFzdXJlKTtcbiAgY29uc3QgYXhpcyA9IEF4aXMoc2Nyb2xsQXhpcywgZGlyZWN0aW9uKTtcbiAgY29uc3Qgdmlld1NpemUgPSBheGlzLm1lYXN1cmVTaXplKGNvbnRhaW5lclJlY3QpO1xuICBjb25zdCBwZXJjZW50T2ZWaWV3ID0gUGVyY2VudE9mVmlldyh2aWV3U2l6ZSk7XG4gIGNvbnN0IGFsaWdubWVudCA9IEFsaWdubWVudChhbGlnbiwgdmlld1NpemUpO1xuICBjb25zdCBjb250YWluU25hcHMgPSAhbG9vcCAmJiAhIWNvbnRhaW5TY3JvbGw7XG4gIGNvbnN0IHJlYWRFZGdlR2FwID0gbG9vcCB8fCAhIWNvbnRhaW5TY3JvbGw7XG4gIGNvbnN0IHtcbiAgICBzbGlkZVNpemVzLFxuICAgIHNsaWRlU2l6ZXNXaXRoR2FwcyxcbiAgICBzdGFydEdhcCxcbiAgICBlbmRHYXBcbiAgfSA9IFNsaWRlU2l6ZXMoYXhpcywgY29udGFpbmVyUmVjdCwgc2xpZGVSZWN0cywgc2xpZGVzLCByZWFkRWRnZUdhcCwgb3duZXJXaW5kb3cpO1xuICBjb25zdCBzbGlkZXNUb1Njcm9sbCA9IFNsaWRlc1RvU2Nyb2xsKGF4aXMsIHZpZXdTaXplLCBncm91cFNsaWRlcywgbG9vcCwgY29udGFpbmVyUmVjdCwgc2xpZGVSZWN0cywgc3RhcnRHYXAsIGVuZEdhcCwgcGl4ZWxUb2xlcmFuY2UpO1xuICBjb25zdCB7XG4gICAgc25hcHMsXG4gICAgc25hcHNBbGlnbmVkXG4gIH0gPSBTY3JvbGxTbmFwcyhheGlzLCBhbGlnbm1lbnQsIGNvbnRhaW5lclJlY3QsIHNsaWRlUmVjdHMsIHNsaWRlc1RvU2Nyb2xsKTtcbiAgY29uc3QgY29udGVudFNpemUgPSAtYXJyYXlMYXN0KHNuYXBzKSArIGFycmF5TGFzdChzbGlkZVNpemVzV2l0aEdhcHMpO1xuICBjb25zdCB7XG4gICAgc25hcHNDb250YWluZWQsXG4gICAgc2Nyb2xsQ29udGFpbkxpbWl0XG4gIH0gPSBTY3JvbGxDb250YWluKHZpZXdTaXplLCBjb250ZW50U2l6ZSwgc25hcHNBbGlnbmVkLCBjb250YWluU2Nyb2xsLCBwaXhlbFRvbGVyYW5jZSk7XG4gIGNvbnN0IHNjcm9sbFNuYXBzID0gY29udGFpblNuYXBzID8gc25hcHNDb250YWluZWQgOiBzbmFwc0FsaWduZWQ7XG4gIGNvbnN0IHtcbiAgICBsaW1pdFxuICB9ID0gU2Nyb2xsTGltaXQoY29udGVudFNpemUsIHNjcm9sbFNuYXBzLCBsb29wKTtcbiAgLy8gSW5kZXhlc1xuICBjb25zdCBpbmRleCA9IENvdW50ZXIoYXJyYXlMYXN0SW5kZXgoc2Nyb2xsU25hcHMpLCBzdGFydEluZGV4LCBsb29wKTtcbiAgY29uc3QgaW5kZXhQcmV2aW91cyA9IGluZGV4LmNsb25lKCk7XG4gIGNvbnN0IHNsaWRlSW5kZXhlcyA9IGFycmF5S2V5cyhzbGlkZXMpO1xuICAvLyBBbmltYXRpb25cbiAgY29uc3QgdXBkYXRlID0gKHtcbiAgICBkcmFnSGFuZGxlcixcbiAgICBzY3JvbGxCb2R5LFxuICAgIHNjcm9sbEJvdW5kcyxcbiAgICBvcHRpb25zOiB7XG4gICAgICBsb29wXG4gICAgfVxuICB9KSA9PiB7XG4gICAgaWYgKCFsb29wKSBzY3JvbGxCb3VuZHMuY29uc3RyYWluKGRyYWdIYW5kbGVyLnBvaW50ZXJEb3duKCkpO1xuICAgIHNjcm9sbEJvZHkuc2VlaygpO1xuICB9O1xuICBjb25zdCByZW5kZXIgPSAoe1xuICAgIHNjcm9sbEJvZHksXG4gICAgdHJhbnNsYXRlLFxuICAgIGxvY2F0aW9uLFxuICAgIG9mZnNldExvY2F0aW9uLFxuICAgIHByZXZpb3VzTG9jYXRpb24sXG4gICAgc2Nyb2xsTG9vcGVyLFxuICAgIHNsaWRlTG9vcGVyLFxuICAgIGRyYWdIYW5kbGVyLFxuICAgIGFuaW1hdGlvbixcbiAgICBldmVudEhhbmRsZXIsXG4gICAgc2Nyb2xsQm91bmRzLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGxvb3BcbiAgICB9XG4gIH0sIGFscGhhKSA9PiB7XG4gICAgY29uc3Qgc2hvdWxkU2V0dGxlID0gc2Nyb2xsQm9keS5zZXR0bGVkKCk7XG4gICAgY29uc3Qgd2l0aGluQm91bmRzID0gIXNjcm9sbEJvdW5kcy5zaG91bGRDb25zdHJhaW4oKTtcbiAgICBjb25zdCBoYXNTZXR0bGVkID0gbG9vcCA/IHNob3VsZFNldHRsZSA6IHNob3VsZFNldHRsZSAmJiB3aXRoaW5Cb3VuZHM7XG4gICAgaWYgKGhhc1NldHRsZWQgJiYgIWRyYWdIYW5kbGVyLnBvaW50ZXJEb3duKCkpIHtcbiAgICAgIGFuaW1hdGlvbi5zdG9wKCk7XG4gICAgICBldmVudEhhbmRsZXIuZW1pdCgnc2V0dGxlJyk7XG4gICAgfVxuICAgIGlmICghaGFzU2V0dGxlZCkgZXZlbnRIYW5kbGVyLmVtaXQoJ3Njcm9sbCcpO1xuICAgIGNvbnN0IGludGVycG9sYXRlZExvY2F0aW9uID0gbG9jYXRpb24uZ2V0KCkgKiBhbHBoYSArIHByZXZpb3VzTG9jYXRpb24uZ2V0KCkgKiAoMSAtIGFscGhhKTtcbiAgICBvZmZzZXRMb2NhdGlvbi5zZXQoaW50ZXJwb2xhdGVkTG9jYXRpb24pO1xuICAgIGlmIChsb29wKSB7XG4gICAgICBzY3JvbGxMb29wZXIubG9vcChzY3JvbGxCb2R5LmRpcmVjdGlvbigpKTtcbiAgICAgIHNsaWRlTG9vcGVyLmxvb3AoKTtcbiAgICB9XG4gICAgdHJhbnNsYXRlLnRvKG9mZnNldExvY2F0aW9uLmdldCgpKTtcbiAgfTtcbiAgY29uc3QgYW5pbWF0aW9uID0gQW5pbWF0aW9ucyhvd25lckRvY3VtZW50LCBvd25lcldpbmRvdywgKCkgPT4gdXBkYXRlKGVuZ2luZSksIGFscGhhID0+IHJlbmRlcihlbmdpbmUsIGFscGhhKSk7XG4gIC8vIFNoYXJlZFxuICBjb25zdCBmcmljdGlvbiA9IDAuNjg7XG4gIGNvbnN0IHN0YXJ0TG9jYXRpb24gPSBzY3JvbGxTbmFwc1tpbmRleC5nZXQoKV07XG4gIGNvbnN0IGxvY2F0aW9uID0gVmVjdG9yMUQoc3RhcnRMb2NhdGlvbik7XG4gIGNvbnN0IHByZXZpb3VzTG9jYXRpb24gPSBWZWN0b3IxRChzdGFydExvY2F0aW9uKTtcbiAgY29uc3Qgb2Zmc2V0TG9jYXRpb24gPSBWZWN0b3IxRChzdGFydExvY2F0aW9uKTtcbiAgY29uc3QgdGFyZ2V0ID0gVmVjdG9yMUQoc3RhcnRMb2NhdGlvbik7XG4gIGNvbnN0IHNjcm9sbEJvZHkgPSBTY3JvbGxCb2R5KGxvY2F0aW9uLCBvZmZzZXRMb2NhdGlvbiwgcHJldmlvdXNMb2NhdGlvbiwgdGFyZ2V0LCBkdXJhdGlvbiwgZnJpY3Rpb24pO1xuICBjb25zdCBzY3JvbGxUYXJnZXQgPSBTY3JvbGxUYXJnZXQobG9vcCwgc2Nyb2xsU25hcHMsIGNvbnRlbnRTaXplLCBsaW1pdCwgdGFyZ2V0KTtcbiAgY29uc3Qgc2Nyb2xsVG8gPSBTY3JvbGxUbyhhbmltYXRpb24sIGluZGV4LCBpbmRleFByZXZpb3VzLCBzY3JvbGxCb2R5LCBzY3JvbGxUYXJnZXQsIHRhcmdldCwgZXZlbnRIYW5kbGVyKTtcbiAgY29uc3Qgc2Nyb2xsUHJvZ3Jlc3MgPSBTY3JvbGxQcm9ncmVzcyhsaW1pdCk7XG4gIGNvbnN0IGV2ZW50U3RvcmUgPSBFdmVudFN0b3JlKCk7XG4gIGNvbnN0IHNsaWRlc0luVmlldyA9IFNsaWRlc0luVmlldyhjb250YWluZXIsIHNsaWRlcywgZXZlbnRIYW5kbGVyLCBpblZpZXdUaHJlc2hvbGQpO1xuICBjb25zdCB7XG4gICAgc2xpZGVSZWdpc3RyeVxuICB9ID0gU2xpZGVSZWdpc3RyeShjb250YWluU25hcHMsIGNvbnRhaW5TY3JvbGwsIHNjcm9sbFNuYXBzLCBzY3JvbGxDb250YWluTGltaXQsIHNsaWRlc1RvU2Nyb2xsLCBzbGlkZUluZGV4ZXMpO1xuICBjb25zdCBzbGlkZUZvY3VzID0gU2xpZGVGb2N1cyhyb290LCBzbGlkZXMsIHNsaWRlUmVnaXN0cnksIHNjcm9sbFRvLCBzY3JvbGxCb2R5LCBldmVudFN0b3JlLCBldmVudEhhbmRsZXIsIHdhdGNoRm9jdXMpO1xuICAvLyBFbmdpbmVcbiAgY29uc3QgZW5naW5lID0ge1xuICAgIG93bmVyRG9jdW1lbnQsXG4gICAgb3duZXJXaW5kb3csXG4gICAgZXZlbnRIYW5kbGVyLFxuICAgIGNvbnRhaW5lclJlY3QsXG4gICAgc2xpZGVSZWN0cyxcbiAgICBhbmltYXRpb24sXG4gICAgYXhpcyxcbiAgICBkcmFnSGFuZGxlcjogRHJhZ0hhbmRsZXIoYXhpcywgcm9vdCwgb3duZXJEb2N1bWVudCwgb3duZXJXaW5kb3csIHRhcmdldCwgRHJhZ1RyYWNrZXIoYXhpcywgb3duZXJXaW5kb3cpLCBsb2NhdGlvbiwgYW5pbWF0aW9uLCBzY3JvbGxUbywgc2Nyb2xsQm9keSwgc2Nyb2xsVGFyZ2V0LCBpbmRleCwgZXZlbnRIYW5kbGVyLCBwZXJjZW50T2ZWaWV3LCBkcmFnRnJlZSwgZHJhZ1RocmVzaG9sZCwgc2tpcFNuYXBzLCBmcmljdGlvbiwgd2F0Y2hEcmFnKSxcbiAgICBldmVudFN0b3JlLFxuICAgIHBlcmNlbnRPZlZpZXcsXG4gICAgaW5kZXgsXG4gICAgaW5kZXhQcmV2aW91cyxcbiAgICBsaW1pdCxcbiAgICBsb2NhdGlvbixcbiAgICBvZmZzZXRMb2NhdGlvbixcbiAgICBwcmV2aW91c0xvY2F0aW9uLFxuICAgIG9wdGlvbnMsXG4gICAgcmVzaXplSGFuZGxlcjogUmVzaXplSGFuZGxlcihjb250YWluZXIsIGV2ZW50SGFuZGxlciwgb3duZXJXaW5kb3csIHNsaWRlcywgYXhpcywgd2F0Y2hSZXNpemUsIG5vZGVSZWN0cyksXG4gICAgc2Nyb2xsQm9keSxcbiAgICBzY3JvbGxCb3VuZHM6IFNjcm9sbEJvdW5kcyhsaW1pdCwgb2Zmc2V0TG9jYXRpb24sIHRhcmdldCwgc2Nyb2xsQm9keSwgcGVyY2VudE9mVmlldyksXG4gICAgc2Nyb2xsTG9vcGVyOiBTY3JvbGxMb29wZXIoY29udGVudFNpemUsIGxpbWl0LCBvZmZzZXRMb2NhdGlvbiwgW2xvY2F0aW9uLCBvZmZzZXRMb2NhdGlvbiwgcHJldmlvdXNMb2NhdGlvbiwgdGFyZ2V0XSksXG4gICAgc2Nyb2xsUHJvZ3Jlc3MsXG4gICAgc2Nyb2xsU25hcExpc3Q6IHNjcm9sbFNuYXBzLm1hcChzY3JvbGxQcm9ncmVzcy5nZXQpLFxuICAgIHNjcm9sbFNuYXBzLFxuICAgIHNjcm9sbFRhcmdldCxcbiAgICBzY3JvbGxUbyxcbiAgICBzbGlkZUxvb3BlcjogU2xpZGVMb29wZXIoYXhpcywgdmlld1NpemUsIGNvbnRlbnRTaXplLCBzbGlkZVNpemVzLCBzbGlkZVNpemVzV2l0aEdhcHMsIHNuYXBzLCBzY3JvbGxTbmFwcywgb2Zmc2V0TG9jYXRpb24sIHNsaWRlcyksXG4gICAgc2xpZGVGb2N1cyxcbiAgICBzbGlkZXNIYW5kbGVyOiBTbGlkZXNIYW5kbGVyKGNvbnRhaW5lciwgZXZlbnRIYW5kbGVyLCB3YXRjaFNsaWRlcyksXG4gICAgc2xpZGVzSW5WaWV3LFxuICAgIHNsaWRlSW5kZXhlcyxcbiAgICBzbGlkZVJlZ2lzdHJ5LFxuICAgIHNsaWRlc1RvU2Nyb2xsLFxuICAgIHRhcmdldCxcbiAgICB0cmFuc2xhdGU6IFRyYW5zbGF0ZShheGlzLCBjb250YWluZXIpXG4gIH07XG4gIHJldHVybiBlbmdpbmU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50SGFuZGxlcigpIHtcbiAgbGV0IGxpc3RlbmVycyA9IHt9O1xuICBsZXQgYXBpO1xuICBmdW5jdGlvbiBpbml0KGVtYmxhQXBpKSB7XG4gICAgYXBpID0gZW1ibGFBcGk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0TGlzdGVuZXJzKGV2dCkge1xuICAgIHJldHVybiBsaXN0ZW5lcnNbZXZ0XSB8fCBbXTtcbiAgfVxuICBmdW5jdGlvbiBlbWl0KGV2dCkge1xuICAgIGdldExpc3RlbmVycyhldnQpLmZvckVhY2goZSA9PiBlKGFwaSwgZXZ0KSk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZnVuY3Rpb24gb24oZXZ0LCBjYikge1xuICAgIGxpc3RlbmVyc1tldnRdID0gZ2V0TGlzdGVuZXJzKGV2dCkuY29uY2F0KFtjYl0pO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGZ1bmN0aW9uIG9mZihldnQsIGNiKSB7XG4gICAgbGlzdGVuZXJzW2V2dF0gPSBnZXRMaXN0ZW5lcnMoZXZ0KS5maWx0ZXIoZSA9PiBlICE9PSBjYik7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgbGlzdGVuZXJzID0ge307XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0LFxuICAgIGVtaXQsXG4gICAgb2ZmLFxuICAgIG9uLFxuICAgIGNsZWFyXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgYWxpZ246ICdjZW50ZXInLFxuICBheGlzOiAneCcsXG4gIGNvbnRhaW5lcjogbnVsbCxcbiAgc2xpZGVzOiBudWxsLFxuICBjb250YWluU2Nyb2xsOiAndHJpbVNuYXBzJyxcbiAgZGlyZWN0aW9uOiAnbHRyJyxcbiAgc2xpZGVzVG9TY3JvbGw6IDEsXG4gIGluVmlld1RocmVzaG9sZDogMCxcbiAgYnJlYWtwb2ludHM6IHt9LFxuICBkcmFnRnJlZTogZmFsc2UsXG4gIGRyYWdUaHJlc2hvbGQ6IDEwLFxuICBsb29wOiBmYWxzZSxcbiAgc2tpcFNuYXBzOiBmYWxzZSxcbiAgZHVyYXRpb246IDI1LFxuICBzdGFydEluZGV4OiAwLFxuICBhY3RpdmU6IHRydWUsXG4gIHdhdGNoRHJhZzogdHJ1ZSxcbiAgd2F0Y2hSZXNpemU6IHRydWUsXG4gIHdhdGNoU2xpZGVzOiB0cnVlLFxuICB3YXRjaEZvY3VzOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBPcHRpb25zSGFuZGxlcihvd25lcldpbmRvdykge1xuICBmdW5jdGlvbiBtZXJnZU9wdGlvbnMob3B0aW9uc0EsIG9wdGlvbnNCKSB7XG4gICAgcmV0dXJuIG9iamVjdHNNZXJnZURlZXAob3B0aW9uc0EsIG9wdGlvbnNCIHx8IHt9KTtcbiAgfVxuICBmdW5jdGlvbiBvcHRpb25zQXRNZWRpYShvcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0aW9uc0F0TWVkaWEgPSBvcHRpb25zLmJyZWFrcG9pbnRzIHx8IHt9O1xuICAgIGNvbnN0IG1hdGNoZWRNZWRpYU9wdGlvbnMgPSBvYmplY3RLZXlzKG9wdGlvbnNBdE1lZGlhKS5maWx0ZXIobWVkaWEgPT4gb3duZXJXaW5kb3cubWF0Y2hNZWRpYShtZWRpYSkubWF0Y2hlcykubWFwKG1lZGlhID0+IG9wdGlvbnNBdE1lZGlhW21lZGlhXSkucmVkdWNlKChhLCBtZWRpYU9wdGlvbikgPT4gbWVyZ2VPcHRpb25zKGEsIG1lZGlhT3B0aW9uKSwge30pO1xuICAgIHJldHVybiBtZXJnZU9wdGlvbnMob3B0aW9ucywgbWF0Y2hlZE1lZGlhT3B0aW9ucyk7XG4gIH1cbiAgZnVuY3Rpb24gb3B0aW9uc01lZGlhUXVlcmllcyhvcHRpb25zTGlzdCkge1xuICAgIHJldHVybiBvcHRpb25zTGlzdC5tYXAob3B0aW9ucyA9PiBvYmplY3RLZXlzKG9wdGlvbnMuYnJlYWtwb2ludHMgfHwge30pKS5yZWR1Y2UoKGFjYywgbWVkaWFRdWVyaWVzKSA9PiBhY2MuY29uY2F0KG1lZGlhUXVlcmllcyksIFtdKS5tYXAob3duZXJXaW5kb3cubWF0Y2hNZWRpYSk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBtZXJnZU9wdGlvbnMsXG4gICAgb3B0aW9uc0F0TWVkaWEsXG4gICAgb3B0aW9uc01lZGlhUXVlcmllc1xuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gUGx1Z2luc0hhbmRsZXIob3B0aW9uc0hhbmRsZXIpIHtcbiAgbGV0IGFjdGl2ZVBsdWdpbnMgPSBbXTtcbiAgZnVuY3Rpb24gaW5pdChlbWJsYUFwaSwgcGx1Z2lucykge1xuICAgIGFjdGl2ZVBsdWdpbnMgPSBwbHVnaW5zLmZpbHRlcigoe1xuICAgICAgb3B0aW9uc1xuICAgIH0pID0+IG9wdGlvbnNIYW5kbGVyLm9wdGlvbnNBdE1lZGlhKG9wdGlvbnMpLmFjdGl2ZSAhPT0gZmFsc2UpO1xuICAgIGFjdGl2ZVBsdWdpbnMuZm9yRWFjaChwbHVnaW4gPT4gcGx1Z2luLmluaXQoZW1ibGFBcGksIG9wdGlvbnNIYW5kbGVyKSk7XG4gICAgcmV0dXJuIHBsdWdpbnMucmVkdWNlKChtYXAsIHBsdWdpbikgPT4gT2JqZWN0LmFzc2lnbihtYXAsIHtcbiAgICAgIFtwbHVnaW4ubmFtZV06IHBsdWdpblxuICAgIH0pLCB7fSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBhY3RpdmVQbHVnaW5zID0gYWN0aXZlUGx1Z2lucy5maWx0ZXIocGx1Z2luID0+IHBsdWdpbi5kZXN0cm95KCkpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgaW5pdCxcbiAgICBkZXN0cm95XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBFbWJsYUNhcm91c2VsKHJvb3QsIHVzZXJPcHRpb25zLCB1c2VyUGx1Z2lucykge1xuICBjb25zdCBvd25lckRvY3VtZW50ID0gcm9vdC5vd25lckRvY3VtZW50O1xuICBjb25zdCBvd25lcldpbmRvdyA9IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIGNvbnN0IG9wdGlvbnNIYW5kbGVyID0gT3B0aW9uc0hhbmRsZXIob3duZXJXaW5kb3cpO1xuICBjb25zdCBwbHVnaW5zSGFuZGxlciA9IFBsdWdpbnNIYW5kbGVyKG9wdGlvbnNIYW5kbGVyKTtcbiAgY29uc3QgbWVkaWFIYW5kbGVycyA9IEV2ZW50U3RvcmUoKTtcbiAgY29uc3QgZXZlbnRIYW5kbGVyID0gRXZlbnRIYW5kbGVyKCk7XG4gIGNvbnN0IHtcbiAgICBtZXJnZU9wdGlvbnMsXG4gICAgb3B0aW9uc0F0TWVkaWEsXG4gICAgb3B0aW9uc01lZGlhUXVlcmllc1xuICB9ID0gb3B0aW9uc0hhbmRsZXI7XG4gIGNvbnN0IHtcbiAgICBvbixcbiAgICBvZmYsXG4gICAgZW1pdFxuICB9ID0gZXZlbnRIYW5kbGVyO1xuICBjb25zdCByZUluaXQgPSByZUFjdGl2YXRlO1xuICBsZXQgZGVzdHJveWVkID0gZmFsc2U7XG4gIGxldCBlbmdpbmU7XG4gIGxldCBvcHRpb25zQmFzZSA9IG1lcmdlT3B0aW9ucyhkZWZhdWx0T3B0aW9ucywgRW1ibGFDYXJvdXNlbC5nbG9iYWxPcHRpb25zKTtcbiAgbGV0IG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMob3B0aW9uc0Jhc2UpO1xuICBsZXQgcGx1Z2luTGlzdCA9IFtdO1xuICBsZXQgcGx1Z2luQXBpcztcbiAgbGV0IGNvbnRhaW5lcjtcbiAgbGV0IHNsaWRlcztcbiAgZnVuY3Rpb24gc3RvcmVFbGVtZW50cygpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250YWluZXI6IHVzZXJDb250YWluZXIsXG4gICAgICBzbGlkZXM6IHVzZXJTbGlkZXNcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBjdXN0b21Db250YWluZXIgPSBpc1N0cmluZyh1c2VyQ29udGFpbmVyKSA/IHJvb3QucXVlcnlTZWxlY3Rvcih1c2VyQ29udGFpbmVyKSA6IHVzZXJDb250YWluZXI7XG4gICAgY29udGFpbmVyID0gY3VzdG9tQ29udGFpbmVyIHx8IHJvb3QuY2hpbGRyZW5bMF07XG4gICAgY29uc3QgY3VzdG9tU2xpZGVzID0gaXNTdHJpbmcodXNlclNsaWRlcykgPyBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCh1c2VyU2xpZGVzKSA6IHVzZXJTbGlkZXM7XG4gICAgc2xpZGVzID0gW10uc2xpY2UuY2FsbChjdXN0b21TbGlkZXMgfHwgY29udGFpbmVyLmNoaWxkcmVuKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVFbmdpbmUob3B0aW9ucykge1xuICAgIGNvbnN0IGVuZ2luZSA9IEVuZ2luZShyb290LCBjb250YWluZXIsIHNsaWRlcywgb3duZXJEb2N1bWVudCwgb3duZXJXaW5kb3csIG9wdGlvbnMsIGV2ZW50SGFuZGxlcik7XG4gICAgaWYgKG9wdGlvbnMubG9vcCAmJiAhZW5naW5lLnNsaWRlTG9vcGVyLmNhbkxvb3AoKSkge1xuICAgICAgY29uc3Qgb3B0aW9uc1dpdGhvdXRMb29wID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICBsb29wOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY3JlYXRlRW5naW5lKG9wdGlvbnNXaXRob3V0TG9vcCk7XG4gICAgfVxuICAgIHJldHVybiBlbmdpbmU7XG4gIH1cbiAgZnVuY3Rpb24gYWN0aXZhdGUod2l0aE9wdGlvbnMsIHdpdGhQbHVnaW5zKSB7XG4gICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgIG9wdGlvbnNCYXNlID0gbWVyZ2VPcHRpb25zKG9wdGlvbnNCYXNlLCB3aXRoT3B0aW9ucyk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnNBdE1lZGlhKG9wdGlvbnNCYXNlKTtcbiAgICBwbHVnaW5MaXN0ID0gd2l0aFBsdWdpbnMgfHwgcGx1Z2luTGlzdDtcbiAgICBzdG9yZUVsZW1lbnRzKCk7XG4gICAgZW5naW5lID0gY3JlYXRlRW5naW5lKG9wdGlvbnMpO1xuICAgIG9wdGlvbnNNZWRpYVF1ZXJpZXMoW29wdGlvbnNCYXNlLCAuLi5wbHVnaW5MaXN0Lm1hcCgoe1xuICAgICAgb3B0aW9uc1xuICAgIH0pID0+IG9wdGlvbnMpXSkuZm9yRWFjaChxdWVyeSA9PiBtZWRpYUhhbmRsZXJzLmFkZChxdWVyeSwgJ2NoYW5nZScsIHJlQWN0aXZhdGUpKTtcbiAgICBpZiAoIW9wdGlvbnMuYWN0aXZlKSByZXR1cm47XG4gICAgZW5naW5lLnRyYW5zbGF0ZS50byhlbmdpbmUubG9jYXRpb24uZ2V0KCkpO1xuICAgIGVuZ2luZS5hbmltYXRpb24uaW5pdCgpO1xuICAgIGVuZ2luZS5zbGlkZXNJblZpZXcuaW5pdCgpO1xuICAgIGVuZ2luZS5zbGlkZUZvY3VzLmluaXQoc2VsZik7XG4gICAgZW5naW5lLmV2ZW50SGFuZGxlci5pbml0KHNlbGYpO1xuICAgIGVuZ2luZS5yZXNpemVIYW5kbGVyLmluaXQoc2VsZik7XG4gICAgZW5naW5lLnNsaWRlc0hhbmRsZXIuaW5pdChzZWxmKTtcbiAgICBpZiAoZW5naW5lLm9wdGlvbnMubG9vcCkgZW5naW5lLnNsaWRlTG9vcGVyLmxvb3AoKTtcbiAgICBpZiAoY29udGFpbmVyLm9mZnNldFBhcmVudCAmJiBzbGlkZXMubGVuZ3RoKSBlbmdpbmUuZHJhZ0hhbmRsZXIuaW5pdChzZWxmKTtcbiAgICBwbHVnaW5BcGlzID0gcGx1Z2luc0hhbmRsZXIuaW5pdChzZWxmLCBwbHVnaW5MaXN0KTtcbiAgfVxuICBmdW5jdGlvbiByZUFjdGl2YXRlKHdpdGhPcHRpb25zLCB3aXRoUGx1Z2lucykge1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBzZWxlY3RlZFNjcm9sbFNuYXAoKTtcbiAgICBkZUFjdGl2YXRlKCk7XG4gICAgYWN0aXZhdGUobWVyZ2VPcHRpb25zKHtcbiAgICAgIHN0YXJ0SW5kZXhcbiAgICB9LCB3aXRoT3B0aW9ucyksIHdpdGhQbHVnaW5zKTtcbiAgICBldmVudEhhbmRsZXIuZW1pdCgncmVJbml0Jyk7XG4gIH1cbiAgZnVuY3Rpb24gZGVBY3RpdmF0ZSgpIHtcbiAgICBlbmdpbmUuZHJhZ0hhbmRsZXIuZGVzdHJveSgpO1xuICAgIGVuZ2luZS5ldmVudFN0b3JlLmNsZWFyKCk7XG4gICAgZW5naW5lLnRyYW5zbGF0ZS5jbGVhcigpO1xuICAgIGVuZ2luZS5zbGlkZUxvb3Blci5jbGVhcigpO1xuICAgIGVuZ2luZS5yZXNpemVIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICBlbmdpbmUuc2xpZGVzSGFuZGxlci5kZXN0cm95KCk7XG4gICAgZW5naW5lLnNsaWRlc0luVmlldy5kZXN0cm95KCk7XG4gICAgZW5naW5lLmFuaW1hdGlvbi5kZXN0cm95KCk7XG4gICAgcGx1Z2luc0hhbmRsZXIuZGVzdHJveSgpO1xuICAgIG1lZGlhSGFuZGxlcnMuY2xlYXIoKTtcbiAgfVxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGlmIChkZXN0cm95ZWQpIHJldHVybjtcbiAgICBkZXN0cm95ZWQgPSB0cnVlO1xuICAgIG1lZGlhSGFuZGxlcnMuY2xlYXIoKTtcbiAgICBkZUFjdGl2YXRlKCk7XG4gICAgZXZlbnRIYW5kbGVyLmVtaXQoJ2Rlc3Ryb3knKTtcbiAgICBldmVudEhhbmRsZXIuY2xlYXIoKTtcbiAgfVxuICBmdW5jdGlvbiBzY3JvbGxUbyhpbmRleCwganVtcCwgZGlyZWN0aW9uKSB7XG4gICAgaWYgKCFvcHRpb25zLmFjdGl2ZSB8fCBkZXN0cm95ZWQpIHJldHVybjtcbiAgICBlbmdpbmUuc2Nyb2xsQm9keS51c2VCYXNlRnJpY3Rpb24oKS51c2VEdXJhdGlvbihqdW1wID09PSB0cnVlID8gMCA6IG9wdGlvbnMuZHVyYXRpb24pO1xuICAgIGVuZ2luZS5zY3JvbGxUby5pbmRleChpbmRleCwgZGlyZWN0aW9uIHx8IDApO1xuICB9XG4gIGZ1bmN0aW9uIHNjcm9sbE5leHQoanVtcCkge1xuICAgIGNvbnN0IG5leHQgPSBlbmdpbmUuaW5kZXguYWRkKDEpLmdldCgpO1xuICAgIHNjcm9sbFRvKG5leHQsIGp1bXAsIC0xKTtcbiAgfVxuICBmdW5jdGlvbiBzY3JvbGxQcmV2KGp1bXApIHtcbiAgICBjb25zdCBwcmV2ID0gZW5naW5lLmluZGV4LmFkZCgtMSkuZ2V0KCk7XG4gICAgc2Nyb2xsVG8ocHJldiwganVtcCwgMSk7XG4gIH1cbiAgZnVuY3Rpb24gY2FuU2Nyb2xsTmV4dCgpIHtcbiAgICBjb25zdCBuZXh0ID0gZW5naW5lLmluZGV4LmFkZCgxKS5nZXQoKTtcbiAgICByZXR1cm4gbmV4dCAhPT0gc2VsZWN0ZWRTY3JvbGxTbmFwKCk7XG4gIH1cbiAgZnVuY3Rpb24gY2FuU2Nyb2xsUHJldigpIHtcbiAgICBjb25zdCBwcmV2ID0gZW5naW5lLmluZGV4LmFkZCgtMSkuZ2V0KCk7XG4gICAgcmV0dXJuIHByZXYgIT09IHNlbGVjdGVkU2Nyb2xsU25hcCgpO1xuICB9XG4gIGZ1bmN0aW9uIHNjcm9sbFNuYXBMaXN0KCkge1xuICAgIHJldHVybiBlbmdpbmUuc2Nyb2xsU25hcExpc3Q7XG4gIH1cbiAgZnVuY3Rpb24gc2Nyb2xsUHJvZ3Jlc3MoKSB7XG4gICAgcmV0dXJuIGVuZ2luZS5zY3JvbGxQcm9ncmVzcy5nZXQoZW5naW5lLmxvY2F0aW9uLmdldCgpKTtcbiAgfVxuICBmdW5jdGlvbiBzZWxlY3RlZFNjcm9sbFNuYXAoKSB7XG4gICAgcmV0dXJuIGVuZ2luZS5pbmRleC5nZXQoKTtcbiAgfVxuICBmdW5jdGlvbiBwcmV2aW91c1Njcm9sbFNuYXAoKSB7XG4gICAgcmV0dXJuIGVuZ2luZS5pbmRleFByZXZpb3VzLmdldCgpO1xuICB9XG4gIGZ1bmN0aW9uIHNsaWRlc0luVmlldygpIHtcbiAgICByZXR1cm4gZW5naW5lLnNsaWRlc0luVmlldy5nZXQoKTtcbiAgfVxuICBmdW5jdGlvbiBzbGlkZXNOb3RJblZpZXcoKSB7XG4gICAgcmV0dXJuIGVuZ2luZS5zbGlkZXNJblZpZXcuZ2V0KGZhbHNlKTtcbiAgfVxuICBmdW5jdGlvbiBwbHVnaW5zKCkge1xuICAgIHJldHVybiBwbHVnaW5BcGlzO1xuICB9XG4gIGZ1bmN0aW9uIGludGVybmFsRW5naW5lKCkge1xuICAgIHJldHVybiBlbmdpbmU7XG4gIH1cbiAgZnVuY3Rpb24gcm9vdE5vZGUoKSB7XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH1cbiAgZnVuY3Rpb24gY29udGFpbmVyTm9kZSgpIHtcbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9XG4gIGZ1bmN0aW9uIHNsaWRlTm9kZXMoKSB7XG4gICAgcmV0dXJuIHNsaWRlcztcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGNhblNjcm9sbE5leHQsXG4gICAgY2FuU2Nyb2xsUHJldixcbiAgICBjb250YWluZXJOb2RlLFxuICAgIGludGVybmFsRW5naW5lLFxuICAgIGRlc3Ryb3ksXG4gICAgb2ZmLFxuICAgIG9uLFxuICAgIGVtaXQsXG4gICAgcGx1Z2lucyxcbiAgICBwcmV2aW91c1Njcm9sbFNuYXAsXG4gICAgcmVJbml0LFxuICAgIHJvb3ROb2RlLFxuICAgIHNjcm9sbE5leHQsXG4gICAgc2Nyb2xsUHJldixcbiAgICBzY3JvbGxQcm9ncmVzcyxcbiAgICBzY3JvbGxTbmFwTGlzdCxcbiAgICBzY3JvbGxUbyxcbiAgICBzZWxlY3RlZFNjcm9sbFNuYXAsXG4gICAgc2xpZGVOb2RlcyxcbiAgICBzbGlkZXNJblZpZXcsXG4gICAgc2xpZGVzTm90SW5WaWV3XG4gIH07XG4gIGFjdGl2YXRlKHVzZXJPcHRpb25zLCB1c2VyUGx1Z2lucyk7XG4gIHNldFRpbWVvdXQoKCkgPT4gZXZlbnRIYW5kbGVyLmVtaXQoJ2luaXQnKSwgMCk7XG4gIHJldHVybiBzZWxmO1xufVxuRW1ibGFDYXJvdXNlbC5nbG9iYWxPcHRpb25zID0gdW5kZWZpbmVkO1xuXG5leHBvcnQgeyBFbWJsYUNhcm91c2VsIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVtYmxhLWNhcm91c2VsLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJpc051bWJlciIsInN1YmplY3QiLCJpc1N0cmluZyIsImlzQm9vbGVhbiIsImlzT2JqZWN0IiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwibWF0aEFicyIsIm4iLCJNYXRoIiwiYWJzIiwibWF0aFNpZ24iLCJzaWduIiwiZGVsdGFBYnMiLCJ2YWx1ZUIiLCJ2YWx1ZUEiLCJmYWN0b3JBYnMiLCJkaWZmIiwicm91bmRUb1R3b0RlY2ltYWxzIiwibnVtIiwicm91bmQiLCJhcnJheUtleXMiLCJhcnJheSIsIm9iamVjdEtleXMiLCJtYXAiLCJOdW1iZXIiLCJhcnJheUxhc3QiLCJhcnJheUxhc3RJbmRleCIsIm1heCIsImxlbmd0aCIsImFycmF5SXNMYXN0SW5kZXgiLCJpbmRleCIsImFycmF5RnJvbU51bWJlciIsInN0YXJ0QXQiLCJBcnJheSIsImZyb20iLCJfIiwiaSIsIm9iamVjdCIsImtleXMiLCJvYmplY3RzTWVyZ2VEZWVwIiwib2JqZWN0QSIsIm9iamVjdEIiLCJyZWR1Y2UiLCJtZXJnZWRPYmplY3RzIiwiY3VycmVudE9iamVjdCIsImZvckVhY2giLCJrZXkiLCJhcmVPYmplY3RzIiwiaXNNb3VzZUV2ZW50IiwiZXZ0Iiwib3duZXJXaW5kb3ciLCJNb3VzZUV2ZW50IiwiQWxpZ25tZW50IiwiYWxpZ24iLCJ2aWV3U2l6ZSIsInByZWRlZmluZWQiLCJzdGFydCIsImNlbnRlciIsImVuZCIsIm1lYXN1cmUiLCJzZWxmIiwiRXZlbnRTdG9yZSIsImxpc3RlbmVycyIsImFkZCIsIm5vZGUiLCJ0eXBlIiwiaGFuZGxlciIsIm9wdGlvbnMiLCJwYXNzaXZlIiwicmVtb3ZlTGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImxlZ2FjeU1lZGlhUXVlcnlMaXN0IiwiYWRkTGlzdGVuZXIiLCJwdXNoIiwiY2xlYXIiLCJmaWx0ZXIiLCJyZW1vdmUiLCJBbmltYXRpb25zIiwib3duZXJEb2N1bWVudCIsInVwZGF0ZSIsInJlbmRlciIsImRvY3VtZW50VmlzaWJsZUhhbmRsZXIiLCJmaXhlZFRpbWVTdGVwIiwibGFzdFRpbWVTdGFtcCIsImFjY3VtdWxhdGVkVGltZSIsImFuaW1hdGlvbklkIiwiaW5pdCIsImhpZGRlbiIsInJlc2V0IiwiZGVzdHJveSIsInN0b3AiLCJhbmltYXRlIiwidGltZVN0YW1wIiwidGltZUVsYXBzZWQiLCJhbHBoYSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiQXhpcyIsImF4aXMiLCJjb250ZW50RGlyZWN0aW9uIiwiaXNSaWdodFRvTGVmdCIsImlzVmVydGljYWwiLCJzY3JvbGwiLCJjcm9zcyIsInN0YXJ0RWRnZSIsImdldFN0YXJ0RWRnZSIsImVuZEVkZ2UiLCJnZXRFbmRFZGdlIiwibWVhc3VyZVNpemUiLCJub2RlUmVjdCIsImhlaWdodCIsIndpZHRoIiwiZGlyZWN0aW9uIiwiTGltaXQiLCJtaW4iLCJyZWFjaGVkTWluIiwicmVhY2hlZE1heCIsInJlYWNoZWRBbnkiLCJjb25zdHJhaW4iLCJyZW1vdmVPZmZzZXQiLCJjZWlsIiwiQ291bnRlciIsImxvb3AiLCJsb29wRW5kIiwiY291bnRlciIsIndpdGhpbkxpbWl0IiwiZ2V0Iiwic2V0IiwiY2xvbmUiLCJEcmFnSGFuZGxlciIsInJvb3ROb2RlIiwidGFyZ2V0IiwiZHJhZ1RyYWNrZXIiLCJsb2NhdGlvbiIsImFuaW1hdGlvbiIsInNjcm9sbFRvIiwic2Nyb2xsQm9keSIsInNjcm9sbFRhcmdldCIsImV2ZW50SGFuZGxlciIsInBlcmNlbnRPZlZpZXciLCJkcmFnRnJlZSIsImRyYWdUaHJlc2hvbGQiLCJza2lwU25hcHMiLCJiYXNlRnJpY3Rpb24iLCJ3YXRjaERyYWciLCJjcm9zc0F4aXMiLCJmb2N1c05vZGVzIiwibm9uUGFzc2l2ZUV2ZW50IiwiaW5pdEV2ZW50cyIsImRyYWdFdmVudHMiLCJnb1RvTmV4dFRocmVzaG9sZCIsInNuYXBGb3JjZUJvb3N0IiwibW91c2UiLCJ0b3VjaCIsImZyZWVGb3JjZUJvb3N0IiwiYmFzZVNwZWVkIiwiaXNNb3ZpbmciLCJzdGFydFNjcm9sbCIsInN0YXJ0Q3Jvc3MiLCJwb2ludGVySXNEb3duIiwicHJldmVudFNjcm9sbCIsInByZXZlbnRDbGljayIsImlzTW91c2UiLCJlbWJsYUFwaSIsImRvd25JZkFsbG93ZWQiLCJkb3duIiwicHJldmVudERlZmF1bHQiLCJ1bmRlZmluZWQiLCJ1cCIsImNsaWNrIiwiYWRkRHJhZ0V2ZW50cyIsIm1vdmUiLCJpc0ZvY3VzTm9kZSIsIm5vZGVOYW1lIiwiaW5jbHVkZXMiLCJmb3JjZUJvb3N0IiwiYm9vc3QiLCJhbGxvd2VkRm9yY2UiLCJmb3JjZSIsInRhcmdldENoYW5nZWQiLCJuZXh0IiwiYmFzZUZvcmNlIiwiYnlEaXN0YW5jZSIsImRpc3RhbmNlIiwiYnlJbmRleCIsImlzTW91c2VFdnQiLCJidXR0b25zIiwiYnV0dG9uIiwicG9pbnRlckRvd24iLCJ1c2VGcmljdGlvbiIsInVzZUR1cmF0aW9uIiwicmVhZFBvaW50IiwiZW1pdCIsImlzVG91Y2hFdnQiLCJ0b3VjaGVzIiwibGFzdFNjcm9sbCIsImxhc3RDcm9zcyIsImRpZmZTY3JvbGwiLCJkaWZmQ3Jvc3MiLCJjYW5jZWxhYmxlIiwicG9pbnRlck1vdmUiLCJjdXJyZW50TG9jYXRpb24iLCJyYXdGb3JjZSIsInBvaW50ZXJVcCIsImZvcmNlRmFjdG9yIiwic3BlZWQiLCJmcmljdGlvbiIsInN0b3BQcm9wYWdhdGlvbiIsIkRyYWdUcmFja2VyIiwibG9nSW50ZXJ2YWwiLCJzdGFydEV2ZW50IiwibGFzdEV2ZW50IiwicmVhZFRpbWUiLCJldnRBeGlzIiwicHJvcGVydHkiLCJjb29yZCIsImV4cGlyZWQiLCJkaWZmRHJhZyIsImRpZmZUaW1lIiwiaXNGbGljayIsIk5vZGVSZWN0cyIsIm9mZnNldFRvcCIsIm9mZnNldExlZnQiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsIm9mZnNldCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwibGVmdCIsIlBlcmNlbnRPZlZpZXciLCJSZXNpemVIYW5kbGVyIiwiY29udGFpbmVyIiwic2xpZGVzIiwid2F0Y2hSZXNpemUiLCJub2RlUmVjdHMiLCJvYnNlcnZlTm9kZXMiLCJjb25jYXQiLCJyZXNpemVPYnNlcnZlciIsImNvbnRhaW5lclNpemUiLCJzbGlkZVNpemVzIiwiZGVzdHJveWVkIiwicmVhZFNpemUiLCJkZWZhdWx0Q2FsbGJhY2siLCJlbnRyaWVzIiwiZW50cnkiLCJpc0NvbnRhaW5lciIsInNsaWRlSW5kZXgiLCJpbmRleE9mIiwibGFzdFNpemUiLCJuZXdTaXplIiwiZGlmZlNpemUiLCJyZUluaXQiLCJSZXNpemVPYnNlcnZlciIsIm9ic2VydmUiLCJkaXNjb25uZWN0IiwiU2Nyb2xsQm9keSIsIm9mZnNldExvY2F0aW9uIiwicHJldmlvdXNMb2NhdGlvbiIsImJhc2VEdXJhdGlvbiIsInNjcm9sbFZlbG9jaXR5Iiwic2Nyb2xsRGlyZWN0aW9uIiwic2Nyb2xsRHVyYXRpb24iLCJzY3JvbGxGcmljdGlvbiIsInJhd0xvY2F0aW9uIiwicmF3TG9jYXRpb25QcmV2aW91cyIsInNlZWsiLCJkaXNwbGFjZW1lbnQiLCJpc0luc3RhbnQiLCJzY3JvbGxEaXN0YW5jZSIsInNldHRsZWQiLCJkdXJhdGlvbiIsInZlbG9jaXR5IiwidXNlQmFzZUR1cmF0aW9uIiwidXNlQmFzZUZyaWN0aW9uIiwiU2Nyb2xsQm91bmRzIiwibGltaXQiLCJwdWxsQmFja1RocmVzaG9sZCIsImVkZ2VPZmZzZXRUb2xlcmFuY2UiLCJmcmljdGlvbkxpbWl0IiwiZGlzYWJsZWQiLCJzaG91bGRDb25zdHJhaW4iLCJlZGdlIiwiZGlmZlRvRWRnZSIsImRpZmZUb1RhcmdldCIsInN1YnRyYWN0IiwidG9nZ2xlQWN0aXZlIiwiYWN0aXZlIiwiU2Nyb2xsQ29udGFpbiIsImNvbnRlbnRTaXplIiwic25hcHNBbGlnbmVkIiwiY29udGFpblNjcm9sbCIsInBpeGVsVG9sZXJhbmNlIiwic2Nyb2xsQm91bmRzIiwic25hcHNCb3VuZGVkIiwibWVhc3VyZUJvdW5kZWQiLCJzY3JvbGxDb250YWluTGltaXQiLCJmaW5kU2Nyb2xsQ29udGFpbkxpbWl0Iiwic25hcHNDb250YWluZWQiLCJtZWFzdXJlQ29udGFpbmVkIiwidXNlUGl4ZWxUb2xlcmFuY2UiLCJib3VuZCIsInNuYXAiLCJzdGFydFNuYXAiLCJlbmRTbmFwIiwibGFzdEluZGV4T2YiLCJzbmFwQWxpZ25lZCIsImlzRmlyc3QiLCJpc0xhc3QiLCJzY3JvbGxCb3VuZCIsInBhcnNlRmxvYXQiLCJ0b0ZpeGVkIiwic2xpY2UiLCJTY3JvbGxMaW1pdCIsInNjcm9sbFNuYXBzIiwiU2Nyb2xsTG9vcGVyIiwidmVjdG9ycyIsImpvaW50U2FmZXR5Iiwic2hvdWxkTG9vcCIsImxvb3BEaXN0YW5jZSIsInYiLCJTY3JvbGxQcm9ncmVzcyIsIlNjcm9sbFNuYXBzIiwiYWxpZ25tZW50IiwiY29udGFpbmVyUmVjdCIsInNsaWRlUmVjdHMiLCJzbGlkZXNUb1Njcm9sbCIsImdyb3VwU2xpZGVzIiwiYWxpZ25tZW50cyIsIm1lYXN1cmVTaXplcyIsInNuYXBzIiwibWVhc3VyZVVuYWxpZ25lZCIsIm1lYXN1cmVBbGlnbmVkIiwicmVjdHMiLCJyZWN0IiwiZyIsIlNsaWRlUmVnaXN0cnkiLCJjb250YWluU25hcHMiLCJzbGlkZUluZGV4ZXMiLCJzbGlkZVJlZ2lzdHJ5IiwiY3JlYXRlU2xpZGVSZWdpc3RyeSIsImdyb3VwZWRTbGlkZUluZGV4ZXMiLCJkb05vdENvbnRhaW4iLCJncm91cCIsImdyb3VwcyIsInJhbmdlIiwiU2Nyb2xsVGFyZ2V0IiwidGFyZ2V0VmVjdG9yIiwibWluRGlzdGFuY2UiLCJkaXN0YW5jZXMiLCJzb3J0IiwiYSIsImIiLCJmaW5kVGFyZ2V0U25hcCIsImFzY0RpZmZzVG9TbmFwcyIsInNob3J0Y3V0IiwiZDEiLCJkMiIsInRhcmdldHMiLCJtYXRjaGluZ1RhcmdldHMiLCJ0IiwiZGlmZlRvU25hcCIsInRhcmdldFNuYXBEaXN0YW5jZSIsInJlYWNoZWRCb3VuZCIsInNuYXBEaXN0YW5jZSIsIlNjcm9sbFRvIiwiaW5kZXhDdXJyZW50IiwiaW5kZXhQcmV2aW91cyIsImRpc3RhbmNlRGlmZiIsImluZGV4RGlmZiIsInRhcmdldEluZGV4IiwiU2xpZGVGb2N1cyIsInJvb3QiLCJldmVudFN0b3JlIiwid2F0Y2hGb2N1cyIsImZvY3VzTGlzdGVuZXJPcHRpb25zIiwiY2FwdHVyZSIsImxhc3RUYWJQcmVzc1RpbWUiLCJub3dUaW1lIiwiRGF0ZSIsImdldFRpbWUiLCJzY3JvbGxMZWZ0IiwiZmluZEluZGV4IiwiZG9jdW1lbnQiLCJyZWdpc3RlclRhYlByZXNzIiwic2xpZGUiLCJldmVudCIsImNvZGUiLCJWZWN0b3IxRCIsImluaXRpYWxWYWx1ZSIsInZhbHVlIiwibm9ybWFsaXplSW5wdXQiLCJUcmFuc2xhdGUiLCJ0cmFuc2xhdGUiLCJ4IiwieSIsImNvbnRhaW5lclN0eWxlIiwic3R5bGUiLCJwcmV2aW91c1RhcmdldCIsInRvIiwibmV3VGFyZ2V0IiwidHJhbnNmb3JtIiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiU2xpZGVMb29wZXIiLCJzbGlkZVNpemVzV2l0aEdhcHMiLCJyb3VuZGluZ1NhZmV0eSIsImFzY0l0ZW1zIiwiZGVzY0l0ZW1zIiwicmV2ZXJzZSIsImxvb3BQb2ludHMiLCJzdGFydFBvaW50cyIsImVuZFBvaW50cyIsInJlbW92ZVNsaWRlU2l6ZXMiLCJpbmRleGVzIiwic2xpZGVzSW5HYXAiLCJnYXAiLCJyZW1haW5pbmdHYXAiLCJmaW5kU2xpZGVCb3VuZHMiLCJmaW5kTG9vcFBvaW50cyIsImlzRW5kRWRnZSIsInNsaWRlQm91bmRzIiwiaW5pdGlhbCIsImFsdGVyZWQiLCJib3VuZEVkZ2UiLCJsb29wUG9pbnQiLCJzbGlkZUxvY2F0aW9uIiwiY2FuTG9vcCIsImV2ZXJ5Iiwib3RoZXJJbmRleGVzIiwic2hpZnRMb2NhdGlvbiIsIlNsaWRlc0hhbmRsZXIiLCJ3YXRjaFNsaWRlcyIsIm11dGF0aW9uT2JzZXJ2ZXIiLCJtdXRhdGlvbnMiLCJtdXRhdGlvbiIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJjaGlsZExpc3QiLCJTbGlkZXNJblZpZXciLCJ0aHJlc2hvbGQiLCJpbnRlcnNlY3Rpb25FbnRyeU1hcCIsImluVmlld0NhY2hlIiwibm90SW5WaWV3Q2FjaGUiLCJpbnRlcnNlY3Rpb25PYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwicGFyZW50RWxlbWVudCIsImNyZWF0ZUluVmlld0xpc3QiLCJpblZpZXciLCJsaXN0IiwicGFyc2VJbnQiLCJpc0ludGVyc2VjdGluZyIsImluVmlld01hdGNoIiwibm90SW5WaWV3TWF0Y2giLCJTbGlkZVNpemVzIiwicmVhZEVkZ2VHYXAiLCJ3aXRoRWRnZUdhcCIsInN0YXJ0R2FwIiwibWVhc3VyZVN0YXJ0R2FwIiwiZW5kR2FwIiwibWVhc3VyZUVuZEdhcCIsIm1lYXN1cmVXaXRoR2FwcyIsInNsaWRlUmVjdCIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiU2xpZGVzVG9TY3JvbGwiLCJncm91cEJ5TnVtYmVyIiwiYnlOdW1iZXIiLCJncm91cFNpemUiLCJieVNpemUiLCJyZWN0QiIsInJlY3RBIiwiZWRnZUEiLCJlZGdlQiIsImdhcEEiLCJnYXBCIiwiY2h1bmtTaXplIiwiY3VycmVudFNpemUiLCJwcmV2aW91c1NpemUiLCJFbmdpbmUiLCJzY3JvbGxBeGlzIiwic3RhcnRJbmRleCIsImluVmlld1RocmVzaG9sZCIsImRyYWdIYW5kbGVyIiwic2Nyb2xsTG9vcGVyIiwic2xpZGVMb29wZXIiLCJzaG91bGRTZXR0bGUiLCJ3aXRoaW5Cb3VuZHMiLCJoYXNTZXR0bGVkIiwiaW50ZXJwb2xhdGVkTG9jYXRpb24iLCJlbmdpbmUiLCJzdGFydExvY2F0aW9uIiwic2Nyb2xsUHJvZ3Jlc3MiLCJzbGlkZXNJblZpZXciLCJzbGlkZUZvY3VzIiwicmVzaXplSGFuZGxlciIsInNjcm9sbFNuYXBMaXN0Iiwic2xpZGVzSGFuZGxlciIsIkV2ZW50SGFuZGxlciIsImFwaSIsImdldExpc3RlbmVycyIsImUiLCJvbiIsImNiIiwib2ZmIiwiZGVmYXVsdE9wdGlvbnMiLCJicmVha3BvaW50cyIsIk9wdGlvbnNIYW5kbGVyIiwibWVyZ2VPcHRpb25zIiwib3B0aW9uc0EiLCJvcHRpb25zQiIsIm9wdGlvbnNBdE1lZGlhIiwibWF0Y2hlZE1lZGlhT3B0aW9ucyIsIm1lZGlhIiwibWF0Y2hNZWRpYSIsIm1hdGNoZXMiLCJtZWRpYU9wdGlvbiIsIm9wdGlvbnNNZWRpYVF1ZXJpZXMiLCJvcHRpb25zTGlzdCIsImFjYyIsIm1lZGlhUXVlcmllcyIsIlBsdWdpbnNIYW5kbGVyIiwib3B0aW9uc0hhbmRsZXIiLCJhY3RpdmVQbHVnaW5zIiwicGx1Z2lucyIsInBsdWdpbiIsImFzc2lnbiIsIm5hbWUiLCJFbWJsYUNhcm91c2VsIiwidXNlck9wdGlvbnMiLCJ1c2VyUGx1Z2lucyIsImRlZmF1bHRWaWV3IiwicGx1Z2luc0hhbmRsZXIiLCJtZWRpYUhhbmRsZXJzIiwicmVBY3RpdmF0ZSIsIm9wdGlvbnNCYXNlIiwiZ2xvYmFsT3B0aW9ucyIsInBsdWdpbkxpc3QiLCJwbHVnaW5BcGlzIiwic3RvcmVFbGVtZW50cyIsInVzZXJDb250YWluZXIiLCJ1c2VyU2xpZGVzIiwiY3VzdG9tQ29udGFpbmVyIiwicXVlcnlTZWxlY3RvciIsImNoaWxkcmVuIiwiY3VzdG9tU2xpZGVzIiwicXVlcnlTZWxlY3RvckFsbCIsImNyZWF0ZUVuZ2luZSIsIm9wdGlvbnNXaXRob3V0TG9vcCIsImFjdGl2YXRlIiwid2l0aE9wdGlvbnMiLCJ3aXRoUGx1Z2lucyIsInF1ZXJ5Iiwib2Zmc2V0UGFyZW50Iiwic2VsZWN0ZWRTY3JvbGxTbmFwIiwiZGVBY3RpdmF0ZSIsImp1bXAiLCJzY3JvbGxOZXh0Iiwic2Nyb2xsUHJldiIsInByZXYiLCJjYW5TY3JvbGxOZXh0IiwiY2FuU2Nyb2xsUHJldiIsInByZXZpb3VzU2Nyb2xsU25hcCIsInNsaWRlc05vdEluVmlldyIsImludGVybmFsRW5naW5lIiwiY29udGFpbmVyTm9kZSIsInNsaWRlTm9kZXMiLCJzZXRUaW1lb3V0IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/embla-carousel/esm/embla-carousel.esm.js\n");

/***/ })

};
;